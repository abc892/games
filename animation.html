<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGL GPU Stress Test</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    font-family: monospace;
  }
  #fps {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 14px;
    color: white;
    background: rgba(0,0,0,0.5);
    padding: 2px 5px;
    border-radius: 3px;
    display: none;
  }
  #settingsBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 14px;
    color: white;
    background: rgba(0,0,0,0.5);
    padding: 2px 5px;
    border-radius: 3px;
    cursor: pointer;
  }
  #settingsOverlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    display: none;
    color: white;
    text-align: center;
    padding-top: 50px;
  }
  #settingsOverlay input[type=range] {
    width: 300px;
  }
  #backBtn {
    margin-top: 20px;
    font-size: 14px;
    padding: 5px 10px;
    cursor: pointer;
  }
  .toggle-label {
    display: block;
    margin: 15px 0 5px;
    font-size: 16px;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="fps"></div>
<div id="settingsBtn">Settings</div>
<div id="settingsOverlay">
  <div>
    <label>Animation Quality: <span id="qualityValue">50</span></label><br>
    <input id="qualitySlider" type="range" min="10" max="100" step="1" value="50">
  </div>
  <div>
    <label class="toggle-label"><input type="checkbox" id="cpuToggle"> CPU</label>
  </div>
  <div>
    <label class="toggle-label"><input type="checkbox" id="strToggle"> STR</label>
  </div>
  <button id="backBtn">Back</button>
</div>

<script type="text/javascript">
const canvas = document.getElementById("glcanvas");
const fpsDisplay = document.getElementById("fps");
const settingsBtn = document.getElementById("settingsBtn");
const settingsOverlay = document.getElementById("settingsOverlay");
const qualitySlider = document.getElementById("qualitySlider");
const qualityValue = document.getElementById("qualityValue");
const backBtn = document.getElementById("backBtn");
const cpuToggle = document.getElementById("cpuToggle");
const strToggle = document.getElementById("strToggle");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
if (!gl) alert("WebGL not supported in your browser.");

// Vertex shader
const vsSource = `
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0, 1);
}
`;

// Fragment shader
const fsSource = `
precision highp float;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_detail;

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    float x = uv.x * 10.0;
    float y = uv.y * 10.0;
    float val = 0.0;

    int maxSteps = int(500.0 * u_detail);
    for(int i = 0; i < 1000; i++) {
        if(i >= maxSteps) break;
        val += sin(x*float(i)+u_time) * cos(y*float(i)+u_time);
        val = mod(val, 10.0);
    }

    gl_FragColor = vec4(val/10.0, val/15.0, val/20.0, 1.0);
}
`;

// Shader compilation
function compileShader(gl, src, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(shader));
    }
    return shader;
}

// Program
const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Buffer
const posLoc = gl.getAttribLocation(program, "a_position");
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const u_resolution = gl.getUniformLocation(program, "u_resolution");
const u_time = gl.getUniformLocation(program, "u_time");
const u_detail = gl.getUniformLocation(program, "u_detail");

// Initial detail
let detail = 0.5;

// FPS
let lastTime = performance.now();
let frameCount = 0;
let showFPS = false;

// CPU & STR stress flags
let cpuActive = false;
let strActive = false;
let cpuWorkers = [];
let strArrays = [];

// CPU stress using all logical cores
function startCpuStress() {
    stopCpuStress();
    const cores = navigator.hardwareConcurrency || 4;
    cpuActive = true;
    cpuWorkers = [];
    const workerCode = `
        self.onmessage = function(e){
            if(e.data === 'stop') close();
            else {
                function loop(){
                    let x=0;
                    for(let i=0;i<1e8;i++){ x+=Math.sqrt(Math.random()); }
                    if(true) setTimeout(loop,0);
                }
                loop();
            }
        }
    `;
    const blob = new Blob([workerCode], {type:'application/javascript'});
    const url = URL.createObjectURL(blob);
    for(let i=0;i<cores;i++){
        const w = new Worker(url);
        w.postMessage('start');
        cpuWorkers.push(w);
    }
}
function stopCpuStress(){
    cpuActive = false;
    for(const w of cpuWorkers){
        w.postMessage('stop');
    }
    cpuWorkers = [];
}

// STR stress: allocate gradually up to ~2 GB safely
function startStrStress() {
    stopStrStress();
    strActive = true;
    const maxBlocks = 50; // ~2GB
    const blockSize = 40e6; // ~40MB
    function allocLoop() {
        if(!strActive) return;
        try {
            strArrays.push(new Array(blockSize).fill(Math.random()));
            if(strArrays.length > maxBlocks) strArrays.shift(); // release oldest block
        } catch(e) {
            // ignore memory errors
        }
        setTimeout(allocLoop, 50);
    }
    allocLoop();
}
function stopStrStress() {
    strActive = false;
    strArrays = [];
}

// Keyboard
window.addEventListener('keydown', e => {
    if(e.key === 'f' || e.key === 'F'){
        if(!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    }
    if(e.key === '`'){
        showFPS = !showFPS;
        fpsDisplay.style.display = showFPS ? 'block' : 'none';
    }
    if(e.key === 'c' || e.key === 'C'){
        cpuActive = !cpuActive;
        cpuToggle.checked = cpuActive;
        if(cpuActive) startCpuStress(); else stopCpuStress();
    }
    if(e.key === 'd' || e.key === 'D'){
        strActive = !strActive;
        strToggle.checked = strActive;
        if(strActive) startStrStress(); else stopStrStress();
    }
});

// Settings button
settingsBtn.onclick = ()=>{ settingsOverlay.style.display='block'; };
backBtn.onclick = ()=>{ settingsOverlay.style.display='none'; };

// Slider
qualitySlider.addEventListener('input', ()=>{
    detail = parseFloat(qualitySlider.value)/100;
    qualityValue.textContent = qualitySlider.value;
});

// Toggles
cpuToggle.addEventListener('change', ()=>{ 
    cpuActive = cpuToggle.checked;
    if(cpuActive) startCpuStress(); else stopCpuStress();
});
strToggle.addEventListener('change', ()=>{
    strActive = strToggle.checked;
    if(strActive) startStrStress(); else stopStrStress();
});

// Render
function render(time){
    const deltaTime = (time-lastTime)/1000;
    lastTime = time;
    frameCount++;
    if(showFPS && frameCount%30===0){
        const fps = (1/deltaTime).toFixed(1);
        fpsDisplay.textContent = `FPS: ${fps}`;
        fpsDisplay.style.color = fps>50?'lime':fps>=20?'yellow':'red';
    }
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.uniform2f(u_resolution,canvas.width,canvas.height);
    gl.uniform1f(u_time,time*0.001);
    gl.uniform1f(u_detail,detail);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(render);
}
requestAnimationFrame(render);

// Resize
window.addEventListener('resize', ()=>{
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>
