<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brick Blaster</title>
  <style>
    /* Restored original settings layout and kept all game features. */
    :root{--accent:#0077cc}
    html,body{height:100%;margin:0;font-family:Arial, Helvetica, sans-serif;background:#111;color:#fff}
    #wrap{position:relative;max-width:100%;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
    /* Settings (restored previous appearance) */
    #settings{display:flex;flex-direction:column;align-items:center;background:linear-gradient(180deg,#071428,#03142a);padding:24px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    #settings h1{margin:0 0 8px 0;color:var(--accent)}
    #settings .option{margin:8px 0;color:#dfeefb}
    .start-btn{background:var(--accent);color:#fff;border:0;padding:10px 16px;border-radius:8px;cursor:pointer;font-weight:700}
    .home-btn{background:#213249;color:#e6eef8;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    /* Canvas */
    #gameCanvas{display:none;box-shadow:0 12px 40px rgba(0,0,0,0.6);border-radius:8px}
    /* Countdown */
    #countdown{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;font-size:120px;color:yellow;pointer-events:none;display:none}
    /* End overlay */
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);flex-direction:column}
    #overlay .btnrow{display:flex;gap:12px;margin-top:12px}
    #overlay button{padding:10px 16px;border-radius:8px;border:0;cursor:pointer}
    #overlay .retry{background:#0ff;color:#000}
    #overlay .settings{background:#ffd966;color:#000}
    #overlay .home{background:#7ee; color:#000}
    /* Home button top-left */
    #homeTop{position:fixed;top:12px;left:12px;padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
    /* Pause button top-left (next to home) */
    #pauseBtn{position:fixed;top:12px;left:100px;padding:8px 12px;border-radius:8px;border:0;background:#ffa500;color:#fff;cursor:pointer;display:none}
    /* Pause overlay */
    #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);flex-direction:column;z-index:1001}
    #pauseOverlay h2{color:#ffa500;margin-bottom:20px}
    #pauseOverlay button{padding:12px 24px;border-radius:8px;border:0;cursor:pointer;margin:8px;font-size:16px}
    #pauseOverlay .resume{background:#0f0;color:#000}
    #pauseOverlay .pauseSettings{background:#ffd966;color:#000}
    /* small HUD */
    #hud{position:fixed;top:12px;right:12px;color:#dfeefb;font-weight:700}
    /* Name prompt overlay */
    #namePrompt{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:2000}
    #namePrompt .prompt-box{background:linear-gradient(180deg,#071428,#03142a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);text-align:center}
    #namePrompt h2{color:var(--accent);margin-bottom:15px}
    #namePrompt input{padding:10px;width:250px;border-radius:5px;border:2px solid var(--accent);background:#0a1929;color:#fff;font-size:16px;margin-bottom:15px}
    #namePrompt button{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;font-weight:700}
    /* Leaderboard button */
    #leaderboardBtn{position:fixed;top:12px;right:12px;padding:8px 12px;border-radius:8px;border:0;background:#ffd700;color:#000;cursor:pointer;font-weight:700;z-index:100}
    /* User Settings button */
    #userSettingsBtn{position:fixed;bottom:12px;right:12px;padding:8px 12px;border-radius:8px;border:0;background:#00aaff;color:#fff;cursor:pointer;font-weight:700;z-index:100}
    /* Leaderboard overlay */
    #leaderboardOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:1500}
    #leaderboardOverlay .lb-box{background:linear-gradient(180deg,#071428,#03142a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);min-width:400px}
    #leaderboardOverlay h2{color:#ffd700;margin-bottom:20px;text-align:center}
    #leaderboardOverlay .lb-entry{display:flex;justify-content:space-between;padding:12px;margin:8px 0;background:#0a1929;border-radius:5px;color:#dfeefb}
    #leaderboardOverlay .lb-entry.first{background:#ffd700;color:#000;font-weight:bold}
    #leaderboardOverlay .lb-entry.second{background:#c0c0c0;color:#000;font-weight:bold}
    #leaderboardOverlay .lb-entry.third{background:#cd7f32;color:#000;font-weight:bold}
    #leaderboardOverlay .close-btn{background:#ff4444;color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:20px;display:block;margin-left:auto;margin-right:auto}
    #leaderboardOverlay .back-btn{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:10px;display:block;margin-left:auto;margin-right:auto}
    /* User Settings overlay */
    #userSettingsOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:1500}
    #userSettingsOverlay .us-box{background:linear-gradient(180deg,#071428,#03142a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);min-width:450px}
    #userSettingsOverlay h2{color:#00aaff;margin-bottom:20px;text-align:center}
    #userSettingsOverlay .stat-item{display:flex;justify-content:space-between;padding:12px;margin:8px 0;background:#0a1929;border-radius:5px;color:#dfeefb;font-size:16px}
    #userSettingsOverlay .stat-label{font-weight:bold;color:#7dd3fc}
    #userSettingsOverlay .stat-value{color:#ffd700}
    .change-name-section{margin-top:20px;padding-top:20px;border-top:2px solid #0a1929;text-align:center}
    .change-name-section p{color:#dfeefb;margin-bottom:10px}
    .change-name-section input{padding:8px;width:200px;border-radius:5px;border:2px solid var(--accent);background:#0a1929;color:#fff;margin-right:8px}
    .change-name-section button{background:var(--accent);color:#fff;border:0;padding:8px 16px;border-radius:8px;cursor:pointer}
    .change-name-section button:disabled{background:#555;cursor:not-allowed}
    .change-name-section .name-timer{color:#ff6b6b;font-size:14px;margin-top:8px}
    #userSettingsOverlay .back-btn{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:20px;display:block;margin-left:auto;margin-right:auto}
  </style>
</head>
<body>
  <div id="wrap">
    <button id="homeTop" onclick="location.href='index.html'">üè† Home</button>
    <button id="pauseBtn">‚è∏ Pause</button>
    <button id="leaderboardBtn">üèÜ Leaderboard</button>
    <button id="userSettingsBtn">üë§ User Settings</button>
    <!-- Name Prompt Overlay -->
    <div id="namePrompt" style="display:none">
      <div class="prompt-box">
        <h2>Welcome to Brick Blaster!</h2>
        <p style="color:#dfeefb;margin-bottom:20px">Please enter your name to continue</p>
        <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />
        <br>
        <button id="nameSubmit">Continue</button>
      </div>
    </div>
    <!-- Leaderboard Overlay -->
    <div id="leaderboardOverlay">
      <div class="lb-box">
        <h2>üèÜ Leaderboard - Top 3 Players</h2>
        <div id="leaderboardList">
          <p style="color:#dfeefb;text-align:center">Loading...</p>
        </div>
        <button class="back-btn" id="backFromLeaderboard">Back to Settings</button>
        <button class="close-btn" id="closeLeaderboard">Close</button>
      </div>
    </div>
    <!-- User Settings Overlay -->
    <div id="userSettingsOverlay">
      <div class="us-box">
        <h2>üë§ User Settings</h2>
        <div id="userStatsList">
          <div class="stat-item">
            <span class="stat-label">Player Name:</span>
            <span class="stat-value" id="statPlayerName">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Highest Score:</span>
            <span class="stat-value" id="statHighScore">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Total Games Played:</span>
            <span class="stat-value" id="statTotalGames">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Average Score:</span>
            <span class="stat-value" id="statAvgScore">0</span>
          </div>
        </div>
        <div class="change-name-section">
          <p><strong>Change Your Name</strong></p>
          <p style="font-size:13px;color:#aaa">You can change your name once every 10 days</p>
          <input type="text" id="newNameInputUS" placeholder="New name" maxlength="20" />
          <button id="changeNameBtnUS">Update Name</button>
          <div class="name-timer" id="nameTimer"></div>
        </div>
        <button class="back-btn" id="backFromUserSettings">Back to Settings</button>
      </div>
    </div>
    <!-- Settings: RESTORED layout you liked -->
    <div id="settings">
      <h1>üß± Brick Blaster</h1>
      <div class="option">
        <label style="color:#cfeffd">Ball Speed:</label>
        <select id="speedSelect">
          <option value="3.6">1 (Slow)</option>
          <option value="6">2 (Medium)</option>
          <option value="8.4">3 (Fast)</option>
        </select>
      </div>
      <div class="option">
        <label style="color:#cfeffd">Bricks:</label>
        <select id="brickSelect">
          <option value="12">1 (12 Bricks ‚Äî 4√ó3)</option>
          <option value="24">2 (24 Bricks ‚Äî 6√ó4)</option>
          <option value="48">3 (48 Bricks ‚Äî 8√ó6)</option>
          <option value="endless">4 (Endless ‚Äî starts 48)</option>
        </select>
      </div>
      <div style="display:flex;gap:10px;margin-top:10px">
        <button class="start-btn" id="startBtn">Start Game</button>
      </div>
    </div>
    <canvas id="gameCanvas" width="800" height="600" aria-label="Brick Blaster canvas"></canvas>
    <div id="countdown">3</div>
    <div id="overlay">
      <div id="endText" style="font-size:20px"></div>
      <div class="btnrow" style="margin-top:12px">
        <button class="retry" id="retryBtn">Retry</button>
        <button class="settings" id="settingsBtn">Settings</button>
        <button class="home" id="homeBtn2">Home</button>
      </div>
    </div>
    <div id="hud">Lives: <span id="hudLives">3</span> &nbsp;&nbsp; Score: <span id="hudScore">0</span> &nbsp;&nbsp; Time: <span id="hudTime">0</span>s</div>
    <div id="pauseOverlay">
      <h2>‚è∏ PAUSED</h2>
      <div>
        <button class="resume" id="resumeBtn">Resume</button>
        <button class="pauseSettings" id="pauseSettingsBtn">Settings</button>
      </div>
    </div>
  </div>
  <script>
    // --- Variables ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const settingsDiv = document.getElementById('settings');
    const countdownEl = document.getElementById('countdown');
    const overlay = document.getElementById('overlay');
    const endText = document.getElementById('endText');
    const retryBtn = document.getElementById('retryBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const homeBtn2 = document.getElementById('homeBtn2');
    const hudLives = document.getElementById('hudLives');
    const hudScore = document.getElementById('hudScore');
    const hudTime = document.getElementById('hudTime');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const resumeBtn = document.getElementById('resumeBtn');
    const pauseSettingsBtn = document.getElementById('pauseSettingsBtn');
    const namePrompt = document.getElementById('namePrompt');
    const nameInput = document.getElementById('nameInput');
    const nameSubmit = document.getElementById('nameSubmit');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const leaderboardOverlay = document.getElementById('leaderboardOverlay');
    const closeLeaderboard = document.getElementById('closeLeaderboard');
    const backFromLeaderboard = document.getElementById('backFromLeaderboard');
    const leaderboardList = document.getElementById('leaderboardList');
    const userSettingsBtn = document.getElementById('userSettingsBtn');
    const userSettingsOverlay = document.getElementById('userSettingsOverlay');
    const backFromUserSettings = document.getElementById('backFromUserSettings');
    const statPlayerName = document.getElementById('statPlayerName');
    const statHighScore = document.getElementById('statHighScore');
    const statTotalGames = document.getElementById('statTotalGames');
    const statAvgScore = document.getElementById('statAvgScore');
    const newNameInputUS = document.getElementById('newNameInputUS');
    const changeNameBtnUS = document.getElementById('changeNameBtnUS');
    const nameTimer = document.getElementById('nameTimer');

    let playerName = '';
    let playerId = '';
    let database = null;

    let cols = 8, rows = 6; // logical top-grid (based on mode)
    let spawnRows = 0; // how deep bricks can spawn
    let brickW = 0, brickH = 20, brickPad = 1; // 1px spacing between bricks (as requested)
    let grid = []; // grid[c][r] status
    let ball = { x:0, y:0, r:10, dx:0, dy:0, speed:5 };
    let paddle = { w:80, h:12, x:0 };
    let score = 0, lives = 3, timePlayed = 0;
    let running = false, endlessMode = false;
    let paused = false;
    let gameLoopId = null, timeIntervalId = null, spawnIntervalId = null;
    // save last settings so Retry uses same settings
    let lastSettings = { speedVal:3, mode:'12' };

    // --- Helpers ---
    function setCanvasSize(w,h){
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }

    function computeGridFromMode(mode){
      if(mode === '12'){
        cols = 4; rows = 3;
      } else if(mode === '24'){
        cols = 6; rows = 4;
      } else {
        cols = 8; rows = 6;
      }
      // spawn rows depth: allow deep spawning area so bricks won't immediately refill same holes
      const maxSpawnRows = document.fullscreenElement ? 30 : 15;
      spawnRows = maxSpawnRows;
      brickW = (canvas.width - (cols - 1) * brickPad) / cols; // exact fit horizontally with 1px gaps
    }

    function createGrid(){
      grid = [];
      for(let c=0;c<cols;c++){
        grid[c] = [];
        for(let r=0;r<spawnRows;r++) grid[c][r] = 0; // 0 empty, 1 brick
      }
    }

    function fillInitialBricks(mode){
      if(mode === 'endless'){
        // start with 48 in top-left positions (8x6)
        const startCols = 8, startRows = 6;
        for(let c=0;c<startCols;c++) for(let r=0;r<startRows;r++) grid[c][r] = 1;
      } else {
        const total = parseInt(mode);
        let placed = 0;
        for(let r=0;r<rows && placed<total;r++){
          for(let c=0;c<cols && placed<total;c++){
            grid[c][r] = 1;
            placed++;
          }
        }
      }
    }

    function spawnNewBrick(){
      if(!endlessMode) return;
      // prefer deeper rows (r >= rows) to avoid immediate refill
      let candidates = [];
      for(let c=0;c<cols;c++){
        for(let r=rows;r<spawnRows;r++){
          if(grid[c][r] === 0) candidates.push({c,r});
        }
      }
      // if no deep candidates, allow any empty cell
      if(candidates.length === 0){
        for(let c=0;c<cols;c++){
          for(let r=0;r<spawnRows;r++) if(grid[c][r] === 0) candidates.push({c,r});
        }
      }
      if(candidates.length === 0) return;
      const pick = candidates[Math.floor(Math.random() * candidates.length)];
      grid[pick.c][pick.r] = 1;
    }

    // generate ball velocity with a tilt that avoids nearly-vertical
    function generateVelocity(speed){
      // choose angle between 25deg and 65deg from horizontal (for upward launch)
      const deg = (Math.random() * 40 + 25);
      const rad = deg * Math.PI / 180;
      const dir = (Math.random() < 0.5) ? -1 : 1; // left or right
      const dx = Math.cos(rad) * speed * dir;
      const dy = -Math.sin(rad) * speed;
      return {dx,dy};
    }

    // --- Drawing and collision ---
    function drawBricks(){
      for(let c=0;c<cols;c++){
        for(let r=0;r<spawnRows;r++){
          if(grid[c][r] === 1){
            const x = c * (brickW + brickPad);
            const y = r * (brickH + brickPad);
            ctx.fillStyle = '#f33';
            // leave 1px spacing visually (brickPad handles gap)
            ctx.fillRect(x, y, brickW, brickH);
          }
        }
      }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBricks();
      // ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fillStyle = '#ffdd00';
      ctx.fill();
      ctx.closePath();
      // paddle
      ctx.fillStyle = '#00aaff';
      ctx.fillRect(paddle.x, canvas.height - paddle.h - 10, paddle.w, paddle.h);
      // HUD
      hudLives.textContent = lives;
      hudScore.textContent = score;
      hudTime.textContent = timePlayed;
    }

    function checkCollisions(){
      // bricks - check collision at ball edge
      for(let c=0;c<cols;c++){
        for(let r=0;r<spawnRows;r++){
          if(grid[c][r] === 1){
            const bx = c * (brickW + brickPad);
            const by = r * (brickH + brickPad);
            // Check if ball edge touches brick
            if(ball.x + ball.r > bx && ball.x - ball.r < bx + brickW && 
               ball.y + ball.r > by && ball.y - ball.r < by + brickH){
              grid[c][r] = 0;
              score++;
              // reflect vertical direction and nudge horizontal
              ball.dy = -ball.dy;
              ball.dx += (Math.random() - 0.5) * 0.2;
              if(!endlessMode){
                // win check only on fixed mode
                let totalBricks = 0;
                for(let cc=0;cc<cols;cc++) for(let rr=0;rr<rows;rr++) if(grid[cc][rr]===1) totalBricks++;
                if(totalBricks === 0) endRound(true);
              }
              return;
            }
          }
        }
      }
      // walls
      if(ball.x + ball.dx > canvas.width - ball.r || ball.x + ball.dx < ball.r) ball.dx = -ball.dx;
      if(ball.y + ball.dy < ball.r) ball.dy = -ball.dy;
      // paddle/bottom - check collision at ball edge
      const paddleTop = canvas.height - paddle.h - 10;
      if(ball.y + ball.r >= paddleTop && ball.y - ball.r < paddleTop + paddle.h){
        if(ball.x >= paddle.x && ball.x <= paddle.x + paddle.w){
          // reflect with angle based on hit position
          const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2); // -1..1
          const speed = ball.speed;
          const angle = hit * (Math.PI/3); // tilt up to 60deg
          ball.dx = speed * Math.sin(angle);
          ball.dy = -Math.abs(speed * Math.cos(angle));
        }
      } else if(ball.y - ball.r > canvas.height){
        lives--;
        if(lives <= 0) endRound(false);
        else resetBall();
      }
    }

    function resetBall(){
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 60;
      const v = generateVelocity(ball.speed);
      ball.dx = v.dx;
      ball.dy = v.dy;
    }

    // main loop
    function loop(){
      if(!running || paused) return;
      ball.x += ball.dx;
      ball.y += ball.dy;
      checkCollisions();
      // paddle move (global keys)
      if(window._right) paddle.x = Math.min(canvas.width - paddle.w, paddle.x + 7);
      if(window._left) paddle.x = Math.max(0, paddle.x - 7);
      draw();
      requestAnimationFrame(loop);
    }

    // --- Start / End / UI ---
    function startCountdownThenStart(){
      // show 3..1 countdown then start
      countdownEl.style.display = 'flex';
      let n = 3;
      countdownEl.textContent = n;
      const t = setInterval(()=>{
        n--;
        if(n>0) countdownEl.textContent = n;
        else {
          clearInterval(t);
          countdownEl.style.display='none';
          beginPlay();
        }
      },1000);
    }

    function beginPlay(){
      // start game loop
      running = true;
      paused = false;
      timePlayed = 0;
      score = 0;
      lives = 3;
      hudLives.textContent = lives;
      hudScore.textContent = score;
      hudTime.textContent = timePlayed;
      resetBall();
      paddle.x = (canvas.width - paddle.w)/2;
      pauseBtn.style.display = 'block';
      if(endlessMode){
        clearInterval(spawnIntervalId);
        spawnIntervalId = setInterval(spawnNewBrick,3000);
      }
      if(timeIntervalId) clearInterval(timeIntervalId);
      timeIntervalId = setInterval(()=>{
        if(running && !paused) timePlayed++;
      },1000);
      requestAnimationFrame(loop);
    }

    function startGameWithSettings(useLast=false){
      // read settings or reuse last
      let speedVal, modeVal;
      if(useLast){
        speedVal = lastSettings.speedVal;
        modeVal = lastSettings.mode;
      } else{
        speedVal = parseFloat(document.getElementById('speedSelect').value);
        modeVal = document.getElementById('brickSelect').value;
        lastSettings = { speedVal, mode: modeVal };
      }
      // configure ball & grid
      ball.speed = speedVal;
      const v = generateVelocity(ball.speed);
      ball.r = (modeVal==='12')?10:(modeVal==='24')?9:8;
      ball.dx = v.dx;
      ball.dy = v.dy;
      paddle.w = (modeVal==='12')?100:(modeVal==='24')?85:70;
      paddle.h = 12;
      endlessMode = (modeVal === 'endless');
      const modeForGrid = endlessMode ? '48' : modeVal;
      computeGridFromMode(modeForGrid);
      createGrid();
      fillInitialBricks(modeVal);
      // hide settings, show canvas & HUD
      settingsDiv.style.display = 'none';
      overlay.style.display = 'none';
      canvas.style.display = 'block';
      startCountdownThenStart();
    }

    function endRound(win){
      running = false;
      paused = false;
      pauseBtn.style.display = 'none';
      clearInterval(timeIntervalId);
      clearInterval(spawnIntervalId);
      endText.textContent = (win ? 'üéâ You Win!' : 'üíÄ Game Over');
      overlay.style.display = 'flex';
      overlay.style.zIndex = 1000;
      // show stats
      endText.textContent += ` | Score: ${score} | Time: ${timePlayed}s`;
      
      // Update leaderboard and stats
      updatePlayerStats(score);
    }

    // Retry: start countdown immediately with same settings
    retryBtn.addEventListener('click', ()=>{
      overlay.style.display='none';
      startGameWithSettings(true);
    });

    settingsBtn.addEventListener('click', ()=>{
      overlay.style.display='none';
      settingsDiv.style.display='flex';
      canvas.style.display='none';
    });

    homeBtn2.addEventListener('click', ()=>location.href='index.html');

    // Pause functionality
    pauseBtn.addEventListener('click', ()=>{
      if(running && !paused){
        paused = true;
        pauseOverlay.style.display = 'flex';
      }
    });

    resumeBtn.addEventListener('click', ()=>{
      paused = false;
      pauseOverlay.style.display = 'none';
      requestAnimationFrame(loop);
    });

    pauseSettingsBtn.addEventListener('click', ()=>{
      running = false;
      paused = false;
      pauseBtn.style.display = 'none';
      pauseOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
      canvas.style.display = 'none';
      clearInterval(timeIntervalId);
      clearInterval(spawnIntervalId);
    });

    // keys
    window._left = false;
    window._right = false;
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft') window._left = true;
      if(e.key === 'ArrowRight') window._right = true;
      if(e.key.toLowerCase() === 'f') toggleFullscreen();
      if(e.key.toLowerCase() === 'p' && running){
        if(!paused){
          paused = true;
          pauseOverlay.style.display = 'flex';
        } else {
          paused = false;
          pauseOverlay.style.display = 'none';
          requestAnimationFrame(loop);
        }
      }
      if(e.code === 'Space' && overlay.style.display === 'flex') {
        overlay.style.display='none';
        startGameWithSettings(true);
      }
    });

    document.addEventListener('keyup', (e)=>{
      if(e.key === 'ArrowLeft') window._left = false;
      if(e.key === 'ArrowRight') window._right = false;
    });

    // fullscreen toggle (robust) and handle resize
    function toggleFullscreen(){
      if(!document.fullscreenElement){
        document.documentElement.requestFullscreen().catch(()=>{});
      } else document.exitFullscreen().catch(()=>{});
    }

    document.addEventListener('fullscreenchange', ()=>{
      if(document.fullscreenElement){
        // expand canvas to viewport
        setCanvasSize(window.innerWidth, window.innerHeight);
      } else {
        // revert to 800x600
        setCanvasSize(800,600);
      }
      // Only recompute grid layout if game is not running
      if(!running) {
        // recompute grid & positions without changing current settings
        computeGridFromMode(lastSettings.mode === 'endless' ? '48' : lastSettings.mode);
        createGrid();
        fillInitialBricks(lastSettings.mode);
        // reposition ball/paddle
        paddle.x = Math.min(Math.max(0, paddle.x), canvas.width - paddle.w);
        ball.x = Math.min(Math.max(ball.r, ball.x), canvas.width - ball.r);
        resetBall();
        draw();
      } else {
        // Game is running - just adjust positions and brick size
        const oldBrickW = brickW;
        computeGridFromMode(lastSettings.mode === 'endless' ? '48' : lastSettings.mode);
        // Scale existing grid positions
        paddle.x = Math.min(Math.max(0, paddle.x), canvas.width - paddle.w);
        ball.x = Math.min(Math.max(ball.r, ball.x), canvas.width - ball.r);
        ball.y = Math.min(Math.max(ball.r, ball.y), canvas.height - ball.r);
      }
    });

    // start button
    startBtn.addEventListener('click', ()=>{
      startGameWithSettings(false);
    });

    // spawn interval cleared on page leave
    window.addEventListener('beforeunload', ()=>{
      clearInterval(spawnIntervalId);
      clearInterval(timeIntervalId);
    });

    // initial canvas size
    setCanvasSize(800,600);
    computeGridFromMode('12');
    createGrid();
    fillInitialBricks('12');
    // draw initial settings preview (optional)
    draw();

    // --- Name and Leaderboard System ---
    function initializePlayer() {
      // Check if player has a saved ID
      playerId = localStorage.getItem('brickBlasterPlayerId');
      playerName = localStorage.getItem('brickBlasterPlayerName');
      
      if (!playerId) {
        // Generate new player ID
        playerId = 'player_' + Math.random().toString(36).substr(2, 16) + '_' + Date.now();
        localStorage.setItem('brickBlasterPlayerId', playerId);
        // Show name prompt
        namePrompt.style.display = 'flex';
      } else if (!playerName) {
        // Has ID but no name (shouldn't happen, but handle it)
        namePrompt.style.display = 'flex';
      } else {
        // Player already registered, proceed
        settingsDiv.style.display = 'flex';
      }
    }

    nameSubmit.addEventListener('click', submitName);
    nameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') submitName();
    });

    function submitName() {
      const name = nameInput.value.trim();
      if (name.length === 0) {
        alert('Please enter a valid name');
        return;
      }
      playerName = name;
      localStorage.setItem('brickBlasterPlayerName', playerName);
      
      // Initialize player in Firebase
      if (database) {
        database.ref('players/' + playerId).set({
          name: playerName,
          highScore: 0,
          totalGames: 0,
          totalScore: 0,
          lastNameChange: Date.now(),
          lastUpdated: Date.now()
        });
      }
      
      namePrompt.style.display = 'none';
      settingsDiv.style.display = 'flex';
    }

    function updatePlayerStats(newScore) {
      if (!database || !playerId) return;
      
      const playerRef = database.ref('players/' + playerId);
      
      // Get current stats
      playerRef.once('value').then((snapshot) => {
        const data = snapshot.val() || {
          name: playerName,
          highScore: 0,
          totalGames: 0,
          totalScore: 0,
          lastNameChange: Date.now(),
          lastUpdated: Date.now()
        };
        
        const newHighScore = Math.max(data.highScore, newScore);
        const newTotalGames = data.totalGames + 1;
        const newTotalScore = data.totalScore + newScore;
        
        // Update player stats
        playerRef.update({
          name: playerName,
          highScore: newHighScore,
          totalGames: newTotalGames,
          totalScore: newTotalScore,
          lastUpdated: Date.now()
        });
      });
    }

    // Leaderboard functionality
    leaderboardBtn.addEventListener('click', showLeaderboard);
    closeLeaderboard.addEventListener('click', () => {
      leaderboardOverlay.style.display = 'none';
    });
    backFromLeaderboard.addEventListener('click', () => {
      leaderboardOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
    });

    function showLeaderboard() {
      if (!database) {
        leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">Leaderboard not available</p>';
        leaderboardOverlay.style.display = 'flex';
        return;
      }
      
      leaderboardOverlay.style.display = 'flex';
      leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">Loading...</p>';
      
      database.ref('players').orderByChild('highScore').limitToLast(3).once('value').then((snapshot) => {
        const players = [];
        snapshot.forEach((child) => {
          players.push(child.val());
        });
        
        // Sort by high score descending
        players.sort((a, b) => b.highScore - a.highScore);
        
        if (players.length === 0) {
          leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">No players yet. Be the first!</p>';
          return;
        }
        
        let html = '';
        players.forEach((player, index) => {
          const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : 'third';
          const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
          html += `<div class="lb-entry ${rankClass}">
            <span>${medal} ${player.name}</span>
            <span>${player.highScore} pts</span>
          </div>`;
        });
        
        leaderboardList.innerHTML = html;
      });
    }

    // User Settings functionality
    userSettingsBtn.addEventListener('click', showUserSettings);
    backFromUserSettings.addEventListener('click', () => {
      userSettingsOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
    });

    function showUserSettings() {
      if (!database || !playerId) {
        userSettingsOverlay.style.display = 'flex';
        statPlayerName.textContent = playerName || '-';
        statHighScore.textContent = '0';
        statTotalGames.textContent = '0';
        statAvgScore.textContent = '0';
        updateNameChangeButton(0);
        return;
      }
      
      userSettingsOverlay.style.display = 'flex';
      
      database.ref('players/' + playerId).once('value').then((snapshot) => {
        const data = snapshot.val() || {
          name: playerName,
          highScore: 0,
          totalGames: 0,
          totalScore: 0,
          lastNameChange: Date.now()
        };
        
        statPlayerName.textContent = data.name;
        statHighScore.textContent = data.highScore;
        statTotalGames.textContent = data.totalGames;
        const avgScore = data.totalGames > 0 ? Math.round(data.totalScore / data.totalGames) : 0;
        statAvgScore.textContent = avgScore;
        
        updateNameChangeButton(data.lastNameChange || 0);
      });
    }

    function updateNameChangeButton(lastNameChange) {
      const now = Date.now();
      const tenDays = 10 * 24 * 60 * 60 * 1000; // 10 days in milliseconds
      const timeSinceChange = now - lastNameChange;
      
      if (timeSinceChange >= tenDays) {
        changeNameBtnUS.disabled = false;
        nameTimer.textContent = '';
      } else {
        changeNameBtnUS.disabled = true;
        const timeRemaining = tenDays - timeSinceChange;
        const daysRemaining = Math.ceil(timeRemaining / (24 * 60 * 60 * 1000));
        nameTimer.textContent = `You can change your name in ${daysRemaining} day(s)`;
      }
    }

    changeNameBtnUS.addEventListener('click', () => {
      const newName = newNameInputUS.value.trim();
      if (newName.length === 0) {
        alert('Please enter a valid name');
        return;
      }
      
      if (!database || !playerId) {
        playerName = newName;
        localStorage.setItem('brickBlasterPlayerName', playerName);
        alert('Name updated locally!');
        newNameInputUS.value = '';
        showUserSettings();
        return;
      }
      
      database.ref('players/' + playerId).once('value').then((snapshot) => {
        const data = snapshot.val();
        const now = Date.now();
        const tenDays = 10 * 24 * 60 * 60 * 1000;
        const timeSinceChange = now - (data.lastNameChange || 0);
        
        if (timeSinceChange < tenDays) {
          const daysRemaining = Math.ceil((tenDays - timeSinceChange) / (24 * 60 * 60 * 1000));
          alert(`You can change your name in ${daysRemaining} day(s)`);
          return;
        }
        
        playerName = newName;
        localStorage.setItem('brickBlasterPlayerName', playerName);
        
        database.ref('players/' + playerId).update({
          name: playerName,
          lastNameChange: now,
          lastUpdated: now
        }).then(() => {
          alert('Name updated successfully!');
          newNameInputUS.value = '';
          showUserSettings();
        });
      });
    });

    // Initialize player system when page loads
    window.addEventListener('load', () => {
      // Wait a bit for Firebase to initialize
      setTimeout(() => {
        if (typeof firebase !== 'undefined' && firebase.database) {
          database = firebase.database();
        }
        initializePlayer();
      }, 500);
    });
  </script>
  <!-- ADD THIS BEFORE THE CLOSING </body> TAG IN EACH GAME PAGE -->
<!-- (brickblaster.html, chess.html, tag.html, tictactoe.html, snake.html) -->

<!-- Import Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
  // Wait for Firebase to load
  window.addEventListener('load', function() {
    // Check if Firebase is available
    if (typeof firebase === 'undefined') {
      console.error('Firebase failed to load');
      return;
    }

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAwEy-sJx7E61BA6VmBfIFMZsjuAj8RK5g",
      authDomain: "games-c3e27.firebaseapp.com",
      databaseURL: "https://games-c3e27-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "games-c3e27",
      storageBucket: "games-c3e27.firebasestorage.app",
      messagingSenderId: "193027632069",
      appId: "1:193027632069:web:b559c3b10011bc6982b9ac"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    const userId = generateUserId();
    let userRef = null;
    let isConnected = true;

    function generateUserId() {
      let userId = localStorage.getItem('gameHubUserId');
      if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 16) + '_' + Date.now();
        localStorage.setItem('gameHubUserId', userId);
      }
      return userId;
    }

    function setupUserPresence() {
      userRef = database.ref('onlineUsers/' + userId);
      
      // Set user as online with current page info
      userRef.set({ 
        id: userId, 
        connected: true, 
        lastSeen: Date.now(), 
        page: window.location.pathname,
        userAgent: navigator.userAgent.substring(0, 50) 
      });
      
      // Remove user when they disconnect
      userRef.onDisconnect().remove();

      // Send heartbeat every 10 seconds
      const heartbeat = setInterval(() => {
        if (isConnected && userRef) {
          userRef.update({ lastSeen: Date.now(), page: window.location.pathname });
        } else {
          clearInterval(heartbeat);
        }
      }, 10000);

      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        isConnected = false;
        if (userRef) userRef.remove();
      });
    }

    // Initialize tracking
    setupUserPresence();
  });
</script>
</body>
</html>
