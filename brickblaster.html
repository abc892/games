<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brick Blaster</title>
  <style>
    /* All your existing CSS remains exactly the same */
    :root{--accent:#0077cc}
    html,body{height:100%;margin:0;font-family:Arial, Helvetica, sans-serif;background:#111;color:#fff}
    #wrap{position:relative;max-width:100%;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
    /* Settings (restored previous appearance) */
    #settings{display:flex;flex-direction:column;align-items:center;background:linear-gradient(180deg,#071428,#03142a);padding:24px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    #settings h1{margin:0 0 8px 0;color:var(--accent)}
    #settings .option{margin:8px 0;color:#dfeefb}
    .start-btn{background:var(--accent);color:#fff;border:0;padding:10px 16px;border-radius:8px;cursor:pointer;font-weight:700}
    .home-btn{background:#213249;color:#e6eef8;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    /* Canvas */
    #gameCanvas{display:none;box-shadow:0 12px 40px rgba(0,0,0,0.6);border-radius:8px}
    /* Countdown */
    #countdown{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;font-size:120px;color:yellow;pointer-events:none;display:none}
    /* End overlay */
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);flex-direction:column}
    #overlay .btnrow{display:flex;gap:12px;margin-top:12px}
    #overlay button{padding:10px 16px;border-radius:8px;border:0;cursor:pointer}
    #overlay .retry{background:#0ff;color:#000}
    #overlay .settings{background:#ffd966;color:#000}
    #overlay .home{background:#7ee; color:#000}
    /* Home button top-left */
    #homeTop{position:fixed;top:12px;left:12px;padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
    /* Pause button top-left (next to home) */
    #pauseBtn{position:fixed;top:12px;left:100px;padding:8px 12px;border-radius:8px;border:0;background:#ffa500;color:#fff;cursor:pointer;display:none}
    /* Pause overlay */
    #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);flex-direction:column;z-index:1001}
    #pauseOverlay h2{color:#ffa500;margin-bottom:20px}
    #pauseOverlay button{padding:12px 24px;border-radius:8px;border:0;cursor:pointer;margin:8px;font-size:16px}
    #pauseOverlay .resume{background:#0f0;color:#000}
    #pauseOverlay .pauseSettings{background:#ffd966;color:#000}
    /* small HUD */
    #hud{position:fixed;top:12px;right:12px;color:#dfeefb;font-weight:700;display:none}
    /* Name prompt overlay */
    #namePrompt{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:2000}
    #namePrompt .prompt-box{background:linear-gradient(180deg,#071428,#03142a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);text-align:center}
    #namePrompt h2{color:var(--accent);margin-bottom:15px}
    #namePrompt input{padding:10px;width:250px;border-radius:5px;border:2px solid var(--accent);background:#0a1929;color:#fff;font-size:16px;margin-bottom:15px}
    #namePrompt button{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;font-weight:700}
    /* Coins display */
    #coinsDisplay{position:fixed;top:12px;right:140px;padding:8px 16px;border-radius:8px;background:linear-gradient(135deg,#ffd700,#ffed4e);color:#000;font-weight:bold;font-size:16px;z-index:100;box-shadow:0 4px 12px rgba(255,215,0,0.4)}
    #coinsDisplay::before{content:'🪙 '}
    /* Diamonds display */
    #diamondsDisplay{position:fixed;top:12px;right:250px;padding:8px 16px;border-radius:8px;background:linear-gradient(135deg,#b9f2ff,#00bfff);color:#000;font-weight:bold;font-size:16px;z-index:100;box-shadow:0 4px 12px rgba(0,191,255,0.4);display:none}
    #diamondsDisplay::before{content:'💎 '}
    /* Event Display */
    #eventDisplay{position:fixed;top:60px;left:50%;transform:translateX(-50%);padding:8px 20px;border-radius:8px;font-weight:bold;font-size:18px;z-index:100;text-align:center;display:none}
    #eventTimer{position:fixed;top:100px;left:50%;transform:translateX(-50%);padding:6px 15px;border-radius:6px;background:rgba(0,0,0,0.7);color:#fff;font-weight:bold;font-size:14px;z-index:100;text-align:center;display:none}
    /* Leaderboard button */
    #leaderboardBtn{position:fixed;top:12px;right:12px;padding:8px 12px;border-radius:8px;border:0;background:#ffd700;color:#000;cursor:pointer;font-weight:700;z-index:100}
    /* Shop button */
    #shopBtn{position:fixed;top:60px;right:12px;padding:8px 12px;border-radius:8px;border:0;background:#9333ea;color:#fff;cursor:pointer;font-weight:700;z-index:100}
    /* User Settings button */
    #userSettingsBtn{position:fixed;bottom:12px;right:12px;padding:8px 12px;border-radius:8px;border:0;background:#00aaff;color:#fff;cursor:pointer;font-weight:700;z-index:100}
    /* Developer button */
    #devBtn{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);padding:8px 14px;border-radius:6px;border:0;background:#2a2a2a;color:#777;cursor:pointer;font-size:12px;z-index:100;opacity:0.4;box-shadow:0 2px 8px rgba(0,0,0,0.3)}
    #devBtn:hover{opacity:0.8;background:#3a3a3a}
    /* Developer overlays */
    #devPasswordOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);z-index:2500}
    #devPasswordOverlay .dev-box{background:linear-gradient(180deg,#1a1a1a,#0a0a0a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(255,0,0,0.3);border:2px solid #ff0000;min-width:400px;text-align:center}
    #devPasswordOverlay h2{color:#ff0000;margin-bottom:20px}
    #devPasswordOverlay input{padding:10px;width:250px;border-radius:5px;border:2px solid #ff0000;background:#1a1a1a;color:#fff;font-size:16px;margin-bottom:15px}
    #devPasswordOverlay button{background:#ff0000;color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;font-weight:700;margin:5px}
    #devPasswordOverlay .back-btn{background:#333}
    #devPanelOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);z-index:2500;overflow-y:auto}
    #devPanelOverlay .dev-panel{background:linear-gradient(180deg,#1a1a1a,#0a0a0a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(255,0,0,0.3);border:2px solid #ff0000;min-width:600px;max-height:90vh;overflow-y:auto;margin:20px}
    #devPanelOverlay h2{color:#ff0000;margin-bottom:20px;text-align:center}
    #devPanelOverlay .search-section{margin-bottom:30px;padding:20px;background:#111;border-radius:8px}
    #devPanelOverlay .search-section input{padding:10px;width:calc(100% - 120px);border-radius:5px;border:2px solid #ff0000;background:#1a1a1a;color:#fff;margin-right:10px}
    #devPanelOverlay .search-section button{background:#ff0000;color:#fff;border:0;padding:10px 20px;border-radius:8px;cursor:pointer}
    #devPanelOverlay .player-info{background:#111;padding:20px;border-radius:8px;margin-bottom:20px}
    #devPanelOverlay .player-info h3{color:#ff6666;margin-bottom:15px}
    #devPanelOverlay .edit-field{display:flex;justify-content:space-between;align-items:center;margin:10px 0;padding:10px;background:#1a1a1a;border-radius:5px}
    #devPanelOverlay .edit-field label{color:#ff9999;font-weight:bold;flex:1}
    #devPanelOverlay .edit-field input{padding:8px;width:150px;border-radius:5px;border:1px solid #ff0000;background:#0a0a0a;color:#fff}
    #devPanelOverlay .edit-field button{background:#ff0000;color:#fff;border:0;padding:8px 16px;border-radius:5px;cursor:pointer;margin-left:10px}
    #devPanelOverlay .action-buttons{display:flex;gap:10px;margin-top:20px;justify-content:center;flex-wrap:wrap}
    #devPanelOverlay .action-buttons button{background:#ff0000;color:#fff;border:0;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold}
    #devPanelOverlay .action-buttons button.danger{background:#990000}
    #devPanelOverlay .back-btn{background:#333;color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:20px;display:block;margin-left:auto;margin-right:auto}
    /* User List in Dev Panel */
    #devUserList{background:#111;padding:20px;border-radius:8px;margin-top:20px;max-height:300px;overflow-y:auto;display:none}
    #devUserList h3{color:#ff6666;margin-bottom:15px}
    .dev-user-item{padding:10px;margin:5px 0;background:#1a1a1a;border-radius:5px;cursor:pointer;color:#ff9999}
    .dev-user-item:hover{background:#222;color:#fff}
    /* Leaderboard overlay */
    #leaderboardOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:1500}
    #leaderboardOverlay .lb-box{background:linear-gradient(180deg,#071428,#03142a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);min-width:400px}
    #leaderboardOverlay h2{color:#ffd700;margin-bottom:20px;text-align:center}
    #leaderboardOverlay .lb-tabs{display:flex;gap:10px;margin-bottom:20px;justify-content:center}
    #leaderboardOverlay .lb-tabs button{padding:10px 20px;border:0;border-radius:8px;cursor:pointer;background:#0a1929;color:#dfeefb;font-weight:bold}
    #leaderboardOverlay .lb-tabs button.active{background:var(--accent);color:#fff}
    #leaderboardOverlay .lb-entry{display:flex;justify-content:space-between;padding:12px;margin:8px 0;background:#0a1929;border-radius:5px;color:#dfeefb}
    #leaderboardOverlay .lb-entry.first{background:#ffd700;color:#000;font-weight:bold}
    #leaderboardOverlay .lb-entry.second{background:#c0c0c0;color:#000;font-weight:bold}
    #leaderboardOverlay .lb-entry.third{background:#cd7f32;color:#000;font-weight:bold}
    #leaderboardOverlay .back-btn{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:20px;display:block;margin-left:auto;margin-right:auto}
    /* User Settings overlay */
    #userSettingsOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:1500}
    #userSettingsOverlay .us-box{background:linear-gradient(180deg,#071428,#03142a);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);min-width:450px}
    #userSettingsOverlay h2{color:#00aaff;margin-bottom:20px;text-align:center}
    #userSettingsOverlay .stat-item{display:flex;justify-content:space-between;padding:12px;margin:8px 0;background:#0a1929;border-radius:5px;color:#dfeefb;font-size:16px}
    #userSettingsOverlay .stat-label{font-weight:bold;color:#7dd3fc}
    #userSettingsOverlay .stat-value{color:#ffd700}
    .change-name-section{margin-top:20px;padding-top:20px;border-top:2px solid #0a1929;text-align:center}
    .change-name-section p{color:#dfeefb;margin-bottom:10px}
    .change-name-section input{padding:8px;width:200px;border-radius:5px;border:2px solid var(--accent);background:#0a1929;color:#fff;margin-right:8px}
    .change-name-section button{background:var(--accent);color:#fff;border:0;padding:8px 16px;border-radius:8px;cursor:pointer}
    .change-name-section button:disabled{background:#555;cursor:not-allowed}
    .change-name-section .name-timer{color:#ff6b6b;font-size:14px;margin-top:8px}
    .delete-account-section {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid #ff6b6b;
      text-align: center;
    }
    
    #deleteAccountBtn {
      background: #ff6b6b;
      color: #fff;
      border: 0;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s;
    }
    
    #deleteAccountBtn:hover {
      background: #ff5252;
    }
    #userSettingsOverlay .back-btn{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:20px;display:block;margin-left:auto;margin-right:auto}
    /* Shop overlay */
    #shopOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:1500}
    #shopOverlay .shop-box{background:linear-gradient(180deg,#1e1b4b,#312e81);padding:30px;border-radius:10px;box-shadow:0 10px 30px rgba(147,51,234,0.6);min-width:500px;max-height:80vh;overflow-y:auto}
    #shopOverlay h2{color:#c084fc;margin-bottom:20px;text-align:center}
    #shopOverlay .coins-info{text-align:center;font-size:20px;color:#ffd700;margin-bottom:20px;font-weight:bold}
    #shopOverlay .spin-section{text-align:center;padding:20px;background:rgba(0,0,0,0.3);border-radius:10px;margin-bottom:20px}
    #shopOverlay .spin-btn{background:linear-gradient(135deg,#9333ea,#c084fc);color:#fff;border:0;padding:15px 30px;border-radius:8px;cursor:pointer;font-weight:bold;font-size:16px;box-shadow:0 4px 12px rgba(147,51,234,0.4)}
    #shopOverlay .spin-btn:disabled{background:#555;cursor:not-allowed}
    #shopOverlay .spin-result{margin-top:15px;font-size:16px;color:#c084fc;min-height:24px}
    #shopOverlay h3{color:#a78bfa;margin:20px 0 10px 0}
    #shopOverlay .wallpaper-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px}
    #shopOverlay .wallpaper-item{height:80px;border-radius:8px;cursor:pointer;border:3px solid transparent;position:relative;transition:all 0.3s;background-size:cover;background-position:center}
    #shopOverlay .wallpaper-item:hover{transform:scale(1.05);border-color:#c084fc}
    #shopOverlay .wallpaper-item.selected{border-color:#ffd700;box-shadow:0 0 20px rgba(255,215,0,0.5)}
    #shopOverlay .wallpaper-item.rare{box-shadow:0 0 15px rgba(147,51,234,0.8)}
    #shopOverlay .event-section{margin-top:30px;padding-top:20px;border-top:2px solid #a78bfa}
    #shopOverlay .event-section h3{color:#ffd700}
    #shopOverlay .event-wallpaper-item{height:100px;border-radius:8px;cursor:pointer;border:3px solid transparent;position:relative;transition:all 0.3s;margin-bottom:15px;background-size:cover;background-position:center}
    #shopOverlay .event-wallpaper-item:hover{transform:scale(1.05);border-color:#ffd700}
    #shopOverlay .event-wallpaper-item.selected{border-color:#ffd700;box-shadow:0 0 20px rgba(255,215,0,0.5)}
    #shopOverlay .event-wallpaper-item .price{position:absolute;bottom:5px;right:5px;background:rgba(0,0,0,0.7);color:#ffd700;padding:3px 8px;border-radius:4px;font-size:12px;font-weight:bold}
    #shopOverlay .back-btn{background:var(--accent);color:#fff;border:0;padding:10px 24px;border-radius:8px;cursor:pointer;margin-top:20px;display:block;margin-left:auto;margin-right:auto}
    #eventToggle {
  position: fixed;
  top: 60px;
  right: 140px;
  padding: 8px 16px;
  border-radius: 8px;
  background: linear-gradient(135deg, #9333ea, #c084fc);
  color: #fff;
  font-weight: bold;
  font-size: 14px;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(147,51,234,0.4);
  cursor: pointer;
  border: 0;
  display: none;
}

#eventToggle.coin-mode {
  background: linear-gradient(135deg, #ffd700, #ffed4e);
  color: #000;
}

#eventToggle::before {
  content: '💎 Earn Gems';
}

#eventToggle.coin-mode::before {
  content: '🪙 Earn Coins';
}
  </style>
</head>
<body>
  <div id="wrap">
    <button id="homeTop" onclick="location.href='index.html'">🏠 Home</button>
    <button id="pauseBtn">⏸ Pause</button>
    <div id="coinsDisplay">0</div>
    <div id="diamondsDisplay">0</div>
    <button id="eventToggle"></button>  <!-- ADD THIS LINE -->
    <div id="eventDisplay"></div>
    <div id="eventTimer"></div>
    <button id="leaderboardBtn">🏆 Leaderboard</button>
    <button id="shopBtn">🛍️ Shop</button>
    <button id="userSettingsBtn">👤 User Settings</button>
    <button id="devBtn">⚙️</button>
    <!-- Developer Password Overlay -->
    <div id="devPasswordOverlay">
      <div class="dev-box">
        <h2>🔒 Developer Access</h2>
        <p style="color:#ff6666;margin-bottom:20px">Enter Developer Password</p>
        <input type="password" id="devPasswordInput" placeholder="Password" />
        <br>
        <button id="devPasswordSubmit">Enter</button>
        <button class="back-btn" id="devPasswordBack">Back</button>
      </div>
    </div>
    <!-- Developer Panel Overlay -->
    <div id="devPanelOverlay">
      <div class="dev-panel">
        <h2>🛠️ Developer Panel</h2>
        <div class="search-section">
          <h3 style="color:#ff6666;margin-bottom:15px">Search Player</h3>
          <input type="text" id="devSearchInput" placeholder="Enter player name" />
          <button id="devSearchBtn">Search</button>
          <button id="devShowAllUsers" style="background:#444;margin-left:10px">Show All Users</button>
        </div>
        <div id="devUserList">
          <h3>All Registered Users</h3>
          <div id="devUserListContent"></div>
        </div>
        <div id="devPlayerInfo" style="display:none">
          <div class="player-info">
            <h3>Player: <span id="devPlayerName">-</span></h3>
            <div class="edit-field">
              <label>Highest Score:</label>
              <input type="number" id="devHighScore" value="0" />
              <button onclick="updateDevField('highScore')">Update</button>
            </div>
            <div class="edit-field">
              <label>All-Time Score:</label>
              <input type="number" id="devAllTimeScore" value="0" />
              <button onclick="updateDevField('allTimeScore')">Update</button>
            </div>
            <div class="edit-field">
              <label>Total Games:</label>
              <input type="number" id="devTotalGames" value="0" />
              <button onclick="updateDevField('totalGames')">Update</button>
            </div>
            <div class="edit-field">
              <label>Total Score:</label>
              <input type="number" id="devTotalScore" value="0" />
              <button onclick="updateDevField('totalScore')">Update</button>
            </div>
            <div class="edit-field">
              <label>Coins:</label>
              <input type="number" id="devCoins" value="0" />
              <button onclick="updateDevField('coins')">Update</button>
            </div>
            <div class="edit-field" id="devDiamondsField" style="display:none">
              <label>Diamonds:</label>
              <input type="number" id="devDiamonds" value="0" />
              <button onclick="updateDevField('diamonds')">Update</button>
            </div>
            <div class="action-buttons">
              <button onclick="giveAllWallpapers()">Give All Wallpapers</button>
              <button onclick="giveSelectedWallpapers()">Give Selected Wallpapers</button>
              <button onclick="showWallpaperManager()">Manage Wallpapers</button>
              <button onclick="giveEventWallpapers()">Give Event Wallpapers</button>
              <button class="danger" onclick="deletePlayerAccount()">Delete Account</button>
            </div>
          </div>
          <div id="devWallpaperManager" style="display:none;background:#111;padding:20px;border-radius:8px;margin-top:20px">
            <h3 style="color:#ff6666;margin-bottom:15px">Player's Wallpapers</h3>
            <div id="devWallpaperList" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:10px;margin-bottom:15px">
            </div>
            <button onclick="hideWallpaperManager()" style="background:#555;color:#fff;border:0;padding:8px 16px;border-radius:5px;cursor:pointer">Close</button>
          </div>
        </div>
        <button class="back-btn" id="devPanelBack">Back to Settings</button>
      </div>
    </div>
    <!-- Name Prompt Overlay -->
    <div id="namePrompt" style="display:none">
      <div class="prompt-box">
        <h2>Welcome to Brick Blaster!</h2>
        <p style="color:#dfeefb;margin-bottom:20px">Please enter your name to continue</p>
        <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />
        <br>
        <button id="nameSubmit">Continue</button>
      </div>
    </div>
    <!-- Leaderboard Overlay -->
    <div id="leaderboardOverlay">
      <div class="lb-box">
        <h2>🏆 Leaderboard - Top 3 Players</h2>
        <div class="lb-tabs">
          <button id="tabHighScore" class="active">Highest Score (One Match)</button>
          <button id="tabAllTime">All-Time Score</button>
        </div>
        <div id="leaderboardList">
          <p style="color:#dfeefb;text-align:center">Loading...</p>
        </div>
        <button class="back-btn" id="backFromLeaderboard">Back to Settings</button>
      </div>
    </div>
    <!-- User Settings Overlay -->
    <div id="userSettingsOverlay">
      <div class="us-box">
        <h2>👤 User Settings</h2>
        <div id="userStatsList">
          <div class="stat-item">
            <span class="stat-label">Player Name:</span>
            <span class="stat-value" id="statPlayerName">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Highest Score:</span>
            <span class="stat-value" id="statHighScore">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">All-Time Score:</span>
            <span class="stat-value" id="statAllTimeScore">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Total Games Played:</span>
            <span class="stat-value" id="statTotalGames">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Average Score:</span>
            <span class="stat-value" id="statAvgScore">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Coins:</span>
            <span class="stat-value" id="statCoins">0</span>
          </div>
          <div class="stat-item" id="statDiamondsItem" style="display:none">
            <span class="stat-label">Diamonds:</span>
            <span class="stat-value" id="statDiamonds">0</span>
          </div>
        </div>
        <div class="change-name-section">
          <p><strong>Change Your Name</strong></p>
          <p style="font-size:13px;color:#aaa">You can change your name once every 10 days</p>
          <input type="text" id="newNameInputUS" placeholder="New name" maxlength="20" />
          <button id="changeNameBtnUS">Update Name</button>
          <div class="name-timer" id="nameTimer"></div>
        </div>
        <div class="delete-account-section">
          <p style="color:#ff6b6b;margin-bottom:15px"><strong>Danger Zone</strong></p>
          <p style="font-size:13px;color:#aaa;margin-bottom:15px">Permanently delete your account and all data</p>
          <button id="deleteAccountBtn">🗑️ Delete My Account</button>
          <p style="font-size:12px;color:#ff9999;margin-top:8px">This action cannot be undone!</p>
        </div>
        <button class="back-btn" id="backFromUserSettings">Back to Settings</button>
      </div>
    </div>
    <!-- Shop Overlay -->
    <div id="shopOverlay">
      <div class="shop-box">
        <h2>🛍️ Wallpaper Shop</h2>
        <div class="coins-info">🪙 Your Coins: <span id="shopCoins">0</span> <span id="shopDiamondsInfo" style="display:none"> | 💎 Your Diamonds: <span id="shopDiamonds">0</span></span></div>
        <div class="spin-section">
          <p style="color:#c084fc;margin-bottom:15px">Get a random wallpaper for 500 coins!</p>
          <button class="spin-btn" id="spinBtn">🎰 Spin (500 coins)</button>
          <div class="spin-result" id="spinResult"></div>
        </div>
        <h3>Your Wallpapers</h3>
        <div class="wallpaper-grid" id="wallpaperGrid">
          <p style="color:#aaa;grid-column:1/-1;text-align:center">No wallpapers yet. Spin to get some!</p>
        </div>
        <div class="event-section" id="eventShopSection" style="display:none">
          <h3>Event Wallpapers</h3>
          <div id="eventWallpaperGrid">
            <p style="color:#aaa;text-align:center">No event wallpapers available</p>
          </div>
        </div>
        <button class="back-btn" id="backFromShop">Back to Settings</button>
      </div>
    </div>
    <!-- Settings: RESTORED layout you liked -->
    <div id="settings">
      <h1>🧱 Brick Blaster</h1>
      <div class="option">
        <label style="color:#cfeffd">Ball Speed:</label>
        <select id="speedSelect">
          <option value="3.6">1 (Slow)</option>
          <option value="6">2 (Medium)</option>
          <option value="8.4">3 (Fast)</option>
        </select>
      </div>
      <div class="option">
        <label style="color:#cfeffd">Bricks:</label>
        <select id="brickSelect">
          <option value="12">1 (12 Bricks — 4×3)</option>
          <option value="24">2 (24 Bricks — 6×4)</option>
          <option value="48">3 (48 Bricks — 8×6)</option>
          <option value="endless">4 (Endless — starts 48)</option>
        </select>
      </div>
      <div style="display:flex;gap:10px;margin-top:10px">
        <button class="start-btn" id="startBtn">Start Game</button>
      </div>
    </div>
    <canvas id="gameCanvas" width="800" height="600" aria-label="Brick Blaster canvas"></canvas>
    <div id="countdown">3</div>
    <div id="overlay">
      <div id="endText" style="font-size:20px"></div>
      <div class="btnrow" style="margin-top:12px">
        <button class="retry" id="retryBtn">Retry</button>
        <button class="settings" id="settingsBtn">Settings</button>
        <button class="home" id="homeBtn2">Home</button>
      </div>
    </div>
    <div id="hud">Lives: <span id="hudLives">3</span> &nbsp;&nbsp; Score: <span id="hudScore">0</span> &nbsp;&nbsp; Time: <span id="hudTime">0</span>s</div>
    <div id="pauseOverlay">
      <h2>⏸ PAUSED</h2>
      <div>
        <button class="resume" id="resumeBtn">Resume</button>
        <button class="pauseSettings" id="pauseSettingsBtn">Settings</button>
      </div>
    </div>
  </div>
  <script>
    // --- Variables ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const settingsDiv = document.getElementById('settings');
    const countdownEl = document.getElementById('countdown');
    const overlay = document.getElementById('overlay');
    const endText = document.getElementById('endText');
    const retryBtn = document.getElementById('retryBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const homeBtn2 = document.getElementById('homeBtn2');
    const hudLives = document.getElementById('hudLives');
    const hudScore = document.getElementById('hudScore');
    const hudTime = document.getElementById('hudTime');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const resumeBtn = document.getElementById('resumeBtn');
    const pauseSettingsBtn = document.getElementById('pauseSettingsBtn');
    const namePrompt = document.getElementById('namePrompt');
    const nameInput = document.getElementById('nameInput');
    const nameSubmit = document.getElementById('nameSubmit');
    nameInput.addEventListener('input', function() {
    const name = nameInput.value.trim();
    nameSubmit.disabled = name.length === 0;
});

// Also add keypress event to submit on Enter
nameInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        const name = nameInput.value.trim();
        if (name.length > 0) {
            submitName();
        }
    }
});

// Add click event to the submit button
nameSubmit.addEventListener('click', submitName);

// Initialize button state
nameSubmit.disabled = true;
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const leaderboardOverlay = document.getElementById('leaderboardOverlay');
    const backFromLeaderboard = document.getElementById('backFromLeaderboard');
    const leaderboardList = document.getElementById('leaderboardList');
    const tabHighScore = document.getElementById('tabHighScore');
    const tabAllTime = document.getElementById('tabAllTime');
    const userSettingsBtn = document.getElementById('userSettingsBtn');
    const userSettingsOverlay = document.getElementById('userSettingsOverlay');
    const backFromUserSettings = document.getElementById('backFromUserSettings');
    const statPlayerName = document.getElementById('statPlayerName');
    const statHighScore = document.getElementById('statHighScore');
    const statAllTimeScore = document.getElementById('statAllTimeScore');
    const statTotalGames = document.getElementById('statTotalGames');
    const statAvgScore = document.getElementById('statAvgScore');
    const statCoins = document.getElementById('statCoins');
    const statDiamondsItem = document.getElementById('statDiamondsItem');
    const statDiamonds = document.getElementById('statDiamonds');
    const newNameInputUS = document.getElementById('newNameInputUS');
    const changeNameBtnUS = document.getElementById('changeNameBtnUS');
    const deleteAccountBtn = document.getElementById('deleteAccountBtn');
    const nameTimer = document.getElementById('nameTimer');
    const hudEl = document.getElementById('hud');
    const coinsDisplay = document.getElementById('coinsDisplay');
    const diamondsDisplay = document.getElementById('diamondsDisplay');
    const eventDisplay = document.getElementById('eventDisplay');
    const eventTimer = document.getElementById('eventTimer');
    const shopBtn = document.getElementById('shopBtn');
    const shopOverlay = document.getElementById('shopOverlay');
    const backFromShop = document.getElementById('backFromShop');
    const shopCoins = document.getElementById('shopCoins');
    const shopDiamondsInfo = document.getElementById('shopDiamondsInfo');
    const shopDiamonds = document.getElementById('shopDiamonds');
    const spinBtn = document.getElementById('spinBtn');
    const spinResult = document.getElementById('spinResult');
    const wallpaperGrid = document.getElementById('wallpaperGrid');
    const eventShopSection = document.getElementById('eventShopSection');
    const eventWallpaperGrid = document.getElementById('eventWallpaperGrid');
    const devBtn = document.getElementById('devBtn');
    const devPasswordOverlay = document.getElementById('devPasswordOverlay');
    const devPasswordInput = document.getElementById('devPasswordInput');
    const devPasswordSubmit = document.getElementById('devPasswordSubmit');
    const devPasswordBack = document.getElementById('devPasswordBack');
    const devPanelOverlay = document.getElementById('devPanelOverlay');
    const devSearchInput = document.getElementById('devSearchInput');
    const devSearchBtn = document.getElementById('devSearchBtn');
    const devShowAllUsers = document.getElementById('devShowAllUsers');
    const devUserList = document.getElementById('devUserList');
    const devUserListContent = document.getElementById('devUserListContent');
    const devPlayerInfo = document.getElementById('devPlayerInfo');
    const devPlayerName = document.getElementById('devPlayerName');
    const devHighScore = document.getElementById('devHighScore');
    const devAllTimeScore = document.getElementById('devAllTimeScore');
    const devTotalGames = document.getElementById('devTotalGames');
    const devTotalScore = document.getElementById('devTotalScore');
    const devCoins = document.getElementById('devCoins');
    const devDiamondsField = document.getElementById('devDiamondsField');
    const devDiamonds = document.getElementById('devDiamonds');
    const devPanelBack = document.getElementById('devPanelBack');
    const devWallpaperManager = document.getElementById('devWallpaperManager');
    const devWallpaperList = document.getElementById('devWallpaperList');

    let playerName = '';
    let playerId = '';
    let database = null;
    let playerCoins = 0;
    let playerDiamonds = 0;
    let selectedWallpaper = null;
    let ownedWallpapers = [];
    let ownedEventWallpapers = [];
    const eventToggle = document.getElementById('eventToggle');
    let earnGemsMode = true; // Default to earning gems during events
    let currentLeaderboardTab = 'highScore';
    let devCurrentPlayerId = null;
    let devCurrentPlayerData = null;
    const DEV_PASSWORD = 'qwaszx20';
    
    // Event system variables
    let currentEvent = null;
    let eventEndTime = null;
    let eventTimerInterval = null;
    
    // Sound effects
    let audioContext = null;
let collisionSoundBuffer = null;

// Initialize audio system
function initAudio() {
  try {
    // Create audio context (handles browser compatibility)
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
    
    // Create collision sound programmatically (beep sound)
    createCollisionSound();
    
    console.log('Web Audio API initialized successfully');
  } catch (error) {
    console.log('Web Audio API not supported, sounds disabled:', error);
  }
}

// Create a simple beep sound for collisions
function createCollisionSound() {
  if (!audioContext) return;
  
  const duration = 0.1;
  const sampleRate = audioContext.sampleRate;
  const frameCount = duration * sampleRate;
  
  const buffer = audioContext.createBuffer(1, frameCount, sampleRate);
  const channelData = buffer.getChannelData(0);
  
  // Generate a simple beep tone (440Hz - A4)
  for (let i = 0; i < frameCount; i++) {
    const t = i / sampleRate;
    // Simple sine wave with fade out
    channelData[i] = Math.sin(2 * Math.PI * 440 * t) * (1 - t / duration) * 0.3;
  }
  
  collisionSoundBuffer = buffer;
}

// Play collision sound
function playCollisionSound() {
  if (!audioContext || !collisionSoundBuffer) return;
  
  try {
    // Resume audio context if it's suspended (browser autoplay policy)
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    
    const source = audioContext.createBufferSource();
    source.buffer = collisionSoundBuffer;
    source.connect(audioContext.destination);
    source.start(0);
  } catch (error) {
    console.log('Error playing sound:', error);
  }
}

    let cols = 8, rows = 6;
    let spawnRows = 0;
    let brickW = 0, brickH = 20, brickPad = 1;
    let grid = [];
    let ball = { x:0, y:0, r:10, dx:0, dy:0, speed:5 };
    let paddle = { w:80, h:12, x:0 };
    let score = 0, lives = 3, timePlayed = 0;
    let running = false, endlessMode = false;
    let paused = false;
    let gameLoopId = null, timeIntervalId = null, spawnIntervalId = null;
    let lastSettings = { speedVal:3, mode:'12' };

    function debugPlayerState() {
  console.log('=== PLAYER STATE DEBUG ===');
  console.log('Player ID:', localStorage.getItem('brickBlasterPlayerId'));
  console.log('Player Name:', localStorage.getItem('brickBlasterPlayerName'));
  console.log('All Players Registry:', JSON.parse(localStorage.getItem('brickBlasterAllPlayers') || '{}'));
  console.log('UI Elements:');
  console.log('- Settings Div:', settingsDiv.style.display);
  console.log('- Name Prompt:', namePrompt.style.display);
  console.log('- Shop Button:', shopBtn.style.display);
  console.log('- Leaderboard Button:', leaderboardBtn.style.display);
  console.log('- User Settings Button:', userSettingsBtn.style.display);
  console.log('- Dev Button:', devBtn.style.display);
  console.log('==========================');
}

    // Image wallpapers setup
    const wallpaperImages = {};
    // Keep gradients for spinning, use images for events
const wallpaperUrls = [
  'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
  'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
  'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
  'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
  'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
  'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
  'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
  'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
  'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
  'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)',
  'linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%)',
  'linear-gradient(135deg, #f77062 0%, #fe5196 100%)',
  'linear-gradient(135deg, #21d4fd 0%, #b721ff 100%)',
  'linear-gradient(135deg, #08aeea 0%, #2af598 100%)',
  'linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%)',
  'linear-gradient(135deg, #fddb92 0%, #d1fdff 100%)',
  'linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%)',
  // 3 RARE wallpapers (10% chance each)
  'linear-gradient(135deg, #ffd700 0%, #ff8c00 20%, #ff1493 40%, #9400d3 60%, #4b0082 80%, #000033 100%)',
  'radial-gradient(circle at 30% 30%, #00ffff, #0080ff 30%, #8000ff 60%, #2d0a4e)',
  'linear-gradient(45deg, #ff0000 0%, #ff7f00 12.5%, #ffff00 25%, #00ff00 37.5%, #0000ff 50%, #4b0082 62.5%, #9400d3 75%, #ff0844 87.5%, #ff0000 100%)'
];
    
    const rareIndices = [17, 18, 19]; // Last 3 are rare

    // Event Configuration - All events defined in one place
    const events = {
      summer: {
        name: "Summer",
        gemsRequired: 10000,
        startMonth: 5, // June (0-indexed)
        startDay: 15,
        endMonth: 6, // July (0-indexed)
        endDay: 15,
        wallpaper: 'https://raw.githubusercontent.com/abc892/brick-blaster-images/main/summer.jpg',
        displayName: "☀️ SUMMER EVENT ☀️",
        background: 'linear-gradient(135deg, #ff7e5f, #feb47b)'
      },
      halloween: {
        name: "Halloween",
        gemsRequired: 10000,
        startMonth: 9, // October (0-indexed)
        startDay: 1,
        endMonth: 10, // October (0-indexed)
        endDay: 1,
        wallpaper: 'https://raw.githubusercontent.com/abc892/brick-blaster-images/main/haloween.png',
        displayName: "🎃 HALLOWEEN EVENT 🎃",
        background: 'linear-gradient(135deg, #ff8c00, #8b0000)'
      },
      winter: {
        name: "Winter",
        gemsRequired: 10000,
        startMonth: 11, // December (0-indexed)
        startDay: 10,
        endMonth: 0, // January (0-indexed)
        endDay: 10,
        wallpaper: 'https://raw.githubusercontent.com/abc892/brick-blaster-images/main/Background_winter.jpg',
        displayName: "❄️ WINTER EVENT ❄️",
        background: 'linear-gradient(135deg, #1e3c72, #e6f3ff)'
      },
    };

    // Event wallpapers - now using image URLs
    const eventWallpapers = {};
    for (const [key, event] of Object.entries(events)) {
      eventWallpapers[key] = event.wallpaper;
    }

    // Preload only event wallpapers (gradients don't need preloading)
function preloadWallpaperImages() {
  // Only preload event wallpapers (images)
  Object.values(events).forEach(event => {
    const url = event.wallpaper;
    const img = new Image();
    img.onload = () => {
      wallpaperImages[url] = img;
    };
    img.onerror = () => {
      console.warn(`Failed to load event wallpaper: ${url}`);
      wallpaperImages[url] = null;
    };
    img.src = url;
  });
}

// Preload and cache - only event wallpapers need caching
function preloadAndCacheWallpapers() {
  console.log('Preloading and caching event wallpapers...');
  
  // Only cache event wallpapers (gradients don't need caching)
  Object.values(eventWallpapers).forEach(url => {
    const img = new Image();
    img.src = url;
    wallpaperImages[url] = img;
  });
  
  console.log('Event wallpapers preloaded for offline use');
}

    // --- FIXED: Initialize Firebase Only Once ---
    function initializeFirebase() {
      if (typeof firebase === 'undefined') {
        console.log('Firebase not available - running in offline mode');
        return;
      }

      // Check if Firebase is already initialized to prevent conflicts
      if (window.firebaseInitialized) {
        database = firebase.database();
        return;
      }

      const firebaseConfig = {
        apiKey: "AIzaSyAwEy-sJx7E61BA6VmBfIFMZsjuAj8RK5g",
        authDomain: "games-c3e27.firebaseapp.com",
        databaseURL: "https://games-c3e27-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "games-c3e27",
        storageBucket: "games-c3e27.firebasestorage.app",
        messagingSenderId: "193027632069",
        appId: "1:193027632069:web:b559c3b10011bc6982b9ac"
      };

      try {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        window.firebaseInitialized = true;
        console.log('Firebase initialized successfully');
      } catch (error) {
        console.log('Firebase initialization failed - running in offline mode');
        database = null;
      }
    }

    // --- Event System ---
    function checkCurrentEvent() {
      const now = new Date();
      const year = now.getFullYear();
      
      // Check each event
      for (const [eventKey, event] of Object.entries(events)) {
        let startDate, endDate;
        
        // Handle year wrap-around for events like Winter
        if (event.startMonth > event.endMonth) {
          // Event spans across year end (e.g., December to January)
          startDate = new Date(year, event.startMonth, event.startDay);
          endDate = new Date(year + 1, event.endMonth, event.endDay);
        } else {
          // Normal event within same year
          startDate = new Date(year, event.startMonth, event.startDay);
          endDate = new Date(year, event.endMonth, event.endDay);
        }
        
        if (now >= startDate && now <= endDate) {
          currentEvent = eventKey;
          eventEndTime = endDate;
          eventDisplay.textContent = event.displayName;
          eventDisplay.style.background = event.background;
          eventDisplay.style.color = '#fff';
          
          // Show event UI
          eventDisplay.style.display = 'block';
          eventTimer.style.display = 'block';
          diamondsDisplay.style.display = 'block';
          eventToggle.style.display = 'block'; // ADD THIS LINE
          
          // Start event timer
          updateEventTimer();
          if (eventTimerInterval) clearInterval(eventTimerInterval);
          eventTimerInterval = setInterval(updateEventTimer, 1000);
          return;
        }
      }
      
      // No active event
      currentEvent = null;
      eventEndTime = null;
      eventDisplay.style.display = 'none';
      eventTimer.style.display = 'none';
      diamondsDisplay.style.display = 'none';
    }
    
    function updateEventTimer() {
      if (!eventEndTime) return;
      
      const now = new Date();
      const timeLeft = eventEndTime - now;
      
      if (timeLeft <= 0) {
        // Event ended
        currentEvent = null;
        eventEndTime = null;
        eventDisplay.style.display = 'none';
        eventTimer.style.display = 'none';
        diamondsDisplay.style.display = 'none';
        clearInterval(eventTimerInterval);
        
        // Reset diamonds for all players
        if (database) {
          database.ref('players').once('value').then(snapshot => {
            const updates = {};
            snapshot.forEach(child => {
              updates[child.key + '/diamonds'] = 0;
            });
            database.ref('players').update(updates);
          });
        }
        
        // Reset local diamonds
        playerDiamonds = 0;
        localStorage.setItem('brickBlasterDiamonds', '0');
        
        return;
      }
      
      const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
      
      eventTimer.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
    }

    // --- Helpers ---
    function setCanvasSize(w,h){
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }

    function computeGridFromMode(mode){
      if(mode === '12'){
        cols = 4; rows = 3;
      } else if(mode === '24'){
        cols = 6; rows = 4;
      } else {
        cols = 8; rows = 6;
      }
      const maxSpawnRows = document.fullscreenElement ? 30 : 15;
      spawnRows = maxSpawnRows;
      brickW = (canvas.width - (cols - 1) * brickPad) / cols;
    }

    function createGrid(){
      grid = [];
      for(let c=0;c<cols;c++){
        grid[c] = [];
        for(let r=0;r<spawnRows;r++) grid[c][r] = 0;
      }
    }

    function fillInitialBricks(mode){
      if(mode === 'endless'){
        const startCols = 8, startRows = 6;
        for(let c=0;c<startCols;c++) for(let r=0;r<startRows;r++) grid[c][r] = 1;
      } else {
        const total = parseInt(mode);
        let placed = 0;
        for(let r=0;r<rows && placed<total;r++){
          for(let c=0;c<cols && placed<total;c++){
            grid[c][r] = 1;
            placed++;
          }
        }
      }
    }

    function spawnNewBrick(){
      if(!endlessMode) return;
      let candidates = [];
      for(let c=0;c<cols;c++){
        for(let r=rows;r<spawnRows;r++){
          if(grid[c][r] === 0) candidates.push({c,r});
        }
      }
      if(candidates.length === 0){
        for(let c=0;c<cols;c++){
          for(let r=0;r<spawnRows;r++) if(grid[c][r] === 0) candidates.push({c,r});
        }
      }
      if(candidates.length === 0) return;
      const pick = candidates[Math.floor(Math.random() * candidates.length)];
      grid[pick.c][pick.r] = 1;
    }

    function generateVelocity(speed){
      const deg = (Math.random() * 40 + 25);
      const rad = deg * Math.PI / 180;
      const dir = (Math.random() < 0.5) ? -1 : 1;
      const dx = Math.cos(rad) * speed * dir;
      const dy = -Math.sin(rad) * speed;
      return {dx,dy};
    }

    // --- Drawing and collision ---
    function drawBricks(){
      for(let c=0;c<cols;c++){
        for(let r=0;r<spawnRows;r++){
          if(grid[c][r] === 1){
            const x = c * (brickW + brickPad);
            const y = r * (brickH + brickPad);
            ctx.fillStyle = '#f33';
            ctx.fillRect(x, y, brickW, brickH);
          }
        }
      }
    }

    function draw(){
  // Apply wallpaper background if selected
  if(selectedWallpaper){
    // Check if it's a gradient or image
    if (selectedWallpaper.includes('gradient')) {
      // It's a gradient - use parseGradient
      const gradient = parseGradient(selectedWallpaper);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else {
      // It's an image - check if loaded
      if (wallpaperImages[selectedWallpaper] && wallpaperImages[selectedWallpaper].complete && wallpaperImages[selectedWallpaper].naturalWidth > 0) {
        ctx.drawImage(wallpaperImages[selectedWallpaper], 0, 0, canvas.width, canvas.height);
      } else {
        // Fallback to default background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }
  } else {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  
  drawBricks();
  
  // ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fillStyle = '#ffdd00';
  ctx.fill();
  ctx.closePath();
  
  // paddle - bright green to be visible on all wallpapers
  ctx.fillStyle = '#00ff00';
  ctx.fillRect(paddle.x, canvas.height - paddle.h - 10, paddle.w, paddle.h);
  
  // HUD
  hudLives.textContent = lives;
  hudScore.textContent = score;
  hudTime.textContent = timePlayed;
}

    function setupEventToggle() {
  eventToggle.addEventListener('click', () => {
    earnGemsMode = !earnGemsMode;
    
    if (earnGemsMode) {
      eventToggle.classList.remove('coin-mode');
    } else {
      eventToggle.classList.add('coin-mode');
    }
    
    // Save preference to localStorage
    localStorage.setItem('brickBlasterEarnGemsMode', earnGemsMode.toString());
  });
  
  // Load saved preference
  const savedMode = localStorage.getItem('brickBlasterEarnGemsMode');
  if (savedMode !== null) {
    earnGemsMode = savedMode === 'true';
    if (!earnGemsMode) {
      eventToggle.classList.add('coin-mode');
    }
  }
}
    
    function parseGradient(cssGradient) {
      // Extract gradient type and content
      const isRadial = cssGradient.includes('radial-gradient');
      const match = cssGradient.match(/\((.*)\)/);
      if (!match) return '#111';
      
      const content = match[1];
      const parts = content.split(',').map(s => s.trim());
      
      let gradient;
      if (isRadial) {
        // Radial gradient
        gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
        parts.forEach(part => {
          if (part.includes('#') || part.includes('rgb')) {
            const colorMatch = part.match(/(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|rgb\([^)]+\))/);
            const percentMatch = part.match(/(\d+)%/);
            if (colorMatch && percentMatch) {
              gradient.addColorStop(parseInt(percentMatch[1]) / 100, colorMatch[1]);
            } else if (colorMatch) {
              gradient.addColorStop(0, colorMatch[1]);
            }
          }
        });
      } else {
        // Linear gradient - default to 135deg diagonal
        const x0 = 0, y0 = canvas.height, x1 = canvas.width, y1 = 0;
        gradient = ctx.createLinearGradient(x0, y0, x1, y1);
        
        parts.forEach(part => {
          if (part.includes('#') || part.includes('rgb')) {
            const colorMatch = part.match(/(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|rgb\([^)]+\))/);
            const percentMatch = part.match(/(\d+)%/);
            if (colorMatch && percentMatch) {
              gradient.addColorStop(parseInt(percentMatch[1]) / 100, colorMatch[1]);
            } else if (colorMatch) {
              gradient.addColorStop(0, colorMatch[1]);
            }
          }
        });
      }
      
      return gradient;
    }

    function checkCollisions(){
      for(let c=0;c<cols;c++){
        for(let r=0;r<spawnRows;r++){
          if(grid[c][r] === 1){
            const bx = c * (brickW + brickPad);
            const by = r * (brickH + brickPad);
            if(ball.x + ball.r > bx && ball.x - ball.r < bx + brickW && 
               ball.y + ball.r > by && ball.y - ball.r < by + brickH){
              grid[c][r] = 0;
              score++;
              
              // Play collision sound
              playCollisionSound();
              
              ball.dy = -ball.dy;
              ball.dx += (Math.random() - 0.5) * 0.2;
              if(!endlessMode){
                let totalBricks = 0;
                for(let cc=0;cc<cols;cc++) for(let rr=0;rr<rows;rr++) if(grid[cc][rr]===1) totalBricks++;
                if(totalBricks === 0) endRound(true);
              }
              return;
            }
          }
        }
      }
      if(ball.x + ball.dx > canvas.width - ball.r || ball.x + ball.dx < ball.r) {
        ball.dx = -ball.dx;
        // Play collision sound
        playCollisionSound();
      }
      if(ball.y + ball.dy < ball.r) {
        ball.dy = -ball.dy;
        // Play collision sound
        playCollisionSound();
      }
      const paddleTop = canvas.height - paddle.h - 10;
      if(ball.y + ball.r >= paddleTop && ball.y - ball.r < paddleTop + paddle.h){
        if(ball.x >= paddle.x && ball.x <= paddle.x + paddle.w){
          // Play collision sound
          playCollisionSound();
          
          const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
          const speed = ball.speed;
          const angle = hit * (Math.PI/3);
          ball.dx = speed * Math.sin(angle);
          ball.dy = -Math.abs(speed * Math.cos(angle));
        }
      } else if(ball.y - ball.r > canvas.height){
        lives--;
        if(lives <= 0) endRound(false);
        else resetBall();
      }
    }

    function resetBall(){
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 60;
      const v = generateVelocity(ball.speed);
      ball.dx = v.dx;
      ball.dy = v.dy;
    }

    function loop(){
      if(!running || paused) return;
      ball.x += ball.dx;
      ball.y += ball.dy;
      checkCollisions();
      if(window._right) paddle.x = Math.min(canvas.width - paddle.w, paddle.x + 7);
      if(window._left) paddle.x = Math.max(0, paddle.x - 7);
      draw();
      requestAnimationFrame(loop);
    }

    function startCountdownThenStart(){
      countdownEl.style.display = 'flex';
      let n = 3;
      countdownEl.textContent = n;
      const t = setInterval(()=>{
        n--;
        if(n>0) countdownEl.textContent = n;
        else {
          clearInterval(t);
          countdownEl.style.display='none';
          beginPlay();
        }
      },1000);
    }

    function beginPlay(){
      if (!audioContext) {
    initAudio();
  }
  
  running = true;
  paused = false;
  timePlayed = 0;
      running = true;
      paused = false;
      timePlayed = 0;
      score = 0;
      lives = 3;
      hudLives.textContent = lives;
      hudScore.textContent = score;
      hudTime.textContent = timePlayed;
      startDeletionMonitoring();
      resetBall();
      paddle.x = (canvas.width - paddle.w)/2;
      pauseBtn.style.display = 'block';
      leaderboardBtn.style.display = 'none';
      userSettingsBtn.style.display = 'none';
      shopBtn.style.display = 'none';
      coinsDisplay.style.display = 'none';
      diamondsDisplay.style.display = 'none';
      eventDisplay.style.display = 'none';
      eventTimer.style.display = 'none';
      eventToggle.style.display = 'none'; // ADD THIS LINE
      devBtn.style.display = 'none';
      hudEl.style.display = 'block';
      if(endlessMode){
        clearInterval(spawnIntervalId);
        spawnIntervalId = setInterval(spawnNewBrick,3000);
      }
      if(timeIntervalId) clearInterval(timeIntervalId);
      timeIntervalId = setInterval(()=>{
        if(running && !paused) timePlayed++;
      },1000);
      requestAnimationFrame(loop);
    }

    function startGameWithSettings(useLast=false){
      let speedVal, modeVal;
      if(useLast){
        speedVal = lastSettings.speedVal;
        modeVal = lastSettings.mode;
      } else{
        speedVal = parseFloat(document.getElementById('speedSelect').value);
        modeVal = document.getElementById('brickSelect').value;
        lastSettings = { speedVal, mode: modeVal };
      }
      ball.speed = speedVal;
      const v = generateVelocity(ball.speed);
      ball.r = (modeVal==='12')?10:(modeVal==='24')?9:8;
      ball.dx = v.dx;
      ball.dy = v.dy;
      paddle.w = (modeVal==='12')?100:(modeVal==='24')?85:70;
      paddle.h = 12;
      endlessMode = (modeVal === 'endless');
      const modeForGrid = endlessMode ? '48' : modeVal;
      computeGridFromMode(modeForGrid);
      createGrid();
      fillInitialBricks(modeVal);
      settingsDiv.style.display = 'none';
      overlay.style.display = 'none';
      canvas.style.display = 'block';
      startCountdownThenStart();
    }

    function endRound(win){
      running = false;
      paused = false;
      stopDeletionMonitoring();
      pauseBtn.style.display = 'none';
      clearInterval(timeIntervalId);
      clearInterval(spawnIntervalId);
      endText.textContent = (win ? '🎉 You Win!' : '💀 Game Over');
      overlay.style.display = 'flex';
      overlay.style.zIndex = 1000;
      endText.textContent += ` | Score: ${score} | Time: ${timePlayed}s`;
      leaderboardBtn.style.display = 'block';
      userSettingsBtn.style.display = 'block';
      shopBtn.style.display = 'block';
      coinsDisplay.style.display = 'block';
      if (currentEvent) {
        diamondsDisplay.style.display = 'block';
        eventDisplay.style.display = 'block';
        eventTimer.style.display = 'block';
        eventToggle.style.display = 'block'; // ADD THIS LINE
      }
      devBtn.style.display = 'block';
      hudEl.style.display = 'none';
      updatePlayerStats(score);
    }

    retryBtn.addEventListener('click', ()=>{
      overlay.style.display='none';
      startGameWithSettings(true);
    });

    settingsBtn.addEventListener('click', ()=>{
      overlay.style.display='none';
      settingsDiv.style.display='flex';
      canvas.style.display='none';
      leaderboardBtn.style.display = 'block';
      userSettingsBtn.style.display = 'block';
      shopBtn.style.display = 'block';
      coinsDisplay.style.display = 'block';
      if (currentEvent) {
        diamondsDisplay.style.display = 'block';
        eventDisplay.style.display = 'block';
        eventTimer.style.display = 'block';
        eventToggle.style.display = 'block'; // ADD THIS LINE
      }
      devBtn.style.display = 'block';
      hudEl.style.display = 'none';
    });

    homeBtn2.addEventListener('click', ()=>location.href='index.html');

    pauseBtn.addEventListener('click', ()=>{
      if(running && !paused){
        paused = true;
        pauseOverlay.style.display = 'flex';
      }
    });

    resumeBtn.addEventListener('click', ()=>{
      paused = false;
      pauseOverlay.style.display = 'none';
      requestAnimationFrame(loop);
    });

    pauseSettingsBtn.addEventListener('click', ()=>{
      running = false;
      paused = false;
      pauseBtn.style.display = 'none';
      pauseOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
      canvas.style.display = 'none';
      clearInterval(timeIntervalId);
      clearInterval(spawnIntervalId);
      leaderboardBtn.style.display = 'block';
      userSettingsBtn.style.display = 'block';
      shopBtn.style.display = 'block';
      coinsDisplay.style.display = 'block';
      if (currentEvent) {
        diamondsDisplay.style.display = 'block';
        eventDisplay.style.display = 'block';
        eventTimer.style.display = 'block';
        eventToggle.style.display = 'block'; // ADD THIS LINE
      }
      devBtn.style.display = 'block';
      hudEl.style.display = 'none';
    });

    window._left = false;
    window._right = false;
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft') window._left = true;
      if(e.key === 'ArrowRight') window._right = true;
      if(e.key.toLowerCase() === 'f') toggleFullscreen();
      if(e.key.toLowerCase() === 'p' && running){
        if(!paused){
          paused = true;
          pauseOverlay.style.display = 'flex';
        } else {
          paused = false;
          pauseOverlay.style.display = 'none';
          requestAnimationFrame(loop);
        }
      }
      if(e.code === 'Space' && overlay.style.display === 'flex') {
        overlay.style.display='none';
        startGameWithSettings(true);
      }
    });

    document.addEventListener('keyup', (e)=>{
      if(e.key === 'ArrowLeft') window._left = false;
      if(e.key === 'ArrowRight') window._right = false;
    });

    function toggleFullscreen(){
      if(!document.fullscreenElement){
        document.documentElement.requestFullscreen().catch(()=>{});
      } else document.exitFullscreen().catch(()=>{});
    }

    document.addEventListener('fullscreenchange', ()=>{
      if(document.fullscreenElement){
        setCanvasSize(window.innerWidth, window.innerHeight);
      } else {
        setCanvasSize(800,600);
      }
      if(!running) {
        computeGridFromMode(lastSettings.mode === 'endless' ? '48' : lastSettings.mode);
        createGrid();
        fillInitialBricks(lastSettings.mode);
        paddle.x = Math.min(Math.max(0, paddle.x), canvas.width - paddle.w);
        ball.x = Math.min(Math.max(ball.r, ball.x), canvas.width - ball.r);
        resetBall();
        draw();
      } else {
        const oldBrickW = brickW;
        computeGridFromMode(lastSettings.mode === 'endless' ? '48' : lastSettings.mode);
        paddle.x = Math.min(Math.max(0, paddle.x), canvas.width - paddle.w);
        ball.x = Math.min(Math.max(ball.r, ball.x), canvas.width - ball.r);
        ball.y = Math.min(Math.max(ball.r, ball.y), canvas.height - ball.r);
      }
    });

    startBtn.addEventListener('click', ()=>{
      startGameWithSettings(false);
    });

    // FIX: Pause game when switching tabs
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && running && !paused) {
        paused = true;
        pauseOverlay.style.display = 'flex';
      }
    });

    window.addEventListener('beforeunload', ()=>{
      clearInterval(spawnIntervalId);
      clearInterval(timeIntervalId);
      if (eventTimerInterval) clearInterval(eventTimerInterval);
    });

    setCanvasSize(800,600);
    computeGridFromMode('12');
    createGrid();
    fillInitialBricks('12');
    draw();

    // --- FIXED: Name and Player System with Proper Database Sync ---
    function initializePlayer() {
  playerId = localStorage.getItem('brickBlasterPlayerId');
  playerName = localStorage.getItem('brickBlasterPlayerName');
  
  console.log('Initializing player:', { playerId, playerName });
  
  // Check if we have BOTH ID and name (complete player data)
  if (!playerId || !playerName) {
    console.log('No valid player data found, showing name prompt');
    resetToNewPlayerState();
    namePrompt.style.display = 'flex';
    return;
  }
  
  // We have player data - validate it's not corrupted
  if (playerName === 'undefined' || playerName.trim() === '' || playerId === 'undefined') {
    console.log('Corrupted player data found, resetting');
    resetToNewPlayerState();
    namePrompt.style.display = 'flex';
    return;
  }
  
  // NEW: Check if this player was deleted by developer
  checkIfPlayerDeleted().then((wasDeleted) => {
    if (wasDeleted) {
      // Account was deleted - show message and reset
      alert('Your account has been deleted by an administrator. Please create a new account.');
      resetToNewPlayerState();
      namePrompt.style.display = 'flex';
    } else {
      // Valid existing player - load their data
      console.log('Loading existing player:', playerName);
      settingsDiv.style.display = 'flex';
      loadPlayerData();
      devBtn.style.display = 'block';
      
      // Check for current event
      checkCurrentEvent();
    }
  });
}

function resetToNewPlayerState() {
  // Clear any partial player data
  localStorage.removeItem('brickBlasterPlayerId');
  localStorage.removeItem('brickBlasterPlayerName');
  
  // Reset variables
  playerId = '';
  playerName = '';
  
  // Reset UI to new player state
  settingsDiv.style.display = 'none';
  coinsDisplay.style.display = 'none';
  diamondsDisplay.style.display = 'none';
  shopBtn.style.display = 'none';
  devBtn.style.display = 'none';
  leaderboardBtn.style.display = 'none';
  userSettingsBtn.style.display = 'none';
}

    function submitName() {
    const name = nameInput.value.trim();
    console.log('Submit button clicked with name:', name);
    
    if (name.length === 0) {
        alert('Please enter a valid name');
        return;
    }
    
    console.log('Checking name availability...');
    
    // FIX: Check if name is available (both in Firebase and local storage)
    checkNameAvailability(name).then((isAvailable) => {
        console.log('Name availability result:', isAvailable);
        
        if (!isAvailable) {
            alert('This name is already taken. Please choose another name.');
            nameInput.value = '';
            nameSubmit.disabled = true; // Disable button again
            return;
        }
        
        console.log('Completing name submission...');
        completeNameSubmission(name);
    }).catch((error) => {
        console.log('Name check failed, proceeding anyway:', error);
        // If check fails, proceed with submission anyway
        completeNameSubmission(name);
    });
}

    function checkNameAvailability(name) {
  return new Promise((resolve) => {
    // First check local storage registry
    const existingPlayers = JSON.parse(localStorage.getItem('brickBlasterAllPlayers') || '{}');
    
    // Get current player name (if any)
    const currentPlayerName = localStorage.getItem('brickBlasterPlayerName');
    
    // Check if name exists AND has a valid player ID (not deleted)
    if (existingPlayers[name]) {
      // If we have a current player name and it matches the requested name, allow it
      // This handles the case where a player just deleted their account and is trying to recreate
      if (currentPlayerName === name) {
        resolve(true);
        return;
      }
      
      // If we don't have a current player but the name exists in registry,
      // check if there's actually a player ID associated
      const playerId = localStorage.getItem('brickBlasterPlayerId');
      if (!playerId) {
        // No current player ID - this means the account was deleted
        // Remove the name from registry and allow it
        delete existingPlayers[name];
        localStorage.setItem('brickBlasterAllPlayers', JSON.stringify(existingPlayers));
        resolve(true);
        return;
      }
      
      // Name is taken by someone else
      resolve(false);
      return;
    }
    
    // Then check Firebase if available
    if (database) {
      database.ref('players').orderByChild('name').equalTo(name).once('value').then((snapshot) => {
        resolve(!snapshot.exists());
      }).catch((error) => {
        // If Firebase check fails, assume name is available
        resolve(true);
      });
    } else {
      // No database, only local check passed
      resolve(true);
    }
  });
}

    function completeNameSubmission(name) {
  playerName = name;
  
  // Generate new player ID
  playerId = 'player_' + Math.random().toString(36).substr(2, 16) + '_' + Date.now();
  
  // Save to local storage
  localStorage.setItem('brickBlasterPlayerId', playerId);
  localStorage.setItem('brickBlasterPlayerName', playerName);
  
  // Update local player registry
  const existingPlayers = JSON.parse(localStorage.getItem('brickBlasterAllPlayers') || '{}');
  existingPlayers[name] = true;
  localStorage.setItem('brickBlasterAllPlayers', JSON.stringify(existingPlayers));
  
  // Initialize default player data for NEW player only
  const playerData = {
    name: playerName,
    highScore: 0,
    allTimeScore: 0,
    totalGames: 0,
    totalScore: 0,
    coins: 0,
    diamonds: 0,
    ownedWallpapers: [],
    ownedEventWallpapers: [],
    selectedWallpaper: null,
    lastNameChange: Date.now(),
    lastUpdated: Date.now()
  };
  
  // Save to local storage first
  localStorage.setItem(`brickBlaster_${playerId}_coins`, '0');
  localStorage.setItem(`brickBlaster_${playerId}_diamonds`, '0');
  localStorage.setItem(`brickBlaster_${playerId}_ownedWallpapers`, JSON.stringify([]));
  localStorage.setItem(`brickBlaster_${playerId}_ownedEventWallpapers`, JSON.stringify([]));
  
  // Then save to Firebase if available - FIXED: Only set data for this specific player
  if (database) {
    database.ref('players/' + playerId).set(playerData)
      .then(() => {
        console.log('New player saved to database');
      })
      .catch((error) => {
        console.log('Failed to save player to database, saved locally');
      });
  }
  
  // Complete the initialization
  namePrompt.style.display = 'none';
  settingsDiv.style.display = 'flex';
  
  // Load player data and show UI elements
  loadPlayerData();
  devBtn.style.display = 'block';
  leaderboardBtn.style.display = 'block';
  userSettingsBtn.style.display = 'block';
  shopBtn.style.display = 'block';
  coinsDisplay.style.display = 'block';
  
  console.log('New player created successfully:', playerName);
}

    function loadPlayerData() {
  if (!playerId || !playerName) {
    console.error('Cannot load player data: missing ID or name');
    return;
  }
  
  // Load player-specific data from localStorage using playerId as scope
  playerCoins = parseInt(localStorage.getItem(`brickBlaster_${playerId}_coins`)) || 0;
  playerDiamonds = parseInt(localStorage.getItem(`brickBlaster_${playerId}_diamonds`)) || 0;
  
  try {
    ownedWallpapers = JSON.parse(localStorage.getItem(`brickBlaster_${playerId}_ownedWallpapers`) || '[]');
    ownedEventWallpapers = JSON.parse(localStorage.getItem(`brickBlaster_${playerId}_ownedEventWallpapers`) || '[]');
    selectedWallpaper = localStorage.getItem(`brickBlaster_${playerId}_wallpaper`);
  } catch (e) {
    ownedWallpapers = [];
    ownedEventWallpapers = [];
    selectedWallpaper = null;
  }
  
  coinsDisplay.textContent = playerCoins;
  diamondsDisplay.textContent = playerDiamonds;
  coinsDisplay.style.display = 'block';
  if (currentEvent) diamondsDisplay.style.display = 'block';
  shopBtn.style.display = 'block';
  
  // Then sync with Firebase if available
  if (database && playerId) {
    database.ref('players/' + playerId).once('value').then((snapshot) => {
      const data = snapshot.val();
      if (data) {
        // Use database data as source of truth when online
        playerCoins = data.coins || 0;
        playerDiamonds = data.diamonds || 0;
        ownedWallpapers = data.ownedWallpapers || [];
        ownedEventWallpapers = data.ownedEventWallpapers || [];
        selectedWallpaper = data.selectedWallpaper || null;
        
        // Update local storage with database data (scoped to player)
        localStorage.setItem(`brickBlaster_${playerId}_coins`, playerCoins.toString());
        localStorage.setItem(`brickBlaster_${playerId}_diamonds`, playerDiamonds.toString());
        localStorage.setItem(`brickBlaster_${playerId}_ownedWallpapers`, JSON.stringify(ownedWallpapers));
        localStorage.setItem(`brickBlaster_${playerId}_ownedEventWallpapers`, JSON.stringify(ownedEventWallpapers));
        if (selectedWallpaper) {
          localStorage.setItem(`brickBlaster_${playerId}_wallpaper`, selectedWallpaper);
        }
        
        // Update UI
        coinsDisplay.textContent = playerCoins;
        diamondsDisplay.textContent = playerDiamonds;
      } else {
        // Player doesn't exist in database, create them
        const playerData = {
          name: playerName,
          highScore: 0,
          allTimeScore: 0,
          totalGames: 0,
          totalScore: 0,
          coins: playerCoins,
          diamonds: playerDiamonds,
          ownedWallpapers: ownedWallpapers,
          ownedEventWallpapers: ownedEventWallpapers,
          selectedWallpaper: selectedWallpaper,
          lastNameChange: Date.now(),
          lastUpdated: Date.now()
        };
        
        database.ref('players/' + playerId).set(playerData);
      }
    }).catch((error) => {
      console.log('Firebase load failed, using local data');
    });
  }
}

    function updatePlayerStats(newScore) {
  let coinsEarned = 0;
  let diamondsEarned = 0;
  
  if (currentEvent) {
    // During events, check toggle mode
    if (earnGemsMode) {
      // Earn diamonds
      diamondsEarned = newScore;
      
      // Cap at 10,000 (allow exactly 10,000 for purchase)
      if (playerDiamonds >= 10000) {
        diamondsEarned = 0;
      } else if (playerDiamonds + diamondsEarned > 10000) {
        diamondsEarned = 10000 - playerDiamonds;
      }
      
      playerDiamonds += diamondsEarned;
    } else {
      // Earn coins instead
      coinsEarned = newScore;
      playerCoins += coinsEarned;
    }
  } else {
    // Normal gameplay - earn coins
    coinsEarned = newScore;
    playerCoins += coinsEarned;
  }
      
      // ALWAYS save to local storage immediately
      localStorage.setItem(`brickBlaster_${playerId}_coins`, playerCoins.toString());
      localStorage.setItem(`brickBlaster_${playerId}_diamonds`, playerDiamonds.toString());
      
      // Update display immediately
      coinsDisplay.textContent = playerCoins;
      diamondsDisplay.textContent = playerDiamonds;
      
      // FIXED: Update Firebase immediately if online
      if (database && playerId) {
        const playerRef = database.ref('players/' + playerId);
        
        playerRef.once('value').then((snapshot) => {
          const data = snapshot.val() || {
            name: playerName,
            highScore: 0,
            allTimeScore: 0,
            totalGames: 0,
            totalScore: 0,
            coins: 0,
            diamonds: 0,
            lastNameChange: Date.now(),
            lastUpdated: Date.now()
          };
          
          const newHighScore = Math.max(data.highScore, newScore);
          const newAllTimeScore = (data.allTimeScore || 0) + newScore;
          const newTotalGames = data.totalGames + 1;
          const newTotalScore = data.totalScore + newScore;
          
          return playerRef.update({
            name: playerName,
            highScore: newHighScore,
            allTimeScore: newAllTimeScore,
            totalGames: newTotalGames,
            totalScore: newTotalScore,
            coins: playerCoins,
            diamonds: playerDiamonds,
            ownedWallpapers: ownedWallpapers,
            ownedEventWallpapers: ownedEventWallpapers,
            selectedWallpaper: selectedWallpaper,
            lastUpdated: Date.now()
          });
        }).then(() => {
          console.log('Stats updated in database');
        }).catch((error) => {
          console.log('Firebase update failed (offline?), saved locally');
        });
      }
    }

    // --- FIXED: Leaderboard with Proper Data ---
    leaderboardBtn.addEventListener('click', showLeaderboard);
    backFromLeaderboard.addEventListener('click', () => {
      leaderboardOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
    });

    tabHighScore.addEventListener('click', () => {
      currentLeaderboardTab = 'highScore';
      tabHighScore.classList.add('active');
      tabAllTime.classList.remove('active');
      loadLeaderboardData();
    });

    tabAllTime.addEventListener('click', () => {
      currentLeaderboardTab = 'allTimeScore';
      tabAllTime.classList.add('active');
      tabHighScore.classList.remove('active');
      loadLeaderboardData();
    });

    function showLeaderboard() {
      if (!database) {
        leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">Leaderboard not available offline</p>';
        leaderboardOverlay.style.display = 'flex';
        return;
      }
      
      leaderboardOverlay.style.display = 'flex';
      currentLeaderboardTab = 'highScore';
      tabHighScore.classList.add('active');
      tabAllTime.classList.remove('active');
      loadLeaderboardData();
    }

    function loadLeaderboardData() {
      leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">Loading...</p>';
      
      // FIXED: Get all players and sort properly
      database.ref('players').once('value').then((snapshot) => {
        const players = [];
        snapshot.forEach((child) => {
          const playerData = child.val();
          // FIX: Filter out undefined or invalid player names
          if (playerData.name && playerData.name !== 'undefined' && playerData.name.trim() !== '') {
            players.push({
              name: playerData.name,
              highScore: playerData.highScore || 0,
              allTimeScore: playerData.allTimeScore || 0
            });
          }
        });
        
        // Sort by current tab
        players.sort((a, b) => {
          if (currentLeaderboardTab === 'highScore') {
            return b.highScore - a.highScore;
          } else {
            return b.allTimeScore - a.allTimeScore;
          }
        });
        
        // Take top 3
        const topPlayers = players.slice(0, 3);
        
        if (topPlayers.length === 0) {
          leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">No players yet. Be the first!</p>';
          return;
        }
        
        let html = '';
        topPlayers.forEach((player, index) => {
          const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
          const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
          const scoreLabel = currentLeaderboardTab === 'highScore' ? 'pts' : 'total pts';
          const scoreValue = currentLeaderboardTab === 'highScore' ? player.highScore : player.allTimeScore;
          html += `<div class="lb-entry ${rankClass}">
            <span>${medal} ${player.name}</span>
            <span>${scoreValue} ${scoreLabel}</span>
          </div>`;
        });
        
        leaderboardList.innerHTML = html;
      }).catch((error) => {
        leaderboardList.innerHTML = '<p style="color:#dfeefb;text-align:center">Error loading leaderboard</p>';
      });
    }

    // --- User Settings ---
    userSettingsBtn.addEventListener('click', showUserSettings);
    backFromUserSettings.addEventListener('click', () => {
      userSettingsOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
    });

    function showUserSettings() {
      userSettingsOverlay.style.display = 'flex';
      
      // FIXED: Always get latest data from database when online
      if (database && playerId) {
        database.ref('players/' + playerId).once('value').then((snapshot) => {
          const data = snapshot.val() || {
            name: playerName,
            highScore: 0,
            allTimeScore: 0,
            totalGames: 0,
            totalScore: 0,
            coins: 0,
            diamonds: 0,
            lastNameChange: Date.now()
          };
          
          updateUserStatsDisplay(data);
        });
      } else {
        // Use local data if no database
        const localData = {
          name: playerName,
          highScore: 0,
          allTimeScore: 0,
          totalGames: 0,
          totalScore: 0,
          coins: playerCoins,
          diamonds: playerDiamonds,
          lastNameChange: Date.now()
        };
        updateUserStatsDisplay(localData);
      }
    }

    function updateUserStatsDisplay(data) {
      statPlayerName.textContent = data.name;
      statHighScore.textContent = data.highScore;
      statAllTimeScore.textContent = data.allTimeScore || 0;
      statTotalGames.textContent = data.totalGames;
      const avgScore = data.totalGames > 0 ? Math.round(data.totalScore / data.totalGames) : 0;
      statAvgScore.textContent = avgScore;
      statCoins.textContent = data.coins || 0;
      
      if (currentEvent) {
        statDiamondsItem.style.display = 'flex';
        statDiamonds.textContent = data.diamonds || 0;
      } else {
        statDiamondsItem.style.display = 'none';
      }
      
      updateNameChangeButton(data.lastNameChange || 0);
    }

    function updateNameChangeButton(lastNameChange) {
      const now = Date.now();
      const tenDays = 10 * 24 * 60 * 60 * 1000;
      const timeSinceChange = now - lastNameChange;
      
      if (timeSinceChange >= tenDays) {
        changeNameBtnUS.disabled = false;
        nameTimer.textContent = '';
      } else {
        changeNameBtnUS.disabled = true;
        const timeRemaining = tenDays - timeSinceChange;
        const daysRemaining = Math.ceil(timeRemaining / (24 * 60 * 60 * 1000));
        nameTimer.textContent = `You can change your name in ${daysRemaining} day(s)`;
      }
    }

    changeNameBtnUS.addEventListener('click', () => {
      const newName = newNameInputUS.value.trim();
      if (newName.length === 0) {
        alert('Please enter a valid name');
        return;
      }
      
      if (!database || !playerId) {
        alert('Name changes require an internet connection');
        return;
      }
      
      database.ref('players/' + playerId).once('value').then((snapshot) => {
        const data = snapshot.val();
        const now = Date.now();
        const tenDays = 10 * 24 * 60 * 60 * 1000;
        const timeSinceChange = now - (data.lastNameChange || 0);
        
        if (timeSinceChange < tenDays) {
          const daysRemaining = Math.ceil((tenDays - timeSinceChange) / (24 * 60 * 60 * 1000));
          alert(`You can change your name in ${daysRemaining} day(s)`);
          return;
        }
        
        // Check if name is already taken
        checkNameAvailability(newName).then((isAvailable) => {
          if (!isAvailable) {
            alert('This name is already taken. Please choose another name.');
            return;
          }
          
          playerName = newName;
          localStorage.setItem('brickBlasterPlayerName', playerName);
          
          // Update local player registry
          const existingPlayers = JSON.parse(localStorage.getItem('brickBlasterAllPlayers') || '{}');
          const oldName = data.name;
          delete existingPlayers[oldName];
          existingPlayers[newName] = true;
          localStorage.setItem('brickBlasterAllPlayers', JSON.stringify(existingPlayers));
          
          database.ref('players/' + playerId).update({
            name: playerName,
            lastNameChange: now,
            lastUpdated: now
          }).then(() => {
            alert('Name updated successfully!');
            newNameInputUS.value = '';
            showUserSettings();
          });
        });
      });
    });

    // --- FIXED: Delete User Account ---
    deleteAccountBtn.addEventListener('click', deleteUserAccount);

    function deleteUserAccount() {
      if (!confirm('Are you sure you want to PERMANENTLY DELETE your account? This will remove ALL your data including scores, coins, and wallpapers. This action cannot be undone!')) {
        return;
      }
      
      if (!confirm('FINAL WARNING: This will completely erase your account from both local storage and the database. Are you absolutely sure?')) {
        return;
      }
      
      // Delete from Firebase if online
      if (database && playerId) {
        database.ref('players/' + playerId).remove().then(() => {
          completeAccountDeletion();
        }).catch((error) => {
          console.log('Firebase deletion failed, proceeding with local deletion');
          completeAccountDeletion();
        });
      } else {
        completeAccountDeletion();
      }
    }

    function completeAccountDeletion() {
  // Get the name to remove BEFORE clearing storage
  const playerNameToRemove = localStorage.getItem('brickBlasterPlayerName');
  
  // Clear ALL player-related local storage
  const keysToRemove = [
  'brickBlasterPlayerId',
  'brickBlasterPlayerName', 
  `brickBlaster_${playerId}_coins`,
  `brickBlaster_${playerId}_diamonds`,
  `brickBlaster_${playerId}_ownedWallpapers`,
  `brickBlaster_${playerId}_ownedEventWallpapers`,
  `brickBlaster_${playerId}_wallpaper`,
  'brickBlasterEarnGemsMode'
];
  
  keysToRemove.forEach(key => {
    localStorage.removeItem(key);
  });
  
  // Remove from local player registry
  if (playerNameToRemove) {
    const existingPlayers = JSON.parse(localStorage.getItem('brickBlasterAllPlayers') || '{}');
    delete existingPlayers[playerNameToRemove];
    localStorage.setItem('brickBlasterAllPlayers', JSON.stringify(existingPlayers));
  }
  
  // Reset all player variables
  playerId = '';
  playerName = '';
  playerCoins = 0;
  playerDiamonds = 0;
  ownedWallpapers = [];
  ownedEventWallpapers = [];
  selectedWallpaper = null;
  earnGemsMode = true;
  
  // Force UI reset
  resetUIAfterDeletion();
}

    function checkIfPlayerDeleted() {
  if (!playerId || !database) return Promise.resolve(false);
  
  return database.ref('deletedPlayers/' + playerId).once('value')
    .then((snapshot) => {
      if (snapshot.exists()) {
        // Player was deleted by developer - clean up local storage
        console.log('Player account was deleted by developer - cleaning local storage');
        completeAccountDeletion();
        return true;
      }
      return false;
    })
    .catch((error) => {
      console.log('Could not check deletion status (offline)');
      return false;
    });
}

    let deletionCheckInterval;

function startDeletionMonitoring() {
  if (!playerId || !database) return;
  
  // Check every 30 seconds if player was deleted
  deletionCheckInterval = setInterval(() => {
    checkIfPlayerDeleted().then((wasDeleted) => {
      if (wasDeleted && running) {
        // If game is running and player was deleted, end the game
        endRound(false);
        alert('Your account has been deleted. Game over.');
      }
    });
  }, 30000);
}

function stopDeletionMonitoring() {
  if (deletionCheckInterval) {
    clearInterval(deletionCheckInterval);
    deletionCheckInterval = null;
  }
}

function resetUIAfterDeletion() {
  // Hide all overlays and UI elements
  userSettingsOverlay.style.display = 'none';
  shopOverlay.style.display = 'none';
  leaderboardOverlay.style.display = 'none';
  devPanelOverlay.style.display = 'none';
  devPasswordOverlay.style.display = 'none';
  pauseOverlay.style.display = 'none';
  overlay.style.display = 'none';
  
  // Reset main UI
  settingsDiv.style.display = 'none';
  canvas.style.display = 'none';
  coinsDisplay.style.display = 'none';
  diamondsDisplay.style.display = 'none';
  eventDisplay.style.display = 'none';
  eventTimer.style.display = 'none';
  eventToggle.style.display = 'none';
  shopBtn.style.display = 'none';
  devBtn.style.display = 'none';
  leaderboardBtn.style.display = 'none';
  userSettingsBtn.style.display = 'none';
  hudEl.style.display = 'none';
  pauseBtn.style.display = 'none';
  
  // Clear any game state
  running = false;
  paused = false;
  clearInterval(timeIntervalId);
  clearInterval(spawnIntervalId);
  clearInterval(eventTimerInterval);
  
  // Show name prompt with fresh state
  nameInput.value = '';
  namePrompt.style.display = 'flex';
}

    // --- Shop System ---
    shopBtn.addEventListener('click', showShop);
    backFromShop.addEventListener('click', () => {
      shopOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
    });

    function showShop() {
      shopOverlay.style.display = 'flex';
      shopCoins.textContent = playerCoins;
      if (currentEvent) {
        shopDiamondsInfo.style.display = 'inline';
        shopDiamonds.textContent = playerDiamonds;
      } else {
        shopDiamondsInfo.style.display = 'none';
      }
      spinResult.textContent = '';
      renderWallpaperGrid();
      renderEventWallpaperGrid();
      updateSpinButton();
    }

    function updateSpinButton() {
      if (playerCoins >= 500) {
        spinBtn.disabled = false;
      } else {
        spinBtn.disabled = true;
      }
    }

    spinBtn.addEventListener('click', () => {
      if (playerCoins < 500) {
        spinResult.textContent = '❌ Not enough coins!';
        return;
      }
      
      playerCoins -= 500;
      coinsDisplay.textContent = playerCoins;
      shopCoins.textContent = playerCoins;
      localStorage.setItem(`brickBlaster_${playerId}_coins`, playerCoins.toString());
      localStorage.setItem(`brickBlaster_${playerId}_ownedWallpapers`, JSON.stringify(ownedWallpapers));
      
      // Spin logic: 10% chance for rare wallpapers
      let selectedIndex;
      const rand = Math.random();
      if (rand < 0.03) {
        // 10% chance: pick from rare wallpapers
        selectedIndex = rareIndices[Math.floor(Math.random() * rareIndices.length)];
      } else {
        // 90% chance: pick from all wallpapers
        selectedIndex = Math.floor(Math.random() * wallpaperUrls.length);
      }
      
      const wonWallpaper = wallpaperUrls[selectedIndex];
      
      // Add the wallpaper to owned wallpapers (allow duplicates)
      ownedWallpapers.push(wonWallpaper);
      
      const isRare = rareIndices.includes(selectedIndex);
      spinResult.textContent = isRare ? '✨ RARE WALLPAPER UNLOCKED! ✨' : '🎉 New Wallpaper Unlocked!';
      spinResult.style.color = isRare ? '#ffd700' : '#c084fc';
      
      // FIXED: Update database immediately
      if (database && playerId) {
        database.ref('players/' + playerId).update({
          coins: playerCoins,
          ownedWallpapers: ownedWallpapers,
          lastUpdated: Date.now()
        });
      }
      
      renderWallpaperGrid();
      updateSpinButton();
    });

   function renderWallpaperGrid() {
  // Combine regular wallpapers with owned event wallpapers
  const allWallpapers = [...ownedWallpapers];
  
  // Add ALL owned event wallpapers (not just the current event)
  ownedEventWallpapers.forEach(eventKey => {
    if (eventWallpapers[eventKey]) {
      allWallpapers.push(eventWallpapers[eventKey]);
    }
  });
  
  if (allWallpapers.length === 0) {
    wallpaperGrid.innerHTML = '<p style="color:#aaa;grid-column:1/-1;text-align:center">No wallpapers yet. Spin to get some!</p>';
    return;
  }
  
  let html = '';
  allWallpapers.forEach((wp, index) => {
    const isSelected = wp === selectedWallpaper;
    const isRare = rareIndices.includes(wallpaperUrls.indexOf(wp));
    const rareClass = isRare ? 'rare' : '';
    const selectedClass = isSelected ? 'selected' : '';
    
    // Check if it's a gradient or image URL
    if (wp.includes('gradient')) {
      // It's a gradient - use background
      html += `<div class="wallpaper-item ${rareClass} ${selectedClass}" style="background:${wp}" data-index="${index}"></div>`;
    } else {
      // It's an image - use background-image
      html += `<div class="wallpaper-item ${rareClass} ${selectedClass}" style="background-image:url('${wp}')" data-index="${index}"></div>`;
    }
  });
  
  wallpaperGrid.innerHTML = html;
  
  document.querySelectorAll('.wallpaper-item').forEach((item, idx) => {
    item.addEventListener('click', () => {
      selectedWallpaper = allWallpapers[idx];
      localStorage.setItem(`brickBlaster_${playerId}_wallpaper`, selectedWallpaper);
      
      if (database && playerId) {
        database.ref('players/' + playerId).update({
          selectedWallpaper: selectedWallpaper,
          lastUpdated: Date.now()
        });
      }
      
      renderWallpaperGrid();
    });
  });
}
    
    function renderEventWallpaperGrid() {
      if (!currentEvent) {
        eventShopSection.style.display = 'none';
        return;
      }
      
      // FIX: Only show event wallpaper section if the wallpaper is not already owned
      if (ownedEventWallpapers.includes(currentEvent)) {
        eventShopSection.style.display = 'none';
        return;
      }
      
      eventShopSection.style.display = 'block';
      
      const event = events[currentEvent];
      const eventWallpaper = eventWallpapers[currentEvent];
      const isOwned = ownedEventWallpapers.includes(currentEvent);
      const canAfford = playerDiamonds >= event.gemsRequired;
      
      let html = '';
      html += `<div class="event-wallpaper-item ${isOwned ? 'selected' : ''}" style="background-image:url('${eventWallpaper}')">
        <div class="price">${isOwned ? 'OWNED' : `${event.gemsRequired.toLocaleString()} 💎`}</div>
      </div>`;
      
      eventWallpaperGrid.innerHTML = html;
      
      document.querySelectorAll('.event-wallpaper-item').forEach((item) => {
        item.addEventListener('click', () => {
          if (isOwned) {
            selectedWallpaper = eventWallpaper;
            
            // FIXED: Update database immediately
            if (database && playerId) {
              database.ref('players/' + playerId).update({
                selectedWallpaper: selectedWallpaper,
                lastUpdated: Date.now()
              });
            }
            
            renderEventWallpaperGrid();
            renderWallpaperGrid();
          } else if (canAfford) {
            if (confirm(`Purchase this ${event.name} event wallpaper for ${event.gemsRequired.toLocaleString()} Diamonds?`)) {
              playerDiamonds -= event.gemsRequired;
              diamondsDisplay.textContent = playerDiamonds;
              shopDiamonds.textContent = playerDiamonds;
              localStorage.setItem(`brickBlaster_${playerId}_diamonds`, playerDiamonds.toString());
              ownedEventWallpapers.push(currentEvent);
              localStorage.setItem(`brickBlaster_${playerId}_ownedEventWallpapers`, JSON.stringify(ownedEventWallpapers));
              
              // FIXED: Update database immediately and include event wallpaper in locker
              if (database && playerId) {
                database.ref('players/' + playerId).update({
                  diamonds: playerDiamonds,
                  ownedEventWallpapers: ownedEventWallpapers,
                  lastUpdated: Date.now()
                });
              }
              
              // FIX: Hide the event section after purchase and refresh the regular wallpaper grid
              eventShopSection.style.display = 'none';
              renderWallpaperGrid();
              alert(`${event.name} event wallpaper purchased!`);
            }
          } else {
            alert(`You need ${event.gemsRequired.toLocaleString()} Diamonds to purchase this ${event.name} event wallpaper!`);
          }
        });
      });
    }

    // --- Developer Panel ---
    devBtn.addEventListener('click', () => {
      devPasswordOverlay.style.display = 'flex';
      devPasswordInput.value = '';
    });

    devPasswordBack.addEventListener('click', () => {
      devPasswordOverlay.style.display = 'none';
    });

    devPasswordSubmit.addEventListener('click', () => {
      if (devPasswordInput.value === DEV_PASSWORD) {
        devPasswordOverlay.style.display = 'none';
        devPanelOverlay.style.display = 'flex';
        devPlayerInfo.style.display = 'none';
        devUserList.style.display = 'none';
        devSearchInput.value = '';
      } else {
        alert('Incorrect password!');
        devPasswordInput.value = '';
      }
    });

    devPasswordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        devPasswordSubmit.click();
      }
    });

    devPanelBack.addEventListener('click', () => {
      devPanelOverlay.style.display = 'none';
      settingsDiv.style.display = 'flex';
    });

    devSearchBtn.addEventListener('click', () => {
      const searchName = devSearchInput.value.trim();
      if (searchName.length === 0) {
        alert('Please enter a player name');
        return;
      }

      if (!database) {
        alert('Database not available');
        return;
      }

      database.ref('players').orderByChild('name').equalTo(searchName).once('value').then((snapshot) => {
        if (snapshot.exists()) {
          snapshot.forEach((child) => {
            devCurrentPlayerId = child.key;
            const data = child.val();
            devCurrentPlayerData = data;
            
            devPlayerName.textContent = data.name;
            devHighScore.value = data.highScore || 0;
            devAllTimeScore.value = data.allTimeScore || 0;
            devTotalGames.value = data.totalGames || 0;
            devTotalScore.value = data.totalScore || 0;
            devCoins.value = data.coins || 0;
            devDiamonds.value = data.diamonds || 0;
            
            // Show diamonds field if there's an active event
            if (currentEvent) {
              devDiamondsField.style.display = 'flex';
            } else {
              devDiamondsField.style.display = 'none';
            }
            
            devPlayerInfo.style.display = 'block';
            devWallpaperManager.style.display = 'none';
            devUserList.style.display = 'none';
          });
        } else {
          alert('Player not found!');
          devPlayerInfo.style.display = 'none';
        }
      });
    });
    
    devShowAllUsers.addEventListener('click', () => {
      if (!database) {
        alert('Database not available');
        return;
      }
      
      database.ref('players').once('value').then((snapshot) => {
        const users = [];
        snapshot.forEach((child) => {
          const playerData = child.val();
          // FIX: Filter out undefined or invalid player names
          if (playerData.name && playerData.name !== 'undefined' && playerData.name.trim() !== '') {
            users.push({
              id: child.key,
              name: playerData.name,
              highScore: playerData.highScore || 0
            });
          }
        });
        
        if (users.length === 0) {
          devUserListContent.innerHTML = '<p style="color:#ff9999;text-align:center">No users found</p>';
        } else {
          let html = '';
          users.forEach(user => {
            html += `<div class="dev-user-item" data-id="${user.id}">
              ${user.name} (High Score: ${user.highScore})
            </div>`;
          });
          devUserListContent.innerHTML = html;
          
          // Add click handlers
          document.querySelectorAll('.dev-user-item').forEach(item => {
            item.addEventListener('click', () => {
              const userId = item.getAttribute('data-id');
              loadPlayerInDevPanel(userId);
            });
          });
        }
        
        devUserList.style.display = 'block';
        devPlayerInfo.style.display = 'none';
      });
    });
    
    function loadPlayerInDevPanel(userId) {
      if (!database) return;
      
      database.ref('players/' + userId).once('value').then((snapshot) => {
        const data = snapshot.val();
        if (data) {
          devCurrentPlayerId = userId;
          devCurrentPlayerData = data;
          
          devPlayerName.textContent = data.name;
          devHighScore.value = data.highScore || 0;
          devAllTimeScore.value = data.allTimeScore || 0;
          devTotalGames.value = data.totalGames || 0;
          devTotalScore.value = data.totalScore || 0;
          devCoins.value = data.coins || 0;
          devDiamonds.value = data.diamonds || 0;
          
          // Show diamonds field if there's an active event
          if (currentEvent) {
            devDiamondsField.style.display = 'flex';
          } else {
            devDiamondsField.style.display = 'none';
          }
          
          devPlayerInfo.style.display = 'block';
          devWallpaperManager.style.display = 'none';
          devUserList.style.display = 'none';
        }
      });
    }

    window.updateDevField = function(field) {
      if (!devCurrentPlayerId || !database) return;
      
      const value = parseInt(document.getElementById('dev' + field.charAt(0).toUpperCase() + field.slice(1)).value);
      
      database.ref('players/' + devCurrentPlayerId).update({
        [field]: value,
        lastUpdated: Date.now()
      }).then(() => {
        // If updating current player, also update local storage
        if (devCurrentPlayerId === playerId) {
          if (field === 'coins') {
            playerCoins = value;
            localStorage.setItem(`brickBlaster_${playerId}_coins`, value.toString());
            coinsDisplay.textContent = value;
          } else if (field === 'diamonds') {
            playerDiamonds = value;
            localStorage.setItem(`brickBlaster_${playerId}_diamonds`, value.toString());
            diamondsDisplay.textContent = value;
          }
        }
        alert(`${field} updated successfully!`);
      });
    };

   window.giveAllWallpapers = function() {
  if (!devCurrentPlayerId || !database) return;
  
  if (confirm('Give all wallpapers to this player?')) {
    database.ref('players/' + devCurrentPlayerId).update({
      ownedWallpapers: wallpaperUrls, // Give gradient wallpapers
      lastUpdated: Date.now()
    }).then(() => {
      if (devCurrentPlayerId === playerId) {
        ownedWallpapers = wallpaperUrls;
        localStorage.setItem(`brickBlaster_${playerId}_ownedWallpapers`, JSON.stringify(wallpaperUrls));
      }
      alert('All wallpapers given!');
      devCurrentPlayerData.ownedWallpapers = wallpaperUrls;
    });
  }
};

    window.giveSelectedWallpapers = function() {
  if (!devCurrentPlayerId || !database) return;
  
  // Create a modal for selecting wallpapers
  const selectedWallpapers = [];
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
  `;
  
  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
    background: #1a1a1a;
    padding: 30px;
    border-radius: 10px;
    border: 2px solid #ff0000;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
  `;
  
  // Fix the wallpaper display in the modal
  modalContent.innerHTML = `
    <h2 style="color:#ff0000; margin-bottom:20px; text-align:center">Select Wallpapers to Give</h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
      ${wallpaperUrls.map((url, index) => {
        // Check if it's a gradient or image URL
        let backgroundStyle;
        if (url.includes('gradient')) {
          backgroundStyle = `background:${url}`;
        } else {
          backgroundStyle = `background-image:url('${url}')`;
        }
        
        return `
          <div class="wallpaper-select-item" style="height: 80px; border-radius: 8px; ${backgroundStyle}; background-size:cover; background-position:center; border: 2px solid #333; cursor: pointer; position: relative;" data-index="${index}">
            <div style="position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 5px; border-radius: 3px; font-size: 10px;">
              ${rareIndices.includes(index) ? 'RARE' : 'COMMON'}
            </div>
          </div>
        `;
      }).join('')}
    </div>
    <div style="display: flex; gap: 10px; justify-content: center;">
      <button id="confirmGiveSelected" style="background: #ff0000; color: white; border: 0; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Give Selected</button>
      <button id="cancelGiveSelected" style="background: #555; color: white; border: 0; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Cancel</button>
    </div>
  `;
  
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // Handle wallpaper selection
  const wallpaperItems = modalContent.querySelectorAll('.wallpaper-select-item');
  wallpaperItems.forEach(item => {
    item.addEventListener('click', () => {
      const index = parseInt(item.dataset.index);
      if (selectedWallpapers.includes(wallpaperUrls[index])) {
        // Remove if already selected
        const wpIndex = selectedWallpapers.indexOf(wallpaperUrls[index]);
        selectedWallpapers.splice(wpIndex, 1);
        item.style.borderColor = '#333';
      } else {
        // Add to selection
        selectedWallpapers.push(wallpaperUrls[index]);
        item.style.borderColor = '#ffd700';
      }
    });
  });
  
  // Handle confirm button
  modalContent.querySelector('#confirmGiveSelected').addEventListener('click', () => {
    if (selectedWallpapers.length === 0) {
      alert('Please select at least one wallpaper!');
      return;
    }
    
    database.ref('players/' + devCurrentPlayerId).once('value').then((snapshot) => {
      const data = snapshot.val();
      const currentWallpapers = data.ownedWallpapers || [];
      
      // Add selected wallpapers (allow duplicates)
      const newWallpapers = [...currentWallpapers, ...selectedWallpapers];
      
      database.ref('players/' + devCurrentPlayerId).update({
        ownedWallpapers: newWallpapers,
        lastUpdated: Date.now()
      }).then(() => {
        // If updating current player, also update local storage
        if (devCurrentPlayerId === playerId) {
          ownedWallpapers = newWallpapers;
          localStorage.setItem(`brickBlaster_${playerId}_ownedWallpapers`, JSON.stringify(newWallpapers));
        }
        alert(`Successfully gave ${selectedWallpapers.length} wallpapers!`);
        document.body.removeChild(modal);
        devCurrentPlayerData.ownedWallpapers = newWallpapers;
      });
    });
  });
  
  // Handle cancel button
  modalContent.querySelector('#cancelGiveSelected').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
};
    
    window.giveEventWallpapers = function() {
  if (!devCurrentPlayerId || !database) return;
  
  // Create a modal for selecting event wallpapers
  const selectedEvents = [];
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
  `;
  
  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
    background: #1a1a1a;
    padding: 30px;
    border-radius: 10px;
    border: 2px solid #ff0000;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
  `;
  
  modalContent.innerHTML = `
    <h2 style="color:#ff0000; margin-bottom:20px; text-align:center">Select Event Wallpapers to Give</h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px;">
      ${Object.entries(events).map(([eventKey, event]) => `
        <div class="event-wallpaper-select-item" style="height: 100px; border-radius: 8px; background-image:url('${event.wallpaper}'); background-size:cover; background-position:center; border: 2px solid #333; cursor: pointer; position: relative;" data-event="${eventKey}">
          <div style="position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 5px; border-radius: 3px; font-size: 10px; text-transform: uppercase;">
            ${event.name}
          </div>
        </div>
      `).join('')}
    </div>
    <div style="display: flex; gap: 10px; justify-content: center;">
      <button id="confirmGiveEvent" style="background: #ff0000; color: white; border: 0; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Give Selected</button>
      <button id="cancelGiveEvent" style="background: #555; color: white; border: 0; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Cancel</button>
    </div>
  `;
  
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // Handle event wallpaper selection
  const eventWallpaperItems = modalContent.querySelectorAll('.event-wallpaper-select-item');
  eventWallpaperItems.forEach(item => {
    item.addEventListener('click', () => {
      const eventName = item.dataset.event;
      if (selectedEvents.includes(eventName)) {
        // Remove if already selected
        const eventIndex = selectedEvents.indexOf(eventName);
        selectedEvents.splice(eventIndex, 1);
        item.style.borderColor = '#333';
      } else {
        // Add to selection
        selectedEvents.push(eventName);
        item.style.borderColor = '#ffd700';
      }
    });
  });
  
  // Handle confirm button
  modalContent.querySelector('#confirmGiveEvent').addEventListener('click', () => {
    if (selectedEvents.length === 0) {
      alert('Please select at least one event wallpaper!');
      return;
    }
    
    database.ref('players/' + devCurrentPlayerId).once('value').then((snapshot) => {
      const data = snapshot.val();
      const currentEventWallpapers = data.ownedEventWallpapers || [];
      
      // Add selected event wallpapers (avoid duplicates)
      const newEventWallpapers = [...currentEventWallpapers];
      selectedEvents.forEach(eventKey => {
        if (!newEventWallpapers.includes(eventKey)) {
          newEventWallpapers.push(eventKey);
        }
      });
      
      database.ref('players/' + devCurrentPlayerId).update({
        ownedEventWallpapers: newEventWallpapers,
        lastUpdated: Date.now()
      }).then(() => {
        // If updating current player, also update local storage
        if (devCurrentPlayerId === playerId) {
          ownedEventWallpapers = newEventWallpapers;
          localStorage.setItem(`brickBlaster_${playerId}_ownedEventWallpapers`, JSON.stringify(newEventWallpapers));
          
          // Update the shop display if it's open
          if (shopOverlay.style.display === 'flex') {
            renderEventWallpaperGrid();
            renderWallpaperGrid();
          }
        }
        alert(`Successfully gave ${selectedEvents.length} event wallpapers!`);
        document.body.removeChild(modal);
        devCurrentPlayerData.ownedEventWallpapers = newEventWallpapers;
      });
    });
  });
  
  // Handle cancel button
  modalContent.querySelector('#cancelGiveEvent').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
};
    window.removeWallpaperAtIndex = function(index) {
  if (!devCurrentPlayerId || !database) return;
  
  const playerWallpapers = devCurrentPlayerData.ownedWallpapers || [];
  
  if (confirm('Delete this wallpaper from player\'s collection?')) {
    playerWallpapers.splice(index, 1);
    
    database.ref('players/' + devCurrentPlayerId).update({
      ownedWallpapers: playerWallpapers,
      lastUpdated: Date.now()
    }).then(() => {
      // If updating current player, also update local storage
      if (devCurrentPlayerId === playerId) {
        ownedWallpapers = playerWallpapers;
        localStorage.setItem(`brickBlaster_${playerId}_ownedWallpapers`, JSON.stringify(playerWallpapers));
      }
      alert('Wallpaper deleted!');
      devCurrentPlayerData.ownedWallpapers = playerWallpapers;
      showWallpaperManager();
    });
  }
};
    window.deletePlayerAccount = function() {
  if (!devCurrentPlayerId || !database) return;
  
  const playerNameToDelete = devPlayerName.textContent;
  if (confirm(`Are you sure you want to PERMANENTLY DELETE the account of "${playerNameToDelete}"? This cannot be undone!`)) {
    
    // 1. Mark as deleted in Firebase (so player knows they're deleted)
    database.ref('deletedPlayers/' + devCurrentPlayerId).set(Date.now())
      .then(() => {
        // 2. Remove player-specific local storage data (CRITICAL FIX)
        localStorage.removeItem(`brickBlaster_${devCurrentPlayerId}_coins`);
        localStorage.removeItem(`brickBlaster_${devCurrentPlayerId}_diamonds`);
        localStorage.removeItem(`brickBlaster_${devCurrentPlayerId}_ownedWallpapers`);
        localStorage.removeItem(`brickBlaster_${devCurrentPlayerId}_ownedEventWallpapers`);
        localStorage.removeItem(`brickBlaster_${devCurrentPlayerId}_wallpaper`);
        
        // 3. Clean up local name registry
        const existingPlayers = JSON.parse(localStorage.getItem('brickBlasterAllPlayers') || '{}');
        delete existingPlayers[playerNameToDelete];
        localStorage.setItem('brickBlasterAllPlayers', JSON.stringify(existingPlayers));
        
        // 4. Then remove from main players list
        return database.ref('players/' + devCurrentPlayerId).remove();
      })
      .then(() => {
        alert('Account deleted successfully! Player data cleared from all storage.');
        
        devPlayerInfo.style.display = 'none';
        devSearchInput.value = '';
        devCurrentPlayerId = null;
      })
      .catch((error) => {
        alert('Deletion failed: ' + error.message);
      });
  }
};

    window.showWallpaperManager = function() {
  if (!devCurrentPlayerId || !database) return;
  
  const playerWallpapers = devCurrentPlayerData.ownedWallpapers || [];
  const playerEventWallpapers = devCurrentPlayerData.ownedEventWallpapers || [];
  
  if (playerWallpapers.length === 0 && playerEventWallpapers.length === 0) {
    alert('This player has no wallpapers!');
    return;
  }
  
  let html = '';
  
  // Regular wallpapers
  playerWallpapers.forEach((wp, index) => {
    const wpIndex = wallpaperUrls.indexOf(wp);
    const isRare = rareIndices.includes(wpIndex);
    const rareLabel = isRare ? '<div style="color:#ffd700;font-size:10px;text-align:center;margin-top:5px">RARE</div>' : '';
    
    // Check if it's a gradient or image URL
    let backgroundStyle;
    if (wp.includes('gradient')) {
      // It's a gradient - use background
      backgroundStyle = `background:${wp}`;
    } else {
      // It's an image - use background-image
      backgroundStyle = `background-image:url('${wp}')`;
    }
    
    html += `<div style="position:relative">
      <div style="height:70px;border-radius:5px;${backgroundStyle};background-size:cover;background-position:center;border:2px solid #ff0000"></div>
      ${rareLabel}
      <button onclick="removeWallpaperAtIndex(${index})" style="width:100%;margin-top:5px;background:#990000;color:#fff;border:0;padding:5px;border-radius:5px;cursor:pointer;font-size:11px">Delete</button>
    </div>`;
  });
  
  // Event wallpapers
  playerEventWallpapers.forEach((eventName, index) => {
    const wp = eventWallpapers[eventName];
    html += `<div style="position:relative">
      <div style="height:70px;border-radius:5px;background-image:url('${wp}');background-size:cover;background-position:center;border:2px solid #ffd700"></div>
      <div style="color:#ffd700;font-size:10px;text-align:center;margin-top:5px">${events[eventName].name.toUpperCase()}</div>
      <button onclick="removeEventWallpaperAtIndex(${index})" style="width:100%;margin-top:5px;background:#990000;color:#fff;border:0;padding:5px;border-radius:5px;cursor:pointer;font-size:11px">Delete</button>
    </div>`;
  });
  
  devWallpaperList.innerHTML = html;
  devWallpaperManager.style.display = 'block';
};
    
    window.removeEventWallpaperAtIndex = function(index) {
  if (!devCurrentPlayerId || !database) return;
  
  const playerEventWallpapers = devCurrentPlayerData.ownedEventWallpapers || [];
  
  if (confirm('Delete this event wallpaper from player\'s collection?')) {
    playerEventWallpapers.splice(index, 1);
    
    database.ref('players/' + devCurrentPlayerId).update({
      ownedEventWallpapers: playerEventWallpapers,
      lastUpdated: Date.now()
    }).then(() => {
      // If updating current player, also update local storage
      if (devCurrentPlayerId === playerId) {
        ownedEventWallpapers = playerEventWallpapers;
        localStorage.setItem(`brickBlaster_${playerId}_ownedEventWallpapers`, JSON.stringify(playerEventWallpapers));
      }
      alert('Event wallpaper deleted!');
      devCurrentPlayerData.ownedEventWallpapers = playerEventWallpapers;
      showWallpaperManager();
    });
  }
};

    window.hideWallpaperManager = function() {
      devWallpaperManager.style.display = 'none';
    };

    function cleanupDeletedPlayers() {
  if (!database) return;
  
  const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
  
  database.ref('deletedPlayers').once('value').then((snapshot) => {
    const updates = {};
    snapshot.forEach((child) => {
      if (child.val() < oneWeekAgo) {
        updates[child.key] = null; // Remove old records
      }
    });
    if (Object.keys(updates).length > 0) {
      database.ref('deletedPlayers').update(updates);
    }
  });
}

// Run cleanup occasionally (once per day)
setInterval(cleanupDeletedPlayers, 24 * 60 * 60 * 1000);

 function unlockAudio() {
  if (!audioContext) return;
  
  if (audioContext.state === 'suspended') {
    audioContext.resume().then(() => {
      console.log('Audio context unlocked');
    });
  }
}

// Add event listeners for user interaction
document.addEventListener('click', unlockAudio, { once: true });
document.addEventListener('keydown', unlockAudio, { once: true });
document.addEventListener('touchstart', unlockAudio, { once: true });

// Also unlock when game starts
startBtn.addEventListener('click', unlockAudio);   

  // --- FIXED: Initialize Game Properly ---
window.addEventListener('load', () => {
  // Initialize Firebase first
  initializeFirebase();
  
  // ======== ADD THESE TWO LINES RIGHT HERE ========
  preloadWallpaperImages(); // Your existing function
  preloadAndCacheWallpapers(); // The new function you just added
  // ======== END OF ADDED LINES ========
  
  // Then initialize the game
  setTimeout(() => {
    // Clean up duplicate names on load
    if (database) {
      database.ref('players').once('value').then((snapshot) => {
        const nameMap = {};
        const duplicates = [];
        
        snapshot.forEach((child) => {
          const data = child.val();
          const name = data.name;
          
          // FIX: Skip undefined or invalid player names
          if (!name || name === 'undefined' || name.trim() === '') {
            duplicates.push(child.key);
            return;
          }
          
          if (nameMap[name]) {
            // Duplicate found, keep the older one
            if (data.lastUpdated < nameMap[name].lastUpdated) {
              duplicates.push(nameMap[name].id);
              nameMap[name] = { id: child.key, lastUpdated: data.lastUpdated };
            } else {
              duplicates.push(child.key);
            }
          } else {
            nameMap[name] = { id: child.key, lastUpdated: data.lastUpdated };
          }
        });
        
        // Delete duplicates and invalid names
        duplicates.forEach(id => {
          database.ref('players/' + id).remove();
        });
      });
    }
    initializePlayer();
    setupEventToggle(); // ADD THIS LINE
  }, 500);
});
  </script>
  
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
</body>
</html>
