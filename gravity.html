<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Gravity Ball Multiplayer â€” Full Match Implementation</title>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { display:block; }
  #nameOverlay {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.95);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:20;
    color:white;
    flex-direction:column;
    gap:12px;
  }
  #nameInput {
    font-size:20px;
    padding:10px;
    border-radius:8px;
    border:none;
    outline:none;
  }
  #readyBtn {
    position:fixed;
    top:10px;
    left:10px;
    padding:10px 18px;
    font-size:16px;
    border-radius:8px;
    border:none;
    background:#00c853;
    color:black;
    cursor:pointer;
    z-index:5;
    display:block;
  }
  #readyBtn.hidden {
    display:none;
  }
</style>
</head>
<body>

<!-- Name entry -->
<div id="nameOverlay">
  <input id="nameInput" placeholder="Enter your name & press Enter">
  <div style="font-size:14px; color:#ccc;">Join & then press READY (top-left) to start match when all players are ready</div>
</div>

<canvas id="game"></canvas>
<button id="readyBtn">READY</button>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
/* ===========================================================
   FULL IMPLEMENTATION:
   - Lobby with READY/UNREADY (button in top-left, hidden during match)
   - All-ready => 3..2..1 countdown (center)
   - Synchronized match start using server timestamp (.info/serverTimeOffset)
   - 2 minute timer synced via server timestamp
   - 20 green orbs (radius 18) in Â±2000 area; stored in Firebase
   - Orb pickup uses a transaction to ensure single-winner
   - Orb respawn after 3s (spawn created by the client who successfully removed the orb)
   - Avoid orb spawn intersection with planets, black hole, other orbs
   - When players list becomes empty, the entire gravity/ node is removed
   - All match timestamps removed when players all disconnected (because gravity/ removed)
   - Minimap in top-right showing planets, black hole, and player
   - Live leaderboard below minimap during match
   - Enhanced ranking screen that only disappears for player who clicks REPLAY
   =========================================================== */

/* ---------------- FIREBASE CONFIG ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyAwEy-sJx7E61BA6VmBfIFMZsjuAj8RK5g",
  authDomain: "games-c3e27.firebaseapp.com",
  databaseURL: "https://games-c3e27-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "games-c3e27",
  storageBucket: "games-c3e27.firebasestorage.app",
  messagingSenderId: "193027632069",
  appId: "1:193027632069:web:b559c3b10011bc6982b9ac"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------------- CANVAS ---------------- */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize(); window.addEventListener('resize', resize);

/* ---------------- CONSTANTS ---------------- */
const G = 0.15;
const thrust = 0.1;
const MATCH_DURATION_MS = 120000; // 2 minutes
const ORB_COUNT = 20;
const ORB_RADIUS = 18;
const ORB_AREA = 2000; // spawn within Â±2000 x/y
const starSectorSize = 400;
const miniMap = { width:200, height:150, padding:10 };

/* ---------------- STATE ---------------- */
let serverOffset = 0; // ms (serverTime = Date.now() + serverOffset)
db.ref('.info/serverTimeOffset').on('value', snap=>{
  serverOffset = snap.val() || 0;
});
function serverNow(){ return Date.now() + serverOffset; }

let playerName = null;
let playerId = 'player_' + Math.random().toString(36).substr(2,8) + Date.now();
let playersData = {};
let planets = [], blackHole = null;
let orbs = {};
let match = { state: "lobby", duration: MATCH_DURATION_MS };
let isTabActive = true;
let hideRankingScreen = false;
/* ---------------- UI ELEMENTS ---------------- */
const nameOverlay = document.getElementById("nameOverlay");
const nameInput = document.getElementById("nameInput");
const readyBtn = document.getElementById("readyBtn");
const player = { x:0,y:0,vx:0,vy:0,angle:0,radius:8,name:"",ready:false,score:0 };
nameInput.focus();

/* ---------- NAME ENTRY HANDLER (ADD THIS) ---------- */
nameInput.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    const val = nameInput.value.trim();
    if (!val) return;

    playerName = val;
    nameOverlay.style.display = "none";

    // Initial spawn
    player.x = Math.random() * 200 - 100;
    player.y = Math.random() * 200 - 100;

    registerPresence();

    loadWorldThen(() => {
      startMainLoop();
    });
  }
});  

/* ---------------- INPUT ---------------- */
const keys = {};
window.addEventListener("keydown", e=> keys[e.key]=true);
window.addEventListener("keyup", e=> keys[e.key]=false);
document.addEventListener("visibilitychange", ()=>{ isTabActive = !document.hidden; });


/* ---------------- INITIAL WORLD GENERATION (if needed) ---------------- */
function generateWorldLocally(){
  const colors = ["orange","red","green","blue","purple","yellow","pink","cyan","lime","magenta"];
  planets = [];
  let attempts = 0;
  while(planets.length < 10 && attempts < 5000){
    attempts++;
    const radius = 30 + Math.random()*90;
    const x = Math.random()*3000 - 1500;
    const y = Math.random()*3000 - 1500;
    const color = colors[Math.floor(Math.random()*colors.length)];
    let ok = true;
    for(let p of planets){
      const dx=x-p.x, dy=y-p.y, dist=Math.hypot(dx,dy);
      if(dist < radius+p.radius+50){ ok=false; break; }
    }
    if(Math.hypot(x,y)<200) ok=false;
    if(ok) planets.push({x,y,radius,mass:Math.pow(radius,3)*0.07,color});
  }
  // Black Hole placed far away
  let ok=false;
  while(!ok){
    const x = Math.random()*6000 - 3000;
    const y = Math.random()*6000 - 3000;
    if(Math.hypot(x,y) > 4000){
      blackHole = {x,y,radius:100,mass:800000,color:"black",angle:0,particles:[]};
      for(let i=0;i<100;i++){
        blackHole.particles.push({r:blackHole.radius+Math.random()*150,angle:Math.random()*Math.PI*2,speed:0.002+Math.random()*0.004,size:1+Math.random()*2});
      }
      ok=true;
    }
  }
}

/* ---------------- LOAD OR CREATE WORLD ---------------- */
function loadWorldThen(callback){
  // If no world in firebase, first player will create it.
  db.ref('gravity/world').once('value').then(snap=>{
    const data = snap.val();
    if(data && data.planets && data.blackHole){
      planets = data.planets;
      blackHole = data.blackHole;
      callback();
    } else {
      // create world locally and save to firebase
      generateWorldLocally();
      db.ref('gravity/world').set({planets,blackHole,created: serverNow()})
        .then(()=>callback())
        .catch(()=>callback());
    }
  }).catch(err=>{
    // fallback: generate local
    generateWorldLocally();
    callback();
  });
}

/* ---------------- PRESENCE & CLEANUP ---------------- */
// Register player in players list and ensure removal on disconnect
const myRef = db.ref('gravity/players/' + playerId);
function registerPresence(){
  player.name = playerName;
  player.ready = false;
  player.score = 0;
  myRef.set({x:player.x,y:player.y,vx:player.vx,vy:player.vy,angle:player.angle,name:player.name,ready:false,score:0,lastUpdate:serverNow()});
  myRef.onDisconnect().remove();
  // Also, when this client disconnects, check & remove anything leftover if nobody remains.
  // NOTE: client-side cannot unconditionally guarantee deletion when all clients disconnect (no client to run code),
  // but we ensure that whenever any client sees players === null (no players), it removes gravity root.
}

/* ---------------- PLAYERS LISTENER ---------------- */
db.ref('gravity/players').on('value', snap=>{
  playersData = snap.val() || {};
  const ids = Object.keys(playersData);
  // If nobody left, remove entire gravity branch (this removes timers/timestamps/world/orbs)
  if(ids.length === 0){
    db.ref('gravity').remove().catch(()=>{});
  }
  // If match was running and new player joined, they'll see match state via 'gravity/match' listener below
  // Check if all players are ready (only if match in lobby)
  if(match.state === "lobby" && ids.length > 0){
    const allReady = ids.every(id => playersData[id].ready);
    if(allReady){
      startCountdownSequence();
    }
  }
});

/* ---------------- ORBS LISTENER ---------------- */
db.ref('gravity/orbs').on('value', snap=>{
  orbs = snap.val() || {};
});

/* ---------------- MATCH LISTENER ---------------- */
db.ref('gravity/match').on('value', snap=>{
  const m = snap.val();
  if(m){
    match = m;
  } else {
    match = { state:"lobby", duration: MATCH_DURATION_MS };
    hideRankingScreen = false; // Reset when match is cleared
  }
  updateReadyButtonVisibility();
});

/* ---------------- READY BUTTON ---------------- */
readyBtn.onclick = () => {
  player.ready = !player.ready;
  readyBtn.textContent = player.ready ? "UNREADY" : "READY";
  readyBtn.style.background = player.ready ? "#ff5252" : "#00c853";
  myRef.update({ ready: player.ready });
  // If toggling to unready while countdown started, we want to abort countdown if any player unready.
  // That will be handled because players listener checks allReady before starting any new countdown.
};

// Hide ready button during match
function updateReadyButtonVisibility(){
  if(match.state === "playing" || match.state === "ended"){
    readyBtn.classList.add('hidden');
  } else {
    readyBtn.classList.remove('hidden');
  }
}

/* ---------------- COUNTDOWN & MATCH START ---------------- */
let localCountdown = null;
function startCountdownSequence(){
  // Only one client should attempt to initiate countdown; use a transaction to claim countdown if not already claimed.
  // We'll set gravity/match/state = "countdown" with a server timestamp for 'countdownStartedBy'
  db.ref('gravity/match/state').transaction(current => {
    if(current === "lobby" || current === null) return "countdown";
    return; // abort
  }, (err, committed, snap) => {
    if(err) return;
    if(!committed) return; // someone else started it
    // start a 3-second countdown visible to all clients (we'll set no startTime yet)
    db.ref('gravity/match').update({
  countdownStartedAt: firebase.database.ServerValue.TIMESTAMP
});
    // The actual countdown display is client-side based on serverNow - countdownStartedAt
    // After countdown 3=>0, the starter will set the match startTime as server timestamp:
    runLocalCountdownThenStart();
  });
}

function runLocalCountdownThenStart(){
  // We'll read countdownStartedAt, then wait remaining time and start match
  db.ref('gravity/match/countdownStartedAt').once('value').then(snap=>{
    const startedAt = snap.val();
    if(!startedAt) return;
    const remaining = 3000 - (serverNow() - startedAt);
    setTimeout(()=> {
      // only one client should set the real match.startTime; use a transaction to set match.state to "playing" & startTime only if still "countdown"
      db.ref('gravity/match').transaction(current => {
        if(!current || current.state !== "countdown") return; // abort
        return Object.assign({}, current, { state: "playing", startTime: firebase.database.ServerValue.TIMESTAMP, duration: MATCH_DURATION_MS });
      });
      // spawn initial orbs (we let the client that succeeded in transaction spawn them)
      // The transaction callback will run and we can detect who committed by re-checking match state in listener.
    }, Math.max(0, remaining));
  });
}

/* ---------------- SPAWN ORBS (authoritative-ish) ---------------- */
function spawnInitialOrbsIfNeeded(){
  // Called after match starts. Only spawn if orbs node is empty.
  db.ref('gravity/orbs').once('value').then(snap=>{
    if(snap.exists()) return;
    for(let i=0;i<ORB_COUNT;i++){
      spawnSingleOrb();
    }
  });
}

function spawnSingleOrb(){
  // choose random location in Â±ORB_AREA that doesn't intersect planets, blackHole, or existing orbs
  db.ref('gravity/orbs').once('value').then(snap=>{
    const currentOrbs = snap.val() || {};
    let attempts = 0;
    while(attempts < 5000){
      attempts++;
      const x = Math.random()*ORB_AREA*2 - ORB_AREA;
      const y = Math.random()*ORB_AREA*2 - ORB_AREA;
      let ok = true;
      for(let id in currentOrbs){
        const o = currentOrbs[id];
        if(Math.hypot(x-o.x, y-o.y) < ORB_RADIUS*2 + 6){ ok=false; break; }
      }
      for(let p of planets){
        if(Math.hypot(x-p.x, y-p.y) < p.radius + ORB_RADIUS + 12){ ok=false; break; }
      }
      if(blackHole && Math.hypot(x-blackHole.x, y-blackHole.y) < blackHole.radius + ORB_RADIUS + 30) ok=false;
      if(ok){
        db.ref('gravity/orbs').push({x,y});
        return;
      }
    }
    // if unable to find after many attempts, skip
  });
}

/* ---------------- ORB PICKUP (atomic) ---------------- */
function tryPickupOrb(orbId){
  const orbRef = db.ref('gravity/orbs/' + orbId);
  // Transaction to remove orb only if it still exists (committed means this client won it)
  orbRef.transaction(current => {
    if(current === null) return; // someone else already removed
    return null; // delete it
  }, (err, committed, snap) => {
    if(err) return;
    if(committed){
      // this client successfully took the orb
      player.score = (player.score || 0) + 1;
      myRef.child('score').set(player.score);
      // spawn a replacement after 3s (this client will spawn)
      setTimeout(()=> spawnSingleOrb(), 3000);
    }
  });
}

/* ---------------- PHYSICS ---------------- */
function applyGravityAndCollisions(){
  // gravity from planets + blackHole (inside planet: linear r-proportional)
  for(let p of planets.concat(blackHole ? [blackHole] : [])){
    let dx = p.x - player.x;
    let dy = p.y - player.y;
    let dist = Math.hypot(dx,dy);
    if(dist < 0.1) dist = 0.1;
    const R = p.radius + player.radius;
    const nx = dx / dist, ny = dy / dist;
    const accel = dist > R ? G * p.mass / (dist*dist) : G * p.mass * dist / (R*R*R);
    player.vx += accel * nx;
    player.vy += accel * ny;
    if(dist < R && p !== blackHole){
      player.x = p.x - nx * R;
      player.y = p.y - ny * R;
      const vDotN = player.vx*nx + player.vy*ny;
      if(vDotN > 0){
        player.vx -= vDotN*nx;
        player.vy -= vDotN*ny;
      }
    }
  }
  // player-player simple separation
  for(let id in playersData){
    if(id === playerId) continue;
    const op = playersData[id];
    let dx = op.x - player.x, dy = op.y - player.y;
    let dist = Math.hypot(dx,dy);
    let minDist = player.radius + 8;
    if(dist < minDist && dist > 0){
      let nx = dx/dist, ny = dy/dist, overlap = minDist - dist;
      player.x -= nx * overlap * 0.5;
      player.y -= ny * overlap * 0.5;
    }
  }
}

/* ---------------- PLAYER UPDATE ---------------- */
function updatePlayerPhysicsAndSync(){
  if(!isTabActive) return;
  if(keys["ArrowLeft"]) player.angle -= 0.05;
  if(keys["ArrowRight"]) player.angle += 0.05;
  if(keys["ArrowUp"]){ player.vx += Math.cos(player.angle) * thrust; player.vy += Math.sin(player.angle) * thrust; }
  if(keys["m"]){ player.vx *= 0.98; player.vy *= 0.98; }
  applyGravityAndCollisions();
  player.x += player.vx;
  player.y += player.vy;
  // Sync to firebase (rate-limited)
  const now = Date.now();
  if(!updatePlayerPhysicsAndSync.lastSync || now - updatePlayerPhysicsAndSync.lastSync > 50){
    myRef.update({ x: player.x, y: player.y, vx: player.vx, vy: player.vy, angle: player.angle, lastUpdate: serverNow(), name: player.name });
    updatePlayerPhysicsAndSync.lastSync = now;
  }
}

/* ---------------- DRAW HELPERS ---------------- */
function drawStars(){
  const centerX = canvas.width/2, centerY = canvas.height/2;
  const startX = Math.floor((player.x - centerX)/starSectorSize)*starSectorSize;
  const startY = Math.floor((player.y - centerY)/starSectorSize)*starSectorSize;
  const endX = Math.floor((player.x + centerX)/starSectorSize)*starSectorSize;
  const endY = Math.floor((player.y + centerY)/starSectorSize)*starSectorSize;
  for(let sx = startX; sx <= endX; sx += starSectorSize){
    for(let sy = startY; sy <= endY; sy += starSectorSize){
      const seed = sx*73856093 ^ sy*19349663;
      const rand = mulberry32(seed);
      const starsInSector = 10 + Math.floor(rand()*15);
      for(let i=0;i<starsInSector;i++){
        const starX = sx + rand()*starSectorSize;
        const starY = sy + rand()*starSectorSize;
        const radius = 0.5 + rand()*1.5;
        const brightness = 0.2 + rand()*0.5;
        const screenX = starX - player.x + centerX;
        const screenY = starY - player.y + centerY;
        if(screenX>=0 && screenX<=canvas.width && screenY>=0 && screenY<=canvas.height){
          ctx.fillStyle=`rgba(255,255,255,${brightness})`;
          ctx.beginPath();
          ctx.arc(screenX,screenY,radius,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

function drawPlanetsAndBlackHole(){
  const centerX = canvas.width/2, centerY = canvas.height/2;
  for(let p of planets){
    const screenX = p.x - player.x + centerX;
    const screenY = p.y - player.y + centerY;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(screenX, screenY, p.radius, 0, Math.PI*2);
    ctx.fill();
  }
  if(blackHole){
    const bhX = blackHole.x - player.x + centerX;
    const bhY = blackHole.y - player.y + centerY;
    blackHole.angle += 0.005;
    for(let i=0;i<5;i++){
      ctx.strokeStyle = `rgba(150,0,200,${0.1-i*0.015})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(bhX,bhY,blackHole.radius*(1.2+i*0.3),blackHole.angle,blackHole.angle+Math.PI*1.5);
      ctx.stroke();
    }
    const gradient = ctx.createRadialGradient(bhX,bhY,blackHole.radius*0.5,bhX,bhY,blackHole.radius*3);
    gradient.addColorStop(0,"rgba(0,0,0,1)");
    gradient.addColorStop(0.3,"rgba(50,0,50,0.3)");
    gradient.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(bhX,bhY,blackHole.radius*3,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = blackHole.color;
    ctx.beginPath();
    ctx.arc(bhX,bhY,blackHole.radius,0,Math.PI*2);
    ctx.fill();
    for(let p of blackHole.particles){
      p.angle += p.speed;
      const px = bhX + Math.cos(p.angle)*p.r;
      const py = bhY + Math.sin(p.angle)*p.r;
      ctx.fillStyle = `rgba(200,50,250,0.3)`;
      ctx.beginPath();
      ctx.arc(px,py,p.size,0,Math.PI*2);
      ctx.fill();
    }
  }
}

function drawPlayers(){
  const centerX = canvas.width/2, centerY = canvas.height/2;
  for(let id in playersData){
    if(id === playerId) continue;
    const pl = playersData[id];
    const px = pl.x - player.x + centerX;
    const py = pl.y - player.y + centerY;
    ctx.save();
    ctx.translate(px,py);
    ctx.rotate(pl.angle || 0);
    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.arc(0,0,player.radius,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="cyan";
    ctx.beginPath();
    ctx.moveTo(0,0); ctx.lineTo(15,0); ctx.stroke();
    ctx.restore();
    ctx.fillStyle="white";
    ctx.font="14px Arial";
    ctx.textAlign="center";
    ctx.fillText(pl.name || "Anon", px, py - player.radius - 10);
  }
  // draw self
  const px = canvas.width/2, py = canvas.height/2;
  ctx.save();
  ctx.translate(px,py);
  ctx.rotate(player.angle);
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(0,0,player.radius,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle="cyan";
  ctx.beginPath();
  ctx.moveTo(0,0); ctx.lineTo(15,0); ctx.stroke();
  ctx.restore();
}

function drawOrbs(){
  const centerX = canvas.width/2, centerY = canvas.height/2;
  for(let id in orbs){
    const o = orbs[id];
    const sx = o.x - player.x + centerX;
    const sy = o.y - player.y + centerY;
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.arc(sx, sy, ORB_RADIUS, 0, Math.PI*2);
    ctx.fill();
  }
}

/* ---------------- MINI-MAP ---------------- */
function drawMiniMap(){
  const mapX=canvas.width-miniMap.width-miniMap.padding;
  const mapY=miniMap.padding;
  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(mapX,mapY,miniMap.width,miniMap.height);
  ctx.strokeStyle="white";
  ctx.strokeRect(mapX,mapY,miniMap.width,miniMap.height);

  let maxDist=0;
  for(let p of planets.concat([blackHole])){
    const d=Math.sqrt((p.x-player.x)**2+(p.y-player.y)**2)+p.radius;
    if(d>maxDist) maxDist=d;
  }
  if(maxDist<200) maxDist=200;
  const scale=(miniMap.width/2)/maxDist;

  // Draw planets
  for(let p of planets){
    const dx=p.x-player.x;
    const dy=p.y-player.y;
    const px=mapX+miniMap.width/2+dx*scale;
    const py=mapY+miniMap.height/2+dy*scale;
    const r=Math.max(2,p.radius*scale);
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(px,py,r,0,Math.PI*2);
    ctx.fill();
  }

  // Black hole on map (barely visible)
  const dx=blackHole.x-player.x;
  const dy=blackHole.y-player.y;
  const px=mapX+miniMap.width/2+dx*scale;
  const py=mapY+miniMap.height/2+dy*scale;
  const r=Math.max(2,blackHole.radius*scale);
  ctx.fillStyle="rgba(180,180,180,0.15)";
  ctx.beginPath();
  ctx.arc(px,py,r,0,Math.PI*2);
  ctx.fill();

  // Player
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(mapX+miniMap.width/2,mapY+miniMap.height/2,4,0,Math.PI*2);
  ctx.fill();
}

function startMainLoop(){
  requestAnimationFrame(loop);
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  drawStars();
  drawPlanetsAndBlackHole();
  drawOrbs();
  drawPlayers();
  drawMiniMap();
  drawLiveLeaderboard();
  drawHUD();

  if (match.state === "playing") {
    updatePlayerPhysicsAndSync();

    // Orb pickup check
    for (let id in orbs) {
      const o = orbs[id];
      if (Math.hypot(player.x - o.x, player.y - o.y) < player.radius + ORB_RADIUS) {
        tryPickupOrb(id);
      }
    }
  }

  // Spawn orbs when match starts
  if (match.state === "playing") {
    spawnInitialOrbsIfNeeded();
  }

  requestAnimationFrame(loop);
}

/* ---------------- LIVE LEADERBOARD ---------------- */
function drawLiveLeaderboard(){
  if(match.state !== "playing") return;
  
  const mapX=canvas.width-miniMap.width-miniMap.padding;
  const mapY=miniMap.padding + miniMap.height + 10;
  const boardHeight = 200;
  
  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(mapX,mapY,miniMap.width,boardHeight);
  ctx.strokeStyle="white";
  ctx.strokeRect(mapX,mapY,miniMap.width,boardHeight);
  
  ctx.fillStyle="white";
  ctx.font="14px Arial";
  ctx.textAlign="center";
  ctx.fillText("LEADERBOARD", mapX + miniMap.width/2, mapY + 20);
  
  const list = Object.values(playersData || {}).slice().sort((a,b)=> (b.score||0) - (a.score||0));
  ctx.font="12px Arial";
  ctx.textAlign="left";
  for(let i=0;i<Math.min(list.length, 8);i++){
    const p = list[i];
    const yPos = mapY + 40 + i*20;
    ctx.fillText(`${i+1}. ${(p.name || 'Anon').substring(0,12)}`, mapX + 10, yPos);
    ctx.textAlign="right";
    ctx.fillText(`${p.score||0}`, mapX + miniMap.width - 10, yPos);
    ctx.textAlign="left";
  }
}

/* ---------------- HUD: countdown/time/score ---------------- */
function drawHUD(){
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  if(match.state === "countdown"){
    // display 3..2..1 based on countdownStartedAt server timestamp
    const started = match.countdownStartedAt || 0;
    const elapsed = serverNow() - started;
    const remaining = Math.max(0, 3000 - elapsed);
    const number = Math.ceil(remaining/1000);
    ctx.font = "96px Arial";
    ctx.fillText(number || 1, canvas.width/2, canvas.height/2);
  }
  if(match.state === "playing"){
    // compute remaining time via server-aligned clock
    const startTime = match.startTime || 0;
    const duration = match.duration || MATCH_DURATION_MS;
    const elapsed = serverNow() - startTime;
    const remaining = Math.max(0, Math.ceil((duration - elapsed)/1000));
    ctx.font = "20px Arial";
    ctx.fillText(`Time: ${remaining}s   Score: ${player.score || 0}`, canvas.width/2, 30);
    if(remaining <= 0){
      // end match (use transaction to set ended)
      db.ref('gravity/match/state').transaction(current=>{
        if(current === "playing") return "ended";
        return;
      });
    }
  }
  if(match.state === "ended" && !hideRankingScreen){
    // Semi-transparent background
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Title with gradient
    const gradient = ctx.createLinearGradient(0, 50, 0, 120);
    gradient.addColorStop(0, "#FFD700");
    gradient.addColorStop(1, "#FFA500");
    ctx.fillStyle = gradient;
    ctx.font = "bold 48px Arial";
    ctx.fillText("MATCH ENDED", canvas.width/2, 100);
    
    // Trophy icon (simple)
    ctx.fillStyle = "#FFD700";
    ctx.font = "64px Arial";
    ctx.fillText("ðŸ†", canvas.width/2, 180);
    
    // Rankings box
    const boxWidth = 400;
    const boxHeight = 60 + Math.min(Object.keys(playersData).length, 10) * 50;
    const boxX = canvas.width/2 - boxWidth/2;
    const boxY = 220;
    
    ctx.fillStyle = "rgba(30,30,30,0.9)";
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 3;
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
    
    // Rankings
    const list = Object.values(playersData || {}).slice().sort((a,b)=> (b.score||0) - (a.score||0));
    ctx.textAlign = "left";
    for(let i=0;i<Math.min(list.length, 10);i++){
      const p = list[i];
      const yPos = boxY + 45 + i*50;
      
      // Medal for top 3
      let medal = "";
      if(i === 0) medal = "ðŸ¥‡";
      else if(i === 1) medal = "ðŸ¥ˆ";
      else if(i === 2) medal = "ðŸ¥‰";
      
      ctx.font = "24px Arial";
      ctx.fillStyle = i < 3 ? "#FFD700" : "white";
      ctx.fillText(`${medal} ${i+1}.`, boxX + 20, yPos);
      
      ctx.font = "22px Arial";
      ctx.fillStyle = "white";
      ctx.fillText(p.name || 'Anon', boxX + 80, yPos);
      
      ctx.textAlign = "right";
      ctx.fillStyle = "#00FF00";
      ctx.font = "bold 22px Arial";
      ctx.fillText(`${p.score||0}`, boxX + boxWidth - 20, yPos);
      ctx.textAlign = "left";
    }
    
    // Replay button
    const bx = canvas.width/2 - 100, by = boxY + boxHeight + 40, bw = 200, bh = 60;
    ctx.fillStyle = "#00c853";
    ctx.shadowColor = "rgba(0,200,83,0.5)";
    ctx.shadowBlur = 20;
    ctx.fillRect(bx, by, bw, bh);
    ctx.shadowBlur = 0;
    
    ctx.fillStyle = "black";
    ctx.font = "bold 24px Arial";
    ctx.textAlign = "center";
    ctx.fillText("REPLAY", canvas.width/2, by + 40);
  }
}
