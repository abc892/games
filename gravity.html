<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Ball Multiplayer - Match Mode</title>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { display:block; }
  #nameOverlay {
    position:fixed;
    inset:0;
    background:black;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:10;
  }
  #nameInput {
    font-size:20px;
    padding:10px;
    border-radius:8px;
    border:none;
    outline:none;
  }
  #readyButton {
    position:fixed;
    top:20px;
    right:20px;
    padding:10px 20px;
    background:#4CAF50;
    color:white;
    border:none;
    border-radius:5px;
    cursor:pointer;
    font-size:16px;
    z-index:5;
  }
  #readyButton.unready {
    background:#f44336;
  }
  #countdownOverlay {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.8);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:15;
    font-size:100px;
    color:white;
    font-weight:bold;
  }
  #timer {
    position:fixed;
    top:20px;
    center:0;
    transform:translateX(-50%);
    font-size:32px;
    color:white;
    font-weight:bold;
    z-index:5;
    text-align:center;
  }
  #score {
    position:fixed;
    top:60px;
    center:0;
    transform:translateX(-50%);
    font-size:24px;
    color:#4CAF50;
    font-weight:bold;
    z-index:5;
    text-align:center;
  }
  #leaderboardOverlay {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.9);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:20;
    flex-direction:column;
    color:white;
    font-family:Arial, sans-serif;
  }
  #leaderboardTitle {
    font-size:48px;
    margin-bottom:40px;
    color:#4CAF50;
  }
  #leaderboardList {
    font-size:24px;
    margin-bottom:40px;
    text-align:center;
  }
  .leaderboardEntry {
    margin:10px 0;
    padding:10px 20px;
    background:rgba(255,255,255,0.1);
    border-radius:5px;
  }
  #replayButton {
    padding:15px 30px;
    font-size:20px;
    background:#2196F3;
    color:white;
    border:none;
    border-radius:8px;
    cursor:pointer;
  }
  #matchStatus {
    position:fixed;
    top:20px;
    left:20px;
    color:white;
    font-size:18px;
    z-index:5;
    background:rgba(0,0,0,0.5);
    padding:10px;
    border-radius:5px;
  }
</style>
</head>
<body>

<!-- Name entry -->
<div id="nameOverlay">
  <input id="nameInput" placeholder="Enter your name & press Enter">
</div>

<!-- Match UI -->
<button id="readyButton" onclick="toggleReady()">Ready</button>
<div id="matchStatus">Waiting for players...</div>
<div id="countdownOverlay"></div>
<div id="timer"></div>
<div id="score"></div>

<!-- Leaderboard -->
<div id="leaderboardOverlay">
  <div id="leaderboardTitle">MATCH RESULTS</div>
  <div id="leaderboardList"></div>
  <button id="replayButton" onclick="resetGame()">Play Again</button>
</div>

<canvas id="game"></canvas>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyAwEy-sJx7E61BA6VmBfIFMZsjuAj8RK5g",
  authDomain: "games-c3e27.firebaseapp.com",
  databaseURL: "https://games-c3e27-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "games-c3e27",
  storageBucket: "games-c3e27.firebasestorage.app",
  messagingSenderId: "193027632069",
  appId: "1:193027632069:web:b559c3b10011bc6982b9ac"
};
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// --- Variables ---
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const G = 0.15, thrust = 0.1, keys = {};
const miniMap = { width:200, height:150, padding:10 };
const starSectorSize = 400;
const ORB_COUNT = 20;
const MATCH_DURATION = 120; // 2 minutes in seconds
const ORB_RESPAWN_TIME = 3000; // 3 seconds

let playerName = null;
let playerId = 'player_' + Math.random().toString(36).substr(2,8) + Date.now();
let playersData = {};
let planets = [], blackHole = null;
let isTabActive = true;
let lastUpdateTime = Date.now();

// Match state variables
let orbs = [];
let matchState = 'waiting'; // waiting, countdown, running, ended
let countdownValue = 0;
let matchTime = MATCH_DURATION;
let myScore = 0;
let amIReady = false;
let allPlayersReady = false;

// --- DOM Elements ---
const nameOverlay = document.getElementById("nameOverlay");
const nameInput = document.getElementById("nameInput");
const readyButton = document.getElementById("readyButton");
const countdownOverlay = document.getElementById("countdownOverlay");
const timer = document.getElementById("timer");
const score = document.getElementById("score");
const leaderboardOverlay = document.getElementById("leaderboardOverlay");
const leaderboardList = document.getElementById("leaderboardList");
const matchStatus = document.getElementById("matchStatus");

// --- Name entry ---
nameInput.focus();
nameInput.addEventListener("keydown", e => {
  if(e.key === "Enter" && nameInput.value.trim()){
    playerName = nameInput.value.trim();
    nameOverlay.remove();
    startGame();
  }
});

// --- Utility ---
function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return ((t^t>>>14)>>>0)/4294967296;}}

function getDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

// --- Generate world if first player ---
function generateWorld(){
  planets = [];
  const colors = ["orange","red","green","blue","purple","yellow","pink","cyan","lime","magenta"];
  let attempts = 0;
  while(planets.length < 10 && attempts < 5000){
    attempts++;
    const radius = 30 + Math.random()*90;
    const x = Math.random()*3000 - 1500;
    const y = Math.random()*3000 - 1500;
    const color = colors[Math.floor(Math.random()*colors.length)];
    let ok = true;
    for(let p of planets){
      const dx=x-p.x, dy=y-p.y, dist=Math.sqrt(dx*dx+dy*dy);
      if(dist < radius+p.radius+50){ ok=false; break; }
    }
    if(Math.sqrt(x*x+y*y)<200) ok=false;
    if(ok) planets.push({x,y,radius,mass:Math.pow(radius,3)*0.07,color});
  }

  let ok=false;
  while(!ok){
    const x = Math.random()*6000 - 3000;
    const y = Math.random()*6000 - 3000;
    if(Math.sqrt(x*x+y*y) > 4000){
      blackHole = {x,y,radius:100,mass:800000,color:"black",angle:0,particles:[]};
      for(let i=0;i<100;i++){
        blackHole.particles.push({r:blackHole.radius+Math.random()*150,angle:Math.random()*Math.PI*2,speed:0.002+Math.random()*0.004,size:1+Math.random()*2});
      }
      ok=true;
    }
  }

  database.ref('gravity/world').set({planets,blackHole,created:Date.now()});
}

// --- Generate Orbs ---
function generateOrbs() {
  orbs = [];
  const orbArea = 2000; // Area within which orbs spawn
  const minDistance = 50; // Minimum distance between orbs and other objects
  
  for(let i = 0; i < ORB_COUNT; i++) {
    let attempts = 0;
    let orbPlaced = false;
    
    while(!orbPlaced && attempts < 1000) {
      attempts++;
      const x = Math.random() * orbArea - orbArea/2;
      const y = Math.random() * orbArea - orbArea/2;
      
      // Check distance from planets
      let tooClose = false;
      for(let planet of planets) {
        if(getDistance(x, y, planet.x, planet.y) < planet.radius + minDistance) {
          tooClose = true;
          break;
        }
      }
      
      // Check distance from black hole
      if(getDistance(x, y, blackHole.x, blackHole.y) < blackHole.radius + minDistance) {
        tooClose = true;
      }
      
      // Check distance from other orbs
      for(let orb of orbs) {
        if(getDistance(x, y, orb.x, orb.y) < minDistance) {
          tooClose = true;
          break;
        }
      }
      
      if(!tooClose) {
        orbs.push({
          id: 'orb_' + i + '_' + Date.now(),
          x: x,
          y: y,
          radius: 18,
          color: '#4CAF50',
          active: true,
          collectedBy: null
        });
        orbPlaced = true;
      }
    }
  }
  
  // Save orbs to Firebase
  database.ref('gravity/orbs').set(orbs);
}

// --- Respawn Orb ---
function respawnOrb(orbId) {
  setTimeout(() => {
    const orbArea = 2000;
    const minDistance = 50;
    let attempts = 0;
    let orbPlaced = false;
    
    while(!orbPlaced && attempts < 1000) {
      attempts++;
      const x = Math.random() * orbArea - orbArea/2;
      const y = Math.random() * orbArea - orbArea/2;
      
      let tooClose = false;
      for(let planet of planets) {
        if(getDistance(x, y, planet.x, planet.y) < planet.radius + minDistance) {
          tooClose = true;
          break;
        }
      }
      
      if(getDistance(x, y, blackHole.x, blackHole.y) < blackHole.radius + minDistance) {
        tooClose = true;
      }
      
      for(let orb of orbs) {
        if(orb.active && getDistance(x, y, orb.x, orb.y) < minDistance) {
          tooClose = true;
          break;
        }
      }
      
      if(!tooClose) {
        database.ref('gravity/orbs/' + orbId).update({
          x: x,
          y: y,
          active: true,
          collectedBy: null
        });
        orbPlaced = true;
      }
    }
  }, ORB_RESPAWN_TIME);
}

// --- Load world ---
function loadWorld(callback){
  database.ref('gravity/players').once('value', playersSnapshot => {
    const activePlayers = playersSnapshot.val();
    const hasActivePlayers = activePlayers && Object.keys(activePlayers).length > 0;
    
    if(!hasActivePlayers){
      generateWorld();
      callback();
    } else {
      database.ref('gravity/world').once('value', snapshot => {
        const data = snapshot.val();
        if(data){
          planets = data.planets;
          blackHole = data.blackHole;
          callback();
        } else {
          generateWorld();
          callback();
        }
      });
    }
  });
}

// --- Player ---
const player = {x:0,y:0,vx:0,vy:0,angle:0,radius:8,name:"",score:0,ready:false};

function toggleReady() {
  amIReady = !amIReady;
  player.ready = amIReady;
  
  if(amIReady) {
    readyButton.textContent = "Unready";
    readyButton.classList.add("unready");
  } else {
    readyButton.textContent = "Ready";
    readyButton.classList.remove("unready");
  }
  
  // Update Firebase
  database.ref('gravity/players/' + playerId).update({ready: player.ready});
}

function checkAllPlayersReady() {
  if(!playersData || Object.keys(playersData).length < 2) return false;
  
  for(let id in playersData) {
    if(!playersData[id].ready) {
      return false;
    }
  }
  return true;
}

function startMatch() {
  matchState = 'countdown';
  countdownValue = 3;
  countdownOverlay.style.display = 'flex';
  countdownOverlay.textContent = countdownValue;
  
  // Start countdown
  const countdownInterval = setInterval(() => {
    countdownValue--;
    if(countdownValue > 0) {
      countdownOverlay.textContent = countdownValue;
    } else if(countdownValue === 0) {
      countdownOverlay.textContent = "GO!";
    } else {
      clearInterval(countdownInterval);
      countdownOverlay.style.display = 'none';
      matchState = 'running';
      matchTime = MATCH_DURATION;
      myScore = 0;
      player.score = 0;
      score.textContent = "Score: 0";
      
      // Reset all players' scores
      for(let id in playersData) {
        database.ref('gravity/players/' + id).update({score: 0});
      }
      
      // Generate orbs
      generateOrbs();
      
      // Start match timer
      startMatchTimer();
    }
  }, 1000);
}

function startMatchTimer() {
  const timerInterval = setInterval(() => {
    if(matchState !== 'running') {
      clearInterval(timerInterval);
      return;
    }
    
    matchTime--;
    const minutes = Math.floor(matchTime / 60);
    const seconds = matchTime % 60;
    timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    if(matchTime <= 0) {
      clearInterval(timerInterval);
      endMatch();
    }
  }, 1000);
}

function endMatch() {
  matchState = 'ended';
  
  // Calculate rankings
  const playersArray = [];
  for(let id in playersData) {
    if(playersData[id].name) {
      playersArray.push({
        id: id,
        name: playersData[id].name,
        score: playersData[id].score || 0
      });
    }
  }
  
  // Sort by score (descending)
  playersArray.sort((a, b) => b.score - a.score);
  
  // Display leaderboard
  leaderboardList.innerHTML = '';
  playersArray.forEach((playerData, index) => {
    const entry = document.createElement('div');
    entry.className = 'leaderboardEntry';
    entry.innerHTML = `${index + 1}. ${playerData.name} - ${playerData.score} points`;
    if(playerData.id === playerId) {
      entry.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
    }
    leaderboardList.appendChild(entry);
  });
  
  leaderboardOverlay.style.display = 'flex';
}

function resetGame() {
  leaderboardOverlay.style.display = 'none';
  matchState = 'waiting';
  player.ready = false;
  amIReady = false;
  readyButton.textContent = "Ready";
  readyButton.classList.remove("unready");
  myScore = 0;
  player.score = 0;
  score.textContent = "";
  timer.textContent = "";
  matchStatus.textContent = "Waiting for players...";
  
  // Update Firebase
  database.ref('gravity/players/' + playerId).update({ready: false, score: 0});
  
  // Clear orbs
  database.ref('gravity/orbs').remove();
}

function startGame(){
  player.x = 0;
  player.y = 0;
  player.name = playerName;
  player.ready = false;
  player.score = 0;

  loadWorld(()=>{
    const myRef = database.ref('gravity/players/' + playerId);
    myRef.set(player);
    myRef.onDisconnect().remove();
    
    // Listen for other players
    database.ref('gravity/players').on('value', snapshot=>{
      playersData = snapshot.val() || {};
      
      // Update match status
      const playerCount = Object.keys(playersData).length;
      matchStatus.textContent = `Players: ${playerCount} | Ready: ${Object.values(playersData).filter(p => p.ready).length}`;
      
      // Check if all players are ready
      if(playerCount >= 2 && checkAllPlayersReady() && matchState === 'waiting') {
        startMatch();
      }
    });
    
    // Listen for orbs
    database.ref('gravity/orbs').on('value', snapshot=>{
      const orbsData = snapshot.val();
      if(orbsData) {
        orbs = Object.values(orbsData);
      } else {
        orbs = [];
      }
    });
    
    // Listen for match state
    database.ref('gravity/matchState').on('value', snapshot=>{
      const state = snapshot.val();
      if(state === 'running' && matchState !== 'running') {
        // Another player started the match
        matchState = 'running';
        countdownOverlay.style.display = 'none';
      }
    });

    // Update loop
    setInterval(()=>{
      if(isTabActive){
        myRef.update({
          x:player.x,
          y:player.y,
          vx:player.vx,
          vy:player.vy,
          angle:player.angle,
          score:player.score,
          ready:player.ready,
          lastUpdate:Date.now()
        });
      }
    },50);

    // Start game loop
    requestAnimationFrame(loop);
  });
}

// --- Input ---
window.addEventListener("keydown", e=>keys[e.key]=true);
window.addEventListener("keyup", e=>keys[e.key]=false);

// --- Tab visibility handling ---
document.addEventListener("visibilitychange", () => {
  isTabActive = !document.hidden;
  if(isTabActive){
    lastUpdateTime = Date.now();
  }
});

// --- Physics ---
function applyGravity(){
  for(let p of planets.concat([blackHole])){
    let dx = p.x - player.x;
    let dy = p.y - player.y;
    let dist = Math.sqrt(dx*dx + dy*dy); if(dist<0.1) dist=0.1;
    const R=p.radius+player.radius;
    const nx=dx/dist, ny=dy/dist;
    const accel=dist>R? G*p.mass/(dist*dist) : G*p.mass*dist/(R*R*R);
    player.vx += accel*nx; player.vy += accel*ny;
    if(dist<R && p!==blackHole){
      player.x = p.x - nx*R; player.y = p.y - ny*R;
      const vDotN = player.vx*nx + player.vy*ny;
      if(vDotN>0){ player.vx-=vDotN*nx; player.vy-=vDotN*ny; }
    }
  }

  // Player collision
  for(let id in playersData){
    if(id===playerId) continue;
    const op=playersData[id];
    let dx=op.x-player.x, dy=op.y-player.y;
    let dist=Math.sqrt(dx*dx+dy*dy);
    let minDist=player.radius+8;
    if(dist<minDist && dist>0){
      let nx=dx/dist, ny=dy/dist, overlap=minDist-dist;
      player.x-=nx*overlap*0.5;
      player.y-=ny*overlap*0.5;
    }
  }
  
  // Orb collection (only during match)
  if(matchState === 'running') {
    for(let orb of orbs) {
      if(orb.active) {
        const dx = orb.x - player.x;
        const dy = orb.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist < player.radius + orb.radius) {
          // Collect orb
          myScore++;
          player.score = myScore;
          score.textContent = `Score: ${myScore}`;
          
          // Update orb in Firebase
          database.ref('gravity/orbs/' + orb.id).update({
            active: false,
            collectedBy: playerId
          });
          
          // Respawn orb after delay
          respawnOrb(orb.id);
          
          // Update player score in Firebase
          database.ref('gravity/players/' + playerId).update({score: player.score});
        }
      }
    }
  }
}

function updatePlayer(){
  if(!isTabActive) return;
  
  if(keys["ArrowLeft"]) player.angle-=0.05;
  if(keys["ArrowRight"]) player.angle+=0.05;
  if(keys["ArrowUp"]){ player.vx+=Math.cos(player.angle)*thrust; player.vy+=Math.sin(player.angle)*thrust; }
  if(keys["m"]){ player.vx*=0.98; player.vy*=0.98; }
  applyGravity();
  player.x+=player.vx; player.y+=player.vy;
}

// --- Draw ---
function drawStars(){
  const centerX=canvas.width/2, centerY=canvas.height/2;
  const startX=Math.floor((player.x-centerX)/starSectorSize)*starSectorSize;
  const startY=Math.floor((player.y-centerY)/starSectorSize)*starSectorSize;
  const endX=Math.floor((player.x+centerX)/starSectorSize)*starSectorSize;
  const endY=Math.floor((player.y+centerY)/starSectorSize)*starSectorSize;
  for(let sx=startX;sx<=endX;sx+=starSectorSize){
    for(let sy=startY;sy<=endY;sy+=starSectorSize){
      const seed = sx*73856093 ^ sy*19349663;
      const rand = mulberry32(seed);
      const starsInSector = 10 + Math.floor(rand()*15);
      for(let i=0;i<starsInSector;i++){
        const starX = sx + rand()*starSectorSize;
        const starY = sy + rand()*starSectorSize;
        const radius = 0.5 + rand()*1.5;
        const brightness = 0.2 + rand()*0.5;
        const screenX = starX - player.x + centerX;
        const screenY = starY - player.y + centerY;
        if(screenX>=0 && screenX<=canvas.width && screenY>=0 && screenY<=canvas.height){
          ctx.fillStyle=`rgba(255,255,255,${brightness})`;
          ctx.beginPath();
          ctx.arc(screenX,screenY,radius,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

function drawOrbs() {
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  
  for(let orb of orbs) {
    if(orb.active) {
      const screenX = orb.x - player.x + centerX;
      const screenY = orb.y - player.y + centerY;
      
      // Draw glowing effect
      const gradient = ctx.createRadialGradient(
        screenX, screenY, 0,
        screenX, screenY, orb.radius * 1.5
      );
      gradient.addColorStop(0, 'rgba(76, 175, 80, 0.8)');
      gradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(screenX, screenY, orb.radius * 1.5, 0, Math.PI*2);
      ctx.fill();
      
      // Draw orb
      ctx.fillStyle = orb.color;
      ctx.beginPath();
      ctx.arc(screenX, screenY, orb.radius, 0, Math.PI*2);
      ctx.fill();
      
      // Draw inner glow
      const innerGradient = ctx.createRadialGradient(
        screenX, screenY, 0,
        screenX, screenY, orb.radius
      );
      innerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      innerGradient.addColorStop(0.7, 'rgba(76, 175, 80, 0.5)');
      innerGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
      
      ctx.fillStyle = innerGradient;
      ctx.beginPath();
      ctx.arc(screenX, screenY, orb.radius, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

function drawPlayer(pl){
  const centerX=canvas.width/2, centerY=canvas.height/2;
  const px = (pl===player)? centerX : pl.x-player.x+centerX;
  const py = (pl===player)? centerY : pl.y-player.y+centerY;
  
  // Skip if player is off screen
  if(px < -50 || px > canvas.width + 50 || py < -50 || py > canvas.height + 50) return;
  
  ctx.save();
  ctx.translate(px,py);
  ctx.rotate(pl.angle);
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(0,0,player.radius,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle="cyan";
  ctx.beginPath();
  ctx.moveTo(0,0); ctx.lineTo(15,0); ctx.stroke();
  ctx.restore();

  // Name and score
  ctx.fillStyle="white";
  ctx.font="14px Arial";
  ctx.textAlign="center";
  const displayText = `${pl.name}${pl.score !== undefined ? ` (${pl.score})` : ''}`;
  ctx.fillText(displayText, px, py - player.radius - 10);
  
  // Draw ready indicator
  if(pl.ready) {
    ctx.fillStyle = "#4CAF50";
    ctx.beginPath();
    ctx.arc(px + 15, py - 15, 5, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawPlanets(){
  const centerX=canvas.width/2, centerY=canvas.height/2;
  for(let p of planets){
    const screenX=p.x-player.x+centerX;
    const screenY=p.y-player.y+centerY;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(screenX,screenY,p.radius,0,Math.PI*2);
    ctx.fill();
  }

  // Black Hole
  const bhX = blackHole.x - player.x + centerX;
  const bhY = blackHole.y - player.y + centerY;
  blackHole.angle += 0.005;
  for(let i=0;i<5;i++){
    ctx.strokeStyle = `rgba(150,0,200,${0.1-i*0.015})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(bhX,bhY,blackHole.radius*(1.2+i*0.3),blackHole.angle,blackHole.angle+Math.PI*1.5);
    ctx.stroke();
  }
  const gradient = ctx.createRadialGradient(bhX,bhY,blackHole.radius*0.5,bhX,bhY,blackHole.radius*3);
  gradient.addColorStop(0,"rgba(0,0,0,1)");
  gradient.addColorStop(0.3,"rgba(50,0,50,0.3)");
  gradient.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(bhX,bhY,blackHole.radius*3,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle = blackHole.color;
  ctx.beginPath();
  ctx.arc(bhX,bhY,blackHole.radius,0,Math.PI*2);
  ctx.fill();

  // Black hole particles
  for(let p of blackHole.particles){
    p.angle += p.speed;
    const px = bhX + Math.cos(p.angle)*p.r;
    const py = bhY + Math.sin(p.angle)*p.r;
    ctx.fillStyle = `rgba(200,50,250,0.3)`;
    ctx.beginPath();
    ctx.arc(px,py,p.size,0,Math.PI*2);
    ctx.fill();
  }
}

// --- Mini-map ---
function drawMiniMap(){
  const mapX=canvas.width-miniMap.width-miniMap.padding;
  const mapY=miniMap.padding;
  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(mapX,mapY,miniMap.width,miniMap.height);
  ctx.strokeStyle="white";
  ctx.strokeRect(mapX,mapY,miniMap.width,miniMap.height);

  let maxDist=0;
  for(let p of planets.concat([blackHole])){
    const d=Math.sqrt((p.x-player.x)**2+(p.y-player.y)**2)+p.radius;
    if(d>maxDist) maxDist=d;
  }
  if(maxDist<200) maxDist=200;
  const scale=(miniMap.width/2)/maxDist;

  for(let p of planets){
    const dx=p.x-player.x, dy=p.y-player.y;
    const px=mapX+miniMap.width/2+dx*scale;
    const py=mapY+miniMap.height/2+dy*scale;
    const r=Math.max(2,p.radius*scale);
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(px,py,r,0,Math.PI*2);
    ctx.fill();
  }
  
  // Black hole
  const dx=blackHole.x-player.x, dy=blackHole.y-player.y;
  const px=mapX+miniMap.width/2+dx*scale, py=mapY+miniMap.height/2+dy*scale;
  const r=Math.max(2,blackHole.radius*scale);
  ctx.fillStyle="rgba(180,180,180,0.3)";
  ctx.beginPath();
  ctx.arc(px,py,r,0,Math.PI*2);
  ctx.fill();
  
  // Orbs on minimap
  if(matchState === 'running') {
    for(let orb of orbs) {
      if(orb.active) {
        const dx=orb.x-player.x, dy=orb.y-player.y;
        const orbX=mapX+miniMap.width/2+dx*scale;
        const orbY=mapY+miniMap.height/2+dy*scale;
        ctx.fillStyle="#4CAF50";
        ctx.beginPath();
        ctx.arc(orbX, orbY, 3, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // Player
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(mapX+miniMap.width/2,mapY+miniMap.height/2,4,0,Math.PI*2);
  ctx.fill();
}

// --- Game Loop ---
function loop(){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawStars();
  updatePlayer();
  drawPlanets();
  
  // Draw orbs only during match
  if(matchState === 'running') {
    drawOrbs();
  }
  
  // Draw all players
  for(let id in playersData){
    if(id !== playerId){
      drawPlayer(playersData[id]);
    }
  }
  drawPlayer(player);
  drawMiniMap();
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
