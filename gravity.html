<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Ball Multiplayer</title>
<style>
  body { margin:0; background:black; overflow:hidden; font-family:Arial,sans-serif; }
  canvas { display:block; }
  #nameOverlay {
    position:fixed;
    inset:0;
    background:black;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:10;
  }
  #nameInput {
    font-size:20px;
    padding:10px;
    border-radius:8px;
    border:none;
    outline:none;
  }
  #readyBtn {
    position:fixed;
    top:20px;
    right:20px;
    padding:15px 30px;
    font-size:18px;
    font-weight:bold;
    border:none;
    border-radius:8px;
    cursor:pointer;
    z-index:5;
    transition:all 0.3s;
  }
  #readyBtn.not-ready {
    background:#444;
    color:white;
  }
  #readyBtn.ready {
    background:#4CAF50;
    color:white;
  }
  #gameUI {
    position:fixed;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    color:white;
    text-align:center;
    z-index:5;
    font-size:24px;
    font-weight:bold;
  }
  #countdown {
    font-size:80px;
    color:#FFD700;
    text-shadow:0 0 20px #FFD700;
  }
  #endScreen {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.95);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:20;
    flex-direction:column;
    color:white;
  }
  #endScreen h1 {
    font-size:48px;
    margin-bottom:30px;
    color:#FFD700;
  }
  #leaderboard {
    background:rgba(255,255,255,0.1);
    padding:30px;
    border-radius:10px;
    margin-bottom:30px;
    min-width:400px;
  }
  .rank-item {
    display:flex;
    justify-content:space-between;
    padding:10px;
    margin:5px 0;
    background:rgba(255,255,255,0.05);
    border-radius:5px;
    font-size:20px;
  }
  .rank-item.first { background:rgba(255,215,0,0.3); }
  .rank-item.second { background:rgba(192,192,192,0.3); }
  .rank-item.third { background:rgba(205,127,50,0.3); }
  #replayBtn {
    padding:15px 40px;
    font-size:22px;
    background:#4CAF50;
    color:white;
    border:none;
    border-radius:8px;
    cursor:pointer;
    font-weight:bold;
  }
  #replayBtn:hover {
    background:#45a049;
  }
</style>
</head>
<body>

<!-- Name entry -->
<div id="nameOverlay">
  <input id="nameInput" placeholder="Enter your name & press Enter">
</div>

<!-- Ready button -->
<button id="readyBtn" class="not-ready" style="display:none;">Ready</button>

<!-- Game UI -->
<div id="gameUI" style="display:none;">
  <div id="countdown"></div>
  <div id="timer" style="display:none;">Time: <span id="timeLeft">120</span>s</div>
  <div id="score" style="display:none;">Score: <span id="scoreValue">0</span></div>
</div>

<!-- End screen -->
<div id="endScreen">
  <h1>Game Over!</h1>
  <div id="leaderboard"></div>
  <button id="replayBtn">Play Again</button>
</div>

<canvas id="game"></canvas>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyAwEy-sJx7E61BA6VmBfIFMZsjuAj8RK5g",
  authDomain: "games-c3e27.firebaseapp.com",
  databaseURL: "https://games-c3e27-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "games-c3e27",
  storageBucket: "games-c3e27.firebasestorage.app",
  messagingSenderId: "193027632069",
  appId: "1:193027632069:web:b559c3b10011bc6982b9ac"
};
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// --- Variables ---
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const G = 0.15, thrust = 0.1, keys = {};
const miniMap = { width:200, height:150, padding:10 };
const starSectorSize = 400;

let playerName = null;
let playerId = 'player_' + Math.random().toString(36).substr(2,8) + Date.now();
let playersData = {};
let planets = [], blackHole = null;
let isTabActive = true;
let lastUpdateTime = Date.now();

// Game state
let gameState = 'waiting'; // waiting, countdown, playing, ended
let isReady = false;
let countdownValue = 3;
let gameTimer = 120;
let playerScore = 0;
let orbs = {};
let orbRespawnTimers = {};

// --- UI Elements ---
const nameOverlay = document.getElementById("nameOverlay");
const nameInput = document.getElementById("nameInput");
const readyBtn = document.getElementById("readyBtn");
const gameUI = document.getElementById("gameUI");
const countdownDiv = document.getElementById("countdown");
const timerDiv = document.getElementById("timer");
const scoreDiv = document.getElementById("score");
const scoreValue = document.getElementById("scoreValue");
const timeLeft = document.getElementById("timeLeft");
const endScreen = document.getElementById("endScreen");
const leaderboard = document.getElementById("leaderboard");
const replayBtn = document.getElementById("replayBtn");

nameInput.focus();

nameInput.addEventListener("keydown", e => {
  if(e.key === "Enter" && nameInput.value.trim()){
    playerName = nameInput.value.trim();
    nameOverlay.remove();
    startGame();
  }
});

// Ready button
readyBtn.addEventListener("click", () => {
  isReady = !isReady;
  readyBtn.textContent = isReady ? "Unready" : "Ready";
  readyBtn.className = isReady ? "ready" : "not-ready";
  database.ref('gravity/players/' + playerId).update({ready: isReady});
});

// Replay button
replayBtn.addEventListener("click", () => {
  endScreen.style.display = 'none';
  gameState = 'waiting';
  playerScore = 0;
  scoreValue.textContent = '0';
  isReady = false;
  readyBtn.textContent = "Ready";
  readyBtn.className = "not-ready";
  readyBtn.style.display = 'block';
  database.ref('gravity/players/' + playerId).update({ready: false, score: 0});
  database.ref('gravity/gameState').set({state: 'waiting', startTime: null});
});

// --- Utility ---
function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return ((t^t>>>14)>>>0)/4294967296;}}

// --- Generate world if first player ---
function generateWorld(){
  const colors = ["orange","red","green","blue","purple","yellow","pink","cyan","lime","magenta"];
  planets = [];
  let attempts = 0;
  while(planets.length < 10 && attempts < 5000){
    attempts++;
    const radius = 30 + Math.random()*90;
    const x = Math.random()*3000 - 1500;
    const y = Math.random()*3000 - 1500;
    const color = colors[Math.floor(Math.random()*colors.length)];
    let ok = true;
    for(let p of planets){
      const dx=x-p.x, dy=y-p.y, dist=Math.sqrt(dx*dx+dy*dy);
      if(dist < radius+p.radius+50){ ok=false; break; }
    }
    if(Math.sqrt(x*x+y*y)<200) ok=false;
    if(ok) planets.push({x,y,radius,mass:Math.pow(radius,3)*0.07,color});
  }

  let ok=false;
  while(!ok){
    const x = Math.random()*6000 - 3000;
    const y = Math.random()*6000 - 3000;
    if(Math.sqrt(x*x+y*y) > 4000){
      blackHole = {x,y,radius:100,mass:800000,color:"black",angle:0,particles:[]};
      for(let i=0;i<100;i++){
        blackHole.particles.push({r:blackHole.radius+Math.random()*150,angle:Math.random()*Math.PI*2,speed:0.002+Math.random()*0.004,size:1+Math.random()*2});
      }
      ok=true;
    }
  }

  database.ref('gravity/world').set({planets,blackHole,created:Date.now()});
}

// --- Generate Orbs ---
function generateOrbs(){
  const newOrbs = {};
  for(let i = 0; i < 20; i++){
    let valid = false;
    let x, y;
    let attempts = 0;
    while(!valid && attempts < 1000){
      attempts++;
      x = Math.random() * 4000 - 2000;
      y = Math.random() * 4000 - 2000;
      valid = true;
      
      // Check distance from planets
      for(let p of planets){
        const dist = Math.sqrt((x-p.x)**2 + (y-p.y)**2);
        if(dist < p.radius + 50){ valid = false; break; }
      }
      
      // Check distance from black hole
      if(valid){
        const dist = Math.sqrt((x-blackHole.x)**2 + (y-blackHole.y)**2);
        if(dist < blackHole.radius + 100) valid = false;
      }
      
      // Check distance from other orbs
      if(valid){
        for(let id in newOrbs){
          const orb = newOrbs[id];
          const dist = Math.sqrt((x-orb.x)**2 + (y-orb.y)**2);
          if(dist < 100){ valid = false; break; }
        }
      }
    }
    
    if(valid){
      newOrbs['orb_'+i] = {x, y, radius: 18};
    }
  }
  
  database.ref('gravity/orbs').set(newOrbs);
}

// --- Respawn single orb ---
function respawnOrb(orbId){
  let valid = false;
  let x, y;
  let attempts = 0;
  
  while(!valid && attempts < 1000){
    attempts++;
    x = Math.random() * 4000 - 2000;
    y = Math.random() * 4000 - 2000;
    valid = true;
    
    for(let p of planets){
      const dist = Math.sqrt((x-p.x)**2 + (y-p.y)**2);
      if(dist < p.radius + 50){ valid = false; break; }
    }
    
    if(valid){
      const dist = Math.sqrt((x-blackHole.x)**2 + (y-blackHole.y)**2);
      if(dist < blackHole.radius + 100) valid = false;
    }
    
    if(valid){
      for(let id in orbs){
        const orb = orbs[id];
        const dist = Math.sqrt((x-orb.x)**2 + (y-orb.y)**2);
        if(dist < 100){ valid = false; break; }
      }
    }
  }
  
  if(valid){
    database.ref('gravity/orbs/' + orbId).set({x, y, radius: 18});
  }
}

// --- Load world ---
function loadWorld(callback){
  database.ref('gravity/players').once('value', playersSnapshot => {
    const activePlayers = playersSnapshot.val();
    const hasActivePlayers = activePlayers && Object.keys(activePlayers).length > 0;
    
    if(!hasActivePlayers){
      generateWorld();
      callback();
    } else {
      database.ref('gravity/world').once('value', snapshot => {
        const data = snapshot.val();
        if(data){
          planets = data.planets;
          blackHole = data.blackHole;
          callback();
        } else {
          generateWorld();
          callback();
        }
      });
    }
  });
}

// --- Player ---
const player = {x:0,y:0,vx:0,vy:0,angle:0,radius:8,name:"",score:0};

function startGame(){
  player.x = 0; player.y = 0;
  player.name = playerName;
  player.score = 0;

  loadWorld(()=>{
    const myRef = database.ref('gravity/players/' + playerId);
    myRef.set({x:player.x,y:player.y,vx:player.vx,vy:player.vy,angle:player.angle,name:player.name,ready:false,score:0});
    myRef.onDisconnect().remove();
    
    database.ref('gravity/players').on('value', snapshot => {
      const players = snapshot.val();
      if(!players || Object.keys(players).length === 0){
        database.ref('gravity/world').remove();
        database.ref('gravity/gameState').remove();
        database.ref('gravity/orbs').remove();
      }
    });

    setInterval(()=>{
      if(isTabActive && gameState === 'playing'){
        myRef.update({x:player.x,y:player.y,vx:player.vx,vy:player.vy,angle:player.angle,score:playerScore});
      } else if(isTabActive && gameState === 'waiting'){
        myRef.update({x:player.x,y:player.y,vx:player.vx,vy:player.vy,angle:player.angle});
      }
    },50);

    database.ref('gravity/players').on('value', snapshot=>{
      playersData = snapshot.val() || {};
      
      // Check if all players are ready
      if(gameState === 'waiting'){
        const playerIds = Object.keys(playersData);
        if(playerIds.length > 0){
          const allReady = playerIds.every(id => playersData[id].ready === true);
          if(allReady){
            // Start countdown
            database.ref('gravity/gameState').once('value', stateSnap => {
              const state = stateSnap.val();
              if(!state || state.state !== 'countdown'){
                database.ref('gravity/gameState').set({state: 'countdown', startTime: Date.now()});
              }
            });
          }
        }
      }
    });
    
    // Listen to game state
    database.ref('gravity/gameState').on('value', snapshot => {
      const state = snapshot.val();
      if(state){
        if(state.state === 'countdown' && gameState === 'waiting'){
          gameState = 'countdown';
          readyBtn.style.display = 'none';
          gameUI.style.display = 'block';
          startCountdown(state.startTime);
        } else if(state.state === 'playing' && gameState === 'countdown'){
          gameState = 'playing';
          countdownDiv.style.display = 'none';
          timerDiv.style.display = 'block';
          scoreDiv.style.display = 'block';
          startGameTimer(state.gameStartTime);
        } else if(state.state === 'ended' && gameState === 'playing'){
          gameState = 'ended';
          showEndScreen();
        }
      }
    });
    
    // Listen to orbs
    database.ref('gravity/orbs').on('value', snapshot => {
      orbs = snapshot.val() || {};
    });

    readyBtn.style.display = 'block';
    requestAnimationFrame(loop);
  });
}

// --- Countdown ---
function startCountdown(startTime){
  const countdownInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const remaining = 3 - elapsed;
    
    if(remaining > 0){
      countdownDiv.textContent = remaining;
    } else {
      clearInterval(countdownInterval);
      countdownDiv.textContent = 'GO!';
      setTimeout(() => {
        database.ref('gravity/gameState').set({state: 'playing', gameStartTime: Date.now()});
        generateOrbs();
      }, 500);
    }
  }, 100);
}

// --- Game Timer ---
function startGameTimer(gameStartTime){
  const timerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
    const remaining = 120 - elapsed;
    
    if(remaining > 0){
      gameTimer = remaining;
      timeLeft.textContent = remaining;
    } else {
      clearInterval(timerInterval);
      database.ref('gravity/gameState').set({state: 'ended'});
    }
  }, 100);
}

// --- End Screen ---
function showEndScreen(){
  timerDiv.style.display = 'none';
  scoreDiv.style.display = 'none';
  
  const rankings = Object.keys(playersData).map(id => ({
    name: playersData[id].name,
    score: playersData[id].score || 0
  })).sort((a, b) => b.score - a.score);
  
  leaderboard.innerHTML = '';
  rankings.forEach((player, index) => {
    const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
    const rankItem = document.createElement('div');
    rankItem.className = 'rank-item ' + rankClass;
    rankItem.innerHTML = `
      <span>#${index + 1} ${player.name}</span>
      <span>${player.score} points</span>
    `;
    leaderboard.appendChild(rankItem);
  });
  
  endScreen.style.display = 'flex';
}

// --- Input ---
window.addEventListener("keydown", e=>keys[e.key]=true);
window.addEventListener("keyup", e=>keys[e.key]=false);

document.addEventListener("visibilitychange", () => {
  isTabActive = !document.hidden;
  if(isTabActive){
    lastUpdateTime = Date.now();
  }
});

window.addEventListener("blur", () => {
  isTabActive = false;
});

window.addEventListener("focus", () => {
  isTabActive = true;
  lastUpdateTime = Date.now();
});

// --- Physics ---
function applyGravity(){
  for(let p of planets.concat([blackHole])){
    let dx = p.x - player.x;
    let dy = p.y - player.y;
    let dist = Math.sqrt(dx*dx + dy*dy); if(dist<0.1) dist=0.1;
    const R=p.radius+player.radius;
    const nx=dx/dist, ny=dy/dist;
    const accel=dist>R? G*p.mass/(dist*dist) : G*p.mass*dist/(R*R*R);
    player.vx += accel*nx; player.vy += accel*ny;
    if(dist<R && p!==blackHole){
      player.x = p.x - nx*R; player.y = p.y - ny*R;
      const vDotN = player.vx*nx + player.vy*ny;
      if(vDotN>0){ player.vx-=vDotN*nx; player.vy-=vDotN*ny; }
    }
  }

  for(let id in playersData){
    if(id===playerId) continue;
    const op=playersData[id];
    let dx=op.x-player.x, dy=op.y-player.y;
    let dist=Math.sqrt(dx*dx+dy*dy);
    let minDist=player.radius+8;
    if(dist<minDist && dist>0){
      let nx=dx/dist, ny=dy/dist, overlap=minDist-dist;
      player.x-=nx*overlap*0.5;
      player.y-=ny*overlap*0.5;
    }
  }
}

// --- Check orb collision ---
function checkOrbCollision(){
  if(gameState !== 'playing') return;
  
  for(let orbId in orbs){
    const orb = orbs[orbId];
    const dx = orb.x - player.x;
    const dy = orb.y - player.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if(dist < player.radius + orb.radius){
      playerScore++;
      scoreValue.textContent = playerScore;
      database.ref('gravity/players/' + playerId).update({score: playerScore});
      database.ref('gravity/orbs/' + orbId).remove();
      
      // Respawn after 3 seconds
      setTimeout(() => {
        respawnOrb(orbId);
      }, 3000);
      
      break;
    }
  }
}

function updatePlayer(){
  if(!isTabActive) return;
  
  if(keys["ArrowLeft"]) player.angle-=0.05;
  if(keys["ArrowRight"]) player.angle+=0.05;
  if(keys["ArrowUp"]){ player.vx+=Math.cos(player.angle)*thrust; player.vy+=Math.sin(player.angle)*thrust; }
  if(keys["m"]){ player.vx*=0.98; player.vy*=0.98; }
  applyGravity();
  player.x+=player.vx; player.y+=player.vy;
  checkOrbCollision();
}

// --- Infinite stars ---
function drawStars(){
  const centerX=canvas.width/2, centerY=canvas.height/2;
  const startX=Math.floor((player.x-centerX)/starSectorSize)*starSectorSize;
  const startY=Math.floor((player.y-centerY)/starSectorSize)*starSectorSize;
  const endX=Math.floor((player.x+centerX)/starSectorSize)*starSectorSize;
  const endY=Math.floor((player.y+centerY)/starSectorSize)*starSectorSize;
  for(let sx=startX;sx<=endX;sx+=starSectorSize){
    for(let sy=startY;sy<=endY;sy+=starSectorSize){
      const seed = sx*73856093 ^ sy*19349663;
      const rand = mulberry32(seed);
      const starsInSector = 10 + Math.floor(rand()*15);
      for(let i=0;i<starsInSector;i++){
        const starX = sx + rand()*starSectorSize;
        const starY = sy + rand()*starSectorSize;
        const radius = 0.5 + rand()*1.5;
        const brightness = 0.2 + rand()*0.5;
        const screenX = starX - player.x + centerX;
        const screenY = starY - player.y + centerY;
        if(screenX>=0 && screenX<=canvas.width && screenY>=0 && screenY<=canvas.height){
          ctx.fillStyle=`rgba(255,255,255,${brightness})`;
          ctx.beginPath();
          ctx.arc(screenX,screenY,radius,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

// --- Draw ---
function drawPlayer(pl){
  const centerX=canvas.width/2, centerY=canvas.height/2;
  const px = (pl===player)? centerX : pl.x-player.x+centerX;
  const py = (pl===player)? centerY : pl.y-player.y+centerY;
  ctx.save();
  ctx.translate(px,py);
  ctx.rotate(pl.angle);
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(0,0,player.radius,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle="cyan";
  ctx.beginPath();
  ctx.moveTo(0,0); ctx.lineTo(15,0); ctx.stroke();
  ctx.restore();

  ctx.fillStyle="white";
  ctx.font="14px Arial";
  ctx.textAlign="center";
  ctx.fillText(pl.name,px,py-player.radius-10);
}

function drawPlanets(){
  const centerX=canvas.width/2, centerY=canvas.height/2;
  for(let p of planets){
    const screenX=p.x-player.x+centerX;
    const screenY=p.y-player.y+centerY;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(screenX,screenY,p.radius,0,Math.PI*2);
    ctx.fill();
  }

  const bhX = blackHole.x - player.x + centerX;
  const bhY = blackHole.y - player.y + centerY;
  blackHole.angle += 0.005;
  for(let i=0;i<5;i++){
    ctx.strokeStyle = `rgba(150,0,200,${0.1-i*0.015})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(bhX,bhY,blackHole.radius*(1.2+i*0.3),blackHole.angle,blackHole.angle+Math.PI*1.5);
    ctx.stroke();
  }
  const gradient = ctx.createRadialGradient(bhX,bhY,blackHole.radius*0.5,bhX,bhY,blackHole.radius*3);
  gradient.addColorStop(0,"rgba(0,0,0,1)");
  gradient.addColorStop(0.3,"rgba(50,0,50,0.3)");
  gradient.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(bhX,bhY,blackHole.radius*3,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle = blackHole.color;
  ctx.beginPath();
  ctx.arc(bhX,bhY,blackHole.radius,0,Math.PI*2);
  ctx.fill();

  for(let p of blackHole.particles){
    p.angle += p.speed;
    const px = bhX + Math.cos(p.angle)*p.r;
    const py = bhY + Math.sin(p.angle)*p.r;
    ctx.fillStyle = `rgba(200,50,250,0.3)`;
    ctx.beginPath();
    ctx.arc(px,py,p.size,0,Math.PI*2);
    ctx.fill();
  }
}

// --- Draw Orbs ---
function drawOrbs(){
  if(gameState !== 'playing') return;
  
  const centerX = canvas.width/2, centerY = canvas.height/2;
  for(let orbId in orbs){
    const orb = orbs[orbId];
    const screenX = orb.x - player.x + centerX;
    const screenY = orb.y - player.y + centerY;
    
    ctx.fillStyle = 'rgba(0,255,0,0.3)';
    ctx.beginPath();
    ctx.arc(screenX, screenY, orb.radius + 5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(screenX, screenY, orb.radius, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#00aa00';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// --- Mini-map ---
function drawMiniMap(){
  const mapX=canvas.width-miniMap.width-miniMap.padding;
  const mapY=miniMap.padding;
  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(mapX,mapY,miniMap.width,miniMap.height);
  ctx.strokeStyle="white";
  ctx.strokeRect(mapX,mapY,miniMap.width,miniMap.height);

  let maxDist=0;
  for(let p of planets.concat([blackHole])){
    const d=Math.sqrt((p.x-player.x)**2+(p.y-player.y)**2)+p.radius;
    if(d>maxDist) maxDist=d;
  }
  if(maxDist<200) maxDist=200;
  const scale=(miniMap.width/2)/maxDist;

  for(let p of planets){
    const dx=p.x-player.x, dy=p.y-player.y;
    const px=mapX+miniMap.width/2+dx*scale;
    const py=mapY+miniMap.height/2+dy*scale;
    const r=Math.max(2,p.radius*scale);
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(px,py,r,0,Math.PI*2);
    ctx.fill();
  }
  
  const dx=blackHole.x-player.x, dy=blackHole.y-player.y;
  const px=mapX+miniMap.width/2+dx*scale, py=mapY+miniMap.height/2+dy*scale;
  const r=Math.max(2,blackHole.radius*scale);
  ctx.fillStyle="rgba(180,180,180,0.3)";
  ctx.beginPath();
  ctx.arc(px,py,r,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(mapX+miniMap.width/2,mapY+miniMap.height/2,4,0,Math.PI*2);
  ctx.fill();
}

// --- Game Loop ---
function loop(){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawStars();
  updatePlayer();
  drawPlanets();
  drawOrbs();

  for(let id in playersData){
    if(id !== playerId){
      const pl=playersData[id];
      drawPlayer(pl);
    }
  }
  drawPlayer(player);
  drawMiniMap();
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
