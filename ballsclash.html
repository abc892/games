<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gas Simulator with Momentum Piston</title>
<style>
body { margin:0; background:black; color:white; font-family:Arial; overflow:hidden; }
canvas { display:block; }
.ui {
  position: fixed; top:10px;
  background: rgba(0,0,0,0.7);
  padding:12px; border-radius:10px; font-size:14px;
}
#ui-left { left:10px; }
#ui-right { right:10px; }
button, input { margin-top:5px; cursor:pointer; }
input { width:150px; }
.label { font-weight: bold; color: #4CAF50; margin-top: 10px; }
</style>
</head>
<body>

<div id="ui-left" class="ui">
  <div class="label">LEFT SIDE SPAWNER</div>
  <div>Particles: <span id="count-left">0</span></div>
  <div>Speed:</div>
  <input type="range" min="1" max="20" value="5" oninput="SPEED_LEFT=+this.value">
  <br>
  <button onclick="addParticles(5, 'left')">Add 5</button>
  <button onclick="removeParticles(5, 'left')">Remove 5</button>
  <button onclick="clearParticles('left')">Clear</button>
</div>

<div id="ui-right" class="ui">
  <div class="label">RIGHT SIDE SPAWNER</div>
  <div>Particles: <span id="count-right">0</span></div>
  <div>Speed:</div>
  <input type="range" min="1" max="20" value="5" oninput="SPEED_RIGHT=+this.value">
  <br>
  <button onclick="addParticles(5, 'right')">Add 5</button>
  <button onclick="removeParticles(5, 'right')">Remove 5</button>
  <button onclick="clearParticles('right')">Clear</button>
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
resize(); addEventListener("resize",resize);

let SPEED_LEFT = 5;  // Speed for right-side particles
let SPEED_RIGHT = 5; // Speed for left-side particles
const countElLeft = document.getElementById("count-left");
const countElRight = document.getElementById("count-right");

/* ===== PARTICLE ===== */
class Particle {
  constructor(x,y,vx,vy,r=5,side='right'){
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.r = r;
    this.mass = r*r*r; // mass proportional to vol
    this.side = side; // track which side spawned it
  }
  update(piston){
    this.x += this.vx; this.y += this.vy;

    if(this.side === 'left'){
      // Left chamber particles
      // Left wall
      if(this.x-this.r<0){ this.x=this.r; this.vx*=-1; }
      // Right wall = left side of piston
      if(this.x+this.r>piston.x){
        this.x = piston.x-this.r;
        const oldVx = this.vx;
        this.vx*=-1;
        if(!piston.dragging){
          // Push piston to the right
          piston.vx += (2*this.mass*oldVx)/piston.mass;
        }
      }
    } else {
      // Right chamber particles
      // Left wall = right side of piston
      if(this.x-this.r<piston.x+piston.width){
        this.x = piston.x+piston.width+this.r;
        const oldVx = this.vx;
        this.vx*=-1;
        if(!piston.dragging){
          // Push piston to the LEFT (negative direction)
          piston.vx -= (2*this.mass*Math.abs(oldVx))/piston.mass;
        }
      }
      // Right wall
      if(this.x+this.r>canvas.width){ this.x=canvas.width-this.r; this.vx*=-1; }
    }
    
    // Top/Bottom walls
    if(this.y-this.r<0){ this.y=this.r; this.vy*=-1; }
    if(this.y+this.r>canvas.height){ this.y=canvas.height-this.r; this.vy*=-1; }
  }
  draw(){
    const speed = Math.hypot(this.vx,this.vy);
    const hue = this.side === 'right' ? Math.min(speed*50,360) : Math.min(speed*50+180,360);
    const color = `hsl(${hue},100%,50%)`;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    ctx.fill();
  }
}

/* ===== WORLD ===== */
let particlesRight = []; // spawned on right side
let particlesLeft = [];  // spawned on left side

/* ===== PISTON ===== */
let piston = {
  x: canvas.width-100,
  y: 0,
  width: 20,
  height: canvas.height,
  vx:0,
  mass: 2000, // light piston â†’ moves more with particles
  dragging:false
};

canvas.addEventListener("mousedown",e=>{
  const mx = e.clientX;
  if(mx>piston.x && mx<piston.x+piston.width) piston.dragging = true;
});
canvas.addEventListener("mouseup",e=> piston.dragging=false);
canvas.addEventListener("mousemove",e=>{
  if(piston.dragging){ 
    piston.x = Math.min(Math.max(e.clientX,100),canvas.width-100-piston.width); 
    piston.vx=0; 
  }
});

/* ===== PARTICLE FUNCTIONS ===== */
function addParticles(n, spawnSide){
  const targetArray = spawnSide === 'left' ? particlesLeft : particlesRight;
  
  for(let i=0;i<n;i++){
    const r = 2 + Math.random()*6; // variable radius
    let x, y;
    
    if(spawnSide === 'left'){
      // Spawn on left side of piston
      x = r + Math.random()*(piston.x - 150);
    } else {
      // Spawn on right side of piston
      x = piston.x + piston.width + r + Math.random()*100;
    }
    
    y = Math.random()*(canvas.height-2*r)+r;
    const vx = (Math.random()-0.5)*4;
    const vy = (Math.random()-0.5)*4;
    targetArray.push(new Particle(x,y,vx,vy,r,spawnSide));
  }
  updateCounts();
}

function removeParticles(n, side){
  if(side === 'left'){
    particlesLeft.splice(-n,n);
  } else {
    particlesRight.splice(-n,n);
  }
  updateCounts();
}

function clearParticles(side){
  if(side === 'left'){
    particlesLeft = [];
  } else {
    particlesRight = [];
  }
  updateCounts();
}

function updateCounts(){
  countElLeft.textContent = particlesLeft.length;
  countElRight.textContent = particlesRight.length;
}

/* ===== PARTICLE COLLISIONS ===== */
function collide(a,b){
  // Only collide if particles are on the same side of the piston
  if(a.side !== b.side) return;
  
  const dx = b.x-a.x; const dy = b.y-a.y;
  const dist = Math.hypot(dx,dy);
  if(dist < a.r+b.r){
    const angle = Math.atan2(dy,dx);
    const totalMass = a.mass+b.mass;

    const v1 = rotate({x:a.vx,y:a.vy}, -angle);
    const v2 = rotate({x:b.vx,y:b.vy}, -angle);

    const u1 = {x:(v1.x*(a.mass-b.mass)+2*b.mass*v2.x)/totalMass, y:v1.y};
    const u2 = {x:(v2.x*(b.mass-a.mass)+2*a.mass*v1.x)/totalMass, y:v2.y};

    const finalV1 = rotate(u1, angle);
    const finalV2 = rotate(u2, angle);

    a.vx=finalV1.x; a.vy=finalV1.y;
    b.vx=finalV2.x; b.vy=finalV2.y;

    const overlap = a.r+b.r-dist+0.5;
    a.x -= Math.cos(angle)*overlap*(b.mass/totalMass);
    a.y -= Math.sin(angle)*overlap*(b.mass/totalMass);
    b.x += Math.cos(angle)*overlap*(a.mass/totalMass);
    b.y += Math.sin(angle)*overlap*(a.mass/totalMass);
  }
}
function rotate(v,angle){ return {x:v.x*Math.cos(angle)-v.y*Math.sin(angle), y:v.x*Math.sin(angle)+v.y*Math.cos(angle)}; }

/* ===== LOOP ===== */
function loop(){
  ctx.fillStyle="rgba(0,0,0,0.25)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // update piston
  if(!piston.dragging){
    piston.x += piston.vx;
    piston.vx *= 0.95; // damping
    // Enforce 100px minimum gap on both sides
    piston.x = Math.min(Math.max(piston.x,100),canvas.width-100-piston.width);
  }

  // draw piston
  ctx.fillStyle="gray";
  ctx.fillRect(piston.x,piston.y,piston.width,piston.height);

  // combine all particles for simulation
  const allParticles = [...particlesRight, ...particlesLeft];

  // collisions and updates - use appropriate speed
  const maxSpeed = Math.max(SPEED_LEFT, SPEED_RIGHT);
  for(let s=0;s<maxSpeed;s++){
    for(let i=0;i<allParticles.length;i++){
      // Only update if within speed limit for this particle's side
      const particle = allParticles[i];
      const speedLimit = particle.side === 'left' ? SPEED_LEFT : SPEED_RIGHT;
      
      if(s < speedLimit){
        for(let j=i+1;j<allParticles.length;j++) collide(particle,allParticles[j]);
        particle.update(piston);
      }
    }
  }

  // draw particles
  allParticles.forEach(p=>p.draw());

  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>
