<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Casio fx-991ES Plus — Final Replica</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!-- MathJax CDN -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<style>
  :root{
    --bg:#0f1420; --panel:#1f2633; --screen:#f3f6ea; --btn:#e9e9e9;
    --shift:#f39c12; --alpha:#e74c3c; --op:#f9b233; --accent:#4caf50;
  }
  *{box-sizing:border-box}
  body{
    background:linear-gradient(180deg,#08101a 0%, #0f1b2a 100%);
    font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
    margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; color:#e8eef8;
    padding:20px;
  }
  .calc {
    width:980px; max-width:100%; background:linear-gradient(180deg,#222834,#11141a);
    border-radius:12px; padding:16px; display:grid; grid-template-columns:420px 1fr; gap:14px; box-shadow:0 20px 60px rgba(0,0,0,.6);
  }
  /* Left: device */
  .device { background:linear-gradient(180deg,#2a2f3b,#151820); border-radius:10px; padding:12px; display:flex; flex-direction:column; gap:10px; }
  .branding { color:#dfe8ff; font-weight:800; letter-spacing:1px; }
  .model { color:#9cd5ff; font-weight:700; }
  .screen { background:var(--screen); border-radius:6px; height:150px; padding:12px; box-shadow: inset 0 2px 8px rgba(0,0,0,0.2); position:relative; overflow:auto; color:#000; }
  .math-target{ text-align:right; font-family:"Latin Modern Math","Times New Roman",serif; font-size:20px; min-height:42px; }
  .cursor-marker{ position:absolute; width:2px; background:gold; top:12px; height: calc(100% - 24px); left:8px; display:none; }

  .indicators { display:flex; gap:8px; align-items:center; margin-top:6px; }
  .indicator { background:#eee; color:#111; padding:6px 10px; border-radius:6px; font-weight:700; }
  .indicator.shift-on { background:var(--shift); color:#fff; }
  .indicator.alpha-on { background:var(--alpha); color:#fff; }
  .mode-ind { background:#172733; color:#9cd5ff; padding:6px 10px; border-radius:6px; font-weight:700; margin-left:auto; }

  /* keypad */
  .keys { display:grid; grid-template-columns: repeat(8, 1fr); gap:8px; margin-top:6px; }
  .key { background:var(--btn); color:#111; border-radius:8px; height:48px; border:none; font-weight:700; display:flex; align-items:center; justify-content:center; position:relative; cursor:pointer; box-shadow: 0 6px 12px rgba(0,0,0,0.4); }
  .key:active{ transform:translateY(1px); box-shadow:none; }
  .prim{ font-size:15px; }
  .secondary{ position:absolute; left:8px; top:6px; font-size:11px; color:#222; opacity:0.95; }
  .alpha-label{ position:absolute; right:8px; top:6px; font-size:11px; color:#0b6623; font-weight:700; }
  .key.op { background:var(--op); color:#fff; }
  .key.shift { background:var(--shift); color:#fff; }
  .key.alpha { background:var(--alpha); color:#fff; }
  .key.equal{ background:var(--accent); color:#fff; }
  .key.wide{ grid-column:span 2; }
  .hint { font-size:12px; color:#bfcde0; margin-top:6px; text-align:center; }

  /* Right: tools */
  .tools { display:flex; flex-direction:column; gap:12px; }
  .panel{ background:rgba(255,255,255,0.03); border-radius:8px; padding:12px; color:#eaf2ff; }
  .panel h3{ margin:0 0 8px; color:#ffd966; }
  .row{ display:flex; gap:8px; align-items:center; margin-bottom:8px; }
  input[type="text"], input[type="number"], select{ padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); color:#fff; }
  button.small{ padding:8px 10px; border-radius:6px; background:#22313f; color:#fff; border:none; cursor:pointer; }
  .result{ background:#fff; color:#000; padding:8px; border-radius:6px; margin-top:8px; max-height:260px; overflow:auto; }

  /* responsive */
  @media (max-width:1000px){
    .calc{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="calc" role="application" aria-label="Casio fx-991ES Plus final">
    <div class="device">
      <div>
        <div class="branding">CASIO</div>
        <div class="model">fx-991ES PLUS — FINAL</div>
      </div>

      <div class="screen" id="screen" tabindex="0">
        <div id="mathTarget" class="math-target"></div>
        <div id="cursorMarker" class="cursor-marker"></div>
      </div>

      <div class="indicators">
        <div id="shiftIndicator" class="indicator">SHIFT</div>
        <div id="alphaIndicator" class="indicator">ALPHA</div>
        <div id="memIndicator" class="indicator">M: 0</div>
        <div class="mode-ind" id="modeIndicator">MODE: CALC</div>
      </div>

      <div class="keys" id="keysGrid">
        <!-- nav & controls -->
        <button class="key op" id="leftKey">⟵ <span class="secondary"></span></button>
        <button class="key op" id="rightKey">⟶ <span class="secondary"></span></button>
        <button class="key" id="modeKey">MODE <span class="secondary">COMP/STAT/EQN/TBL/MAT/BASE</span></button>
        <button class="key shift" id="shiftKey">SHIFT <span class="secondary">2nd</span></button>
        <button class="key alpha" id="alphaKey">ALPHA <span class="secondary">A</span></button>
        <button class="key" id="stoKey">STO <span class="secondary">→</span></button>
        <button class="key" id="rclKey">RCL <span class="secondary">M</span></button>
        <button class="key" id="mcKey">MC <span class="secondary">CLR</span></button>

        <!-- numeric & func rows -->
        <button class="key" data-alpha="A">7 <span class="prim">7</span> <span class="secondary">⁷</span> <span class="alpha-label">A</span></button>
        <button class="key" data-alpha="B">8 <span class="prim">8</span> <span class="secondary">⁸</span> <span class="alpha-label">B</span></button>
        <button class="key" data-alpha="C">9 <span class="prim">9</span> <span class="secondary">⁹</span> <span class="alpha-label">C</span></button>
        <button class="key op" id="divKey">÷ <span class="secondary">∕</span></button>
        <button class="key op" id="sqrtKey">√ <span class="secondary">³√</span></button>
        <button class="key op" id="x2Key">x² <span class="secondary">x³</span></button>
        <button class="key op" id="fracKey">a⁄b <span class="secondary">b⁄a</span></button>
        <button class="key" id="piKey">π <span class="secondary">τ</span></button>

        <button class="key" data-alpha="D">4 <span class="prim">4</span> <span class="secondary">Δ</span> <span class="alpha-label">D</span></button>
        <button class="key" data-alpha="E">5 <span class="prim">5</span> <span class="secondary">∑</span> <span class="alpha-label">E</span></button>
        <button class="key" data-alpha="F">6 <span class="prim">6</span> <span class="secondary">F</span> <span class="alpha-label">F</span></button>
        <button class="key op" id="mulKey">× <span class="secondary">·</span></button>
        <button class="key op" id="xpyKey">xʸ <span class="secondary">y√x</span></button>
        <button class="key op" id="logKey">log <span class="secondary">10^x</span></button>
        <button class="key op" id="lnKey">ln <span class="secondary">e^x</span></button>
        <button class="key" id="expKey">EXP <span class="secondary">EE</span></button>

        <button class="key" data-alpha="X">1 <span class="prim">1</span> <span class="secondary">i</span> <span class="alpha-label">X</span></button>
        <button class="key" data-alpha="Y">2 <span class="prim">2</span> <span class="secondary">j</span> <span class="alpha-label">Y</span></button>
        <button class="key" data-alpha="Z">3 <span class="prim">3</span> <span class="secondary">k</span> <span class="alpha-label">Z</span></button>
        <button class="key op" id="minusKey">− <span class="secondary">±</span></button>
        <button class="key op" id="sinKey">sin <span class="secondary">sin⁻¹</span></button>
        <button class="key op" id="cosKey">cos <span class="secondary">cos⁻¹</span></button>
        <button class="key op" id="tanKey">tan <span class="secondary">tan⁻¹</span></button>
        <button class="key" id="ansKey">ANS <span class="secondary">Ans→M</span></button>

        <button class="key" data-alpha="θ">0 <span class="prim">0</span> <span class="secondary">°</span> <span class="alpha-label">θ</span></button>
        <button class="key" id="dotKey">. <span class="secondary">·</span></button>
        <button class="key op" id="plusKey">+ <span class="secondary">++</span></button>
        <button class="key wide equal" id="eqKey">= <span class="secondary">▶</span></button>
        <button class="key" id="mplusKey">M+ <span class="secondary">M+</span></button>
        <button class="key" id="mminusKey">M- <span class="secondary">M-</span></button>
      </div>

      <div class="hint">SHIFT and ALPHA are one-shot. Click SHIFT (or ALPHA) then a key to use its secondary label. MathJax required for textbook display.</div>
    </div>
    <div class="tools">
      <div class="panel">
        <h3>Modes & Settings</h3>
        <div class="row">
          <label>Angle unit:
            <select id="angleUnit">
              <option value="DEG">DEG</option>
              <option value="RAD">RAD</option>
              <option value="GRAD">GRAD</option>
            </select>
          </label>
          <label>Decimals:
            <select id="decimals">
              <option value="auto">Auto</option>
              <option value="2">2</option>
              <option value="4">4</option>
              <option value="8">8</option>
            </select>
          </label>
          <div style="flex:1"></div>
          <button class="small" id="clearAll">Clear</button>
        </div>

        <div class="row">
          <div style="flex:1"><strong>Memory:</strong> <span id="memValue">0</span></div>
          <div>
            <button class="small" id="mcBtn">MC</button>
            <button class="small" id="mrBtn">MR</button>
            <button class="small" id="stoBtn">STO</button>
          </div>
        </div>
      </div>

      <div id="modePanel" class="panel">
        <h3>Calculator (COMP)</h3>
        <div>Use keypad to build expressions. Press <kbd>=</kbd> to evaluate. Press <kbd>MODE</kbd> to cycle modes: COMP → STAT → EQN → TABLE → MATRIX → BASE → COMP</div>
      </div>

      <div class="panel">
        <h3>Output</h3>
        <div class="row">
          <button class="small" id="copyResult">Copy</button>
          <button class="small" id="toggleMath">Toggle Math</button>
        </div>
        <div id="consoleOutput" class="result">Ready</div>
      </div>
    </div>
  </div>

<script>
/* Final combined JS: expression editor, MathJax rendering, COMP, STAT, EQN, TABLE, MATRIX, BASE-N, memory, SHIFT/ALPHA
   Keep code readable and resilient. */

/* ---------- DOM refs ---------- */
const mathTarget = document.getElementById('mathTarget');
const screen = document.getElementById('screen');
const cursorMarker = document.getElementById('cursorMarker');
const consoleOutput = document.getElementById('consoleOutput');
const modePanel = document.getElementById('modePanel');
const modeIndicator = document.getElementById('modeIndicator');
const memIndicator = document.getElementById('memIndicator');
const memValueSpan = document.getElementById('memValue');

/* ---------- state ---------- */
let expression = '';
let cursor = 0;
let lastAnswer = 0;

let angleUnit = 'DEG';
let decimalsSetting = 'auto';

let shiftActive = false;
let alphaActive = false;

let memoryM = 0;

/* ---------- small helpers ---------- */
function showConsole(msg){ consoleOutput.textContent = String(msg); }
function roundNum(v){
  if (typeof v !== 'number') return v;
  if (decimalsSetting === 'auto') {
    if (Math.abs(v) < 1e-12) return 0;
    return parseFloat(String(v));
  } else {
    const d = Number(decimalsSetting);
    return parseFloat(v.toFixed(d));
  }
}

/* ---------- Complex class (used for complex math) ---------- */
class Complex {
  constructor(re=0, im=0){ this.re = Number(re); this.im = Number(im); this.isComplex = true; }
  toString(){ const r = this.re, i = this.im; if (Math.abs(i) < 1e-12) return String(roundNum(r)); if (Math.abs(r) < 1e-12) return `${roundNum(i)}i`; return `${roundNum(r)}${i>=0?'+':''}${roundNum(i)}i`; }
  static from(x){ if (x && x.isComplex) return x; if (typeof x === 'number') return new Complex(x,0); throw new Error('Cannot convert to Complex'); }
  add(b){ b = Complex.from(b); return new Complex(this.re + b.re, this.im + b.im); }
  sub(b){ b = Complex.from(b); return new Complex(this.re - b.re, this.im - b.im); }
  mul(b){ b = Complex.from(b); return new Complex(this.re*b.re - this.im*b.im, this.re*b.im + this.im*b.re); }
  div(b){ b = Complex.from(b); const den = b.re*b.re + b.im*b.im; return new Complex((this.re*b.re + this.im*b.im)/den, (this.im*b.re - this.re*b.im)/den); }
  abs(){ return Math.hypot(this.re, this.im); }
  arg(){ return Math.atan2(this.im, this.re); }
  conj(){ return new Complex(this.re, -this.im); }
  neg(){ return new Complex(-this.re, -this.im); }
  exp(){ const e = Math.exp(this.re); return new Complex(e*Math.cos(this.im), e*Math.sin(this.im)); }
  log(){ return new Complex(Math.log(this.abs()), this.arg()); }
  pow(b){ b = Complex.from(b); return this.log().mul(b).exp(); }
  sqrt(){ const r=this.abs(), t=this.arg()/2; return new Complex(Math.sqrt(r)*Math.cos(t), Math.sqrt(r)*Math.sin(t)); }
  sin(){ const a=this.re,b=this.im; return new Complex(Math.sin(a)*Math.cosh(b), Math.cos(a)*Math.sinh(b)); }
  cos(){ const a=this.re,b=this.im; return new Complex(Math.cos(a)*Math.cosh(b), -Math.sin(a)*Math.sinh(b)); }
  tan(){ return this.sin().div(this.cos()); }
}

/* ---------- MathJax rendering & cursor placement ---------- */
const COMMAND_REGEX = /^\\[a-zA-Z]+/;
function buildPlainRepresentation(expr){
  let plain='', map=[];
  for (let i=0;i<expr.length;){
    if (expr[i] === '\\'){
      const m = expr.slice(i).match(COMMAND_REGEX);
      if (m){ plain += m[0].slice(1,2).toUpperCase(); map.push(i); i += m[0].length; continue; }
    }
    plain += expr[i]; map.push(i); i++;
  }
  return { plain, map };
}
function render(){
  const before = expression.slice(0, cursor);
  const after = expression.slice(cursor);
  mathTarget.innerHTML = `\\(${before.replace(/ /g,'\\ ')}\\boxed{\\ }${after.replace(/ /g,'\\ ')}\\)`;
  if (window.MathJax && MathJax.typesetPromise){
    MathJax.typesetPromise([mathTarget]).then(()=> placeCursor()).catch(()=>{ mathTarget.textContent = expression || '0'; placeCursor(); });
  } else { mathTarget.textContent = expression || '0'; placeCursor(); }
}
function placeCursor(){
  const { plain, map } = buildPlainRepresentation(expression);
  const ctx = document.createElement('canvas').getContext('2d');
  ctx.font = '16px monospace';
  const fullW = ctx.measureText(plain).width;
  const mRect = mathTarget.getBoundingClientRect();
  const screenRect = screen.getBoundingClientRect();
  const contentLeft = mRect.left + Math.max(0, mRect.width - fullW);
  let pIndex = map.length;
  for (let p=0;p<map.length;p++){ if (map[p] >= cursor){ pIndex = p; break; } }
  const substr = plain.substring(0,pIndex);
  const w = ctx.measureText(substr).width;
  const cursorX = contentLeft + w;
  const markerLeft = cursorX - screenRect.left;
  cursorMarker.style.left = Math.max(8, markerLeft) + 'px';
  cursorMarker.style.display = 'block';
}

/* ---------- Editing helpers ---------- */
function commandAt(index){
  if (expression[index] !== '\\') return null;
  const substr = expression.slice(index);
  const m = substr.match(COMMAND_REGEX);
  if (!m) return null;
  return { start: index, end: index + m[0].length, text: m[0] };
}
function moveCursorRight(){ if (cursor >= expression.length) return; const cmd = commandAt(cursor); if (cmd){ cursor = cmd.end; return; } if (expression[cursor] === '{'){ cursor++; return; } cursor++; }
function moveCursorLeft(){
  if (cursor <= 0) return;
  if (cursor > 0 && expression[cursor-1] === '{'){ cursor--; return; }
  if (expression[cursor-1] === '}'){
    let depth=0;
    for (let i=cursor-1;i>=0;i--){
      if (expression[i] === '}') depth++;
      else if (expression[i] === '{'){ depth--; if (depth === 0){ let j=i-1; if (j>=0 && expression[j] === '\\'){ const c = commandAt(j); if (c && c.end === i){ cursor = c.start; return; } } cursor = i; return; } }
    }
  }
  let i = cursor-1;
  if (/[a-zA-Z]/.test(expression[i])){
    let j = i; while (j>=0 && /[a-zA-Z]/.test(expression[j])) j--;
    if (j>=0 && expression[j] === '\\'){ cursor = j; return; }
  }
  cursor--;
}
function insertAtCursor(text){ expression = expression.slice(0,cursor) + text + expression.slice(cursor); cursor += text.length; }
function backspace(normal=true){
  if (cursor <= 0) return;
  if (!normal){ deleteBlock(); return; }
  if (expression[cursor-1] === '}'){
    let depth = 0;
    for (let i = cursor-1;i>=0;i--){
      if (expression[i] === '}') depth++;
      else if (expression[i] === '{'){ depth--; if (depth === 0){ let removeFrom = i; if (i-1 >=0 && expression[i-1] === '\\'){ const cmd = commandAt(i-1); if (cmd && cmd.end === i) removeFrom = cmd.start; } expression = expression.slice(0,removeFrom) + expression.slice(cursor); cursor = removeFrom; return; } }
    }
  }
  let i = cursor-1;
  if (/[a-zA-Z]/.test(expression[i])){
    let j = i; while (j>=0 && /[a-zA-Z]/.test(expression[j])) j--;
    if (j>=0 && expression[j] === '\\'){ expression = expression.slice(0,j) + expression.slice(cursor); cursor = j; return; }
  }
  expression = expression.slice(0,cursor-1) + expression.slice(cursor);
  cursor--;
}
function deleteBlock(){
  let left=-1; let depth=0;
  for (let i=cursor-1;i>=0;i--){
    if (expression[i] === '}') depth++;
    else if (expression[i] === '{'){ depth--; if (depth < 0){ left = i; break; } }
  }
  if (left === -1){ backspace(true); return; }
  let right=-1; depth=0;
  for (let i=left;i<expression.length;i++){
    if (expression[i] === '{') depth++;
    else if (expression[i] === '}'){ depth--; if (depth === 0){ right = i; break; } }
  }
  if (right === -1){ backspace(true); return; }
  let removeFrom = left;
  if (left-1 >=0 && expression[left-1] === '\\'){ const c = commandAt(left-1); if (c && c.end === left) removeFrom = c.start; }
  expression = expression.slice(0,removeFrom) + expression.slice(right+1);
  cursor = removeFrom;
}

/* ---------- Preprocess expression into JS (with Complex support) ---------- */
function preprocessForEval(expr){
  let e = expr.replace(/\\boxed\{\\ \}/g,'');
  e = e.replace(/−/g,'-');
  e = e.replace(/\^\{([^\}]+)\}/g, '**($1)');
  e = e.replace(/\\pi/g,'Math.PI').replace(/π/g,'Math.PI').replace(/\\tau/g,'Math.PI*2').replace(/τ/g,'Math.PI*2');
  e = e.replace(/\\sqrt\{([^\}]+)\}/g, 'sqrt($1)');
  while (e.includes('\\frac')){
    const idx = e.indexOf('\\frac');
    const after = e.slice(idx + 5);
    function extractBrace(s){
      if (s[0] !== '{') return [null,0];
      let depth = 0;
      for (let i=0;i<s.length;i++){
        if (s[i] === '{') depth++;
        else if (s[i] === '}'){ depth--; if (depth === 0) return [s.slice(1,i), i+1]; }
      }
      return [null,0];
    }
    const [num, nlen] = extractBrace(after);
    if (num === null) return null;
    const rest = after.slice(nlen);
    const [den, dlen] = extractBrace(rest);
    if (den === null) return null;
    const left = e.slice(0,idx);
    const right = e.slice(idx + 5 + nlen + dlen);
    e = left + '(' + num + ')/(' + den + ')' + right;
  }
  e = e.replace(/×/g,'*').replace(/÷/g,'/');
  e = e.replace(/([0-9])E([+\-]?[0-9]+)/ig, (m,a,b)=> `${a}e${b}`);
  e = e.replace(/\\sin/g,'sin').replace(/\\cos/g,'cos').replace(/\\tan/g,'tan');
  e = e.replace(/\\arcsin/g,'asin').replace(/\\arccos/g,'acos').replace(/\\arctan/g,'atan');
  e = e.replace(/\\log/g,'log10').replace(/\\ln/g,'ln');
  e = e.replace(/\bi\b/g, 'Complex(0,1)');
  return e;
}

/* ---------- wrappers supporting Complex & angle units ---------- */
function toRealArg(x){
  if (isComplexLike(x)) return x;
  if (typeof x === 'number'){
    if (angleUnit === 'DEG') return x * Math.PI/180;
    if (angleUnit === 'GRAD') return x * Math.PI/200;
  }
  return x;
}
function fromRealInverse(y){
  if (typeof y !== 'number') return y;
  if (angleUnit === 'DEG') return y * 180 / Math.PI;
  if (angleUnit === 'GRAD') return y * 200 / Math.PI;
  return y;
}
function sin(x){ if (isComplexLike(x)) return Complex.from(x).sin(); const a = toRealArg(Number(x)); return Math.sin(a); }
function cos(x){ if (isComplexLike(x)) return Complex.from(x).cos(); const a = toRealArg(Number(x)); return Math.cos(a); }
function tan(x){ if (isComplexLike(x)) return Complex.from(x).tan(); const a = toRealArg(Number(x)); return Math.tan(a); }
function asin(x){ if (isComplexLike(x)){ const i = new Complex(0,1); const z = Complex.from(x); return i.neg().mul(i.mul(z).add(Complex.from(1).sub(z.mul(z)).sqrt()).log()); } const r = Math.asin(Number(x)); return fromRealInverse(r); }
function acos(x){ if (isComplexLike(x)){ const i = new Complex(0,1); const z = Complex.from(x); const inner = z.add(i.mul(Complex.from(1).sub(z.mul(z)).sqrt())); return Complex.from(Math.PI/2).sub(i.mul(inner.log())); } const r = Math.acos(Number(x)); return fromRealInverse(r); }
function atan(x){ if (isComplexLike(x)){ const z=Complex.from(x); const i = new Complex(0,1); const num = i.add(z); const den = i.sub(z); return i.div(new Complex(2,0)).mul(num.div(den).log()); } const r = Math.atan(Number(x)); return fromRealInverse(r); }
function sqrt(x){ if (isComplexLike(x)) return Complex.from(x).sqrt(); return Math.sqrt(Number(x)); }
function ln(x){ if (isComplexLike(x)) return Complex.from(x).log(); return Math.log(Number(x)); }
function log10(x){ if (isComplexLike(x)){ const c = Complex.from(x).log(); return c.div(Complex.from(Math.LN10)); } return Math.log10 ? Math.log10(Number(x)) : Math.log(Number(x))/Math.LN10; }

/* ---------- safe evaluation (Function with wrappers) ---------- */
function safeEvalExpression(raw){
  const pre = preprocessForEval(raw);
  if (pre === null) return 'Error';
  let e = pre;
  e = e.replace(/([A-Za-z0-9\)\]])\^([A-Za-z0-9\(\{])/g, (m,a,b)=> `${a}**${b}`); // best-effort
  try {
    const fn = Function('Complex','sin','cos','tan','asin','acos','atan','sqrt','ln','log10','roundNum',
      `"use strict"; return (${e});`);
    const res = fn(Complex, sin, cos, tan, asin, acos, atan, sqrt, ln, log10, roundNum);
    if (isComplexLike(res)) return res.toString();
    if (typeof res === 'number'){ if (!isFinite(res)) return 'Math Error'; return String(roundNum(res)); }
    return String(res);
  } catch (err) {
    return 'Error';
  }
}

/* ---------- UI: SHIFT/ALPHA and key bindings ---------- */
function setShift(v){ shiftActive = v; document.getElementById('shiftIndicator').classList.toggle('shift-on', v); }
function setAlpha(v){ alphaActive = v; document.getElementById('alphaIndicator').classList.toggle('alpha-on', v); }
function clearShiftAlpha(){ if (shiftActive) setShift(false); if (alphaActive) setAlpha(false); }

/* basic control handlers */
document.getElementById('leftKey').addEventListener('click', ()=>{ moveCursorLeft(); render(); });
document.getElementById('rightKey').addEventListener('click', ()=>{ moveCursorRight(); render(); });
document.getElementById('shiftKey').addEventListener('click', ()=>{ setShift(!shiftActive); if (shiftActive) setAlpha(false); });
document.getElementById('alphaKey').addEventListener('click', ()=>{ setAlpha(!alphaActive); if (alphaActive) setShift(false); });

document.getElementById('clearAll').addEventListener('click', ()=>{ expression=''; cursor=0; memoryM=0; memValueSpan.textContent='0'; memIndicator.textContent = `M: ${memoryM}`; render(); showConsole('Cleared'); });

/* memory operations */
document.getElementById('stoKey').addEventListener('click', ()=>{ memoryM = Number(lastAnswer) || 0; memValueSpan.textContent = memoryM; memIndicator.textContent = `M: ${memoryM}`; showConsole('Stored to M'); clearShiftAlpha(); });
document.getElementById('rclKey').addEventListener('click', ()=>{ insertAtCursor(String(memoryM)); render(); clearShiftAlpha(); });
document.getElementById('mcKey').addEventListener('click', ()=>{ memoryM = 0; memValueSpan.textContent = '0'; memIndicator.textContent='M: 0'; showConsole('Memory cleared'); });

document.getElementById('mplusKey').addEventListener('click', ()=>{ memoryM += Number(lastAnswer)||0; memValueSpan.textContent = memoryM; showConsole('M+'); });
document.getElementById('mminusKey').addEventListener('click', ()=>{ memoryM -= Number(lastAnswer)||0; memValueSpan.textContent = memoryM; showConsole('M-'); });

document.getElementById('mcBtn').addEventListener('click', ()=>{ memoryM=0; memValueSpan.textContent='0'; memIndicator.textContent='M: 0'; showConsole('Memory cleared'); });
document.getElementById('mrBtn').addEventListener('click', ()=>{ showConsole('MR: '+memoryM); });
document.getElementById('stoBtn').addEventListener('click', ()=>{ memoryM = Number(lastAnswer) || 0; memValueSpan.textContent = memoryM; memIndicator.textContent = `M: ${memoryM}`; showConsole('Stored to M'); });

/* key grid binding: most keys handled uniformly */
document.querySelectorAll('#keysGrid .key').forEach(btn=>{
  const skip = ['leftKey','rightKey','modeKey','shiftKey','alphaKey','stoKey','rclKey','mcKey','mplusKey','mminusKey','eqKey','mcBtn','mrBtn','stoBtn'];
  if (skip.includes(btn.id)) return;
  btn.addEventListener('click', ()=>{
    const alphaMap = btn.getAttribute('data-alpha');
    if (alphaActive && alphaMap){ insertAtCursor(alphaMap); render(); setAlpha(false); return; }
    if (shiftActive){
      const secEl = btn.querySelector('.secondary');
      if (secEl && secEl.textContent.trim()){
        const s = secEl.textContent.trim();
        // map some common shift actions
        if (s === '10^x'){ insertAtCursor('10**('); clearShiftAlpha(); render(); return; }
        if (s === 'e^x'){ insertAtCursor('Math.E**('); clearShiftAlpha(); render(); return; }
        if (s.endsWith('⁻¹')){ // inverse trig
          if (btn.id === 'sinKey'){ insertAtCursor('\\arcsin('); clearShiftAlpha(); render(); return; }
          if (btn.id === 'cosKey'){ insertAtCursor('\\arccos('); clearShiftAlpha(); render(); return; }
          if (btn.id === 'tanKey'){ insertAtCursor('\\arctan('); clearShiftAlpha(); render(); return; }
        }
        // default: insert secondary text
        insertAtCursor(s);
        clearShiftAlpha();
        render();
        return;
      }
    }
    // standard behavior mapping
    if (btn.id === 'divKey') { insertAtCursor('÷'); render(); return; }
    if (btn.id === 'mulKey') { insertAtCursor('×'); render(); return; }
    if (btn.id === 'minusKey') { insertAtCursor('−'); render(); return; }
    if (btn.id === 'plusKey') { insertAtCursor('+'); render(); return; }
    if (btn.id === 'piKey') { insertAtCursor('\\pi'); render(); return; }
    if (btn.id === 'fracKey'){ insertAtCursor('\\frac{ }{ }'); const idx = expression.indexOf('{', cursor - ('\\frac{ }{ }'.length)); if (idx !== -1) cursor = idx + 1; render(); return; }
    if (btn.id === 'x2Key'){ insertAtCursor('^{2}'); render(); return; }
    if (btn.id === 'xpyKey'){ insertAtCursor('^{ }'); const idx = expression.indexOf('{', cursor - 3); if (idx !== -1) cursor = idx+1; render(); return; }
    if (btn.id === 'sqrtKey'){ insertAtCursor('\\sqrt{ }'); const idx = expression.indexOf('{', cursor - ('\\sqrt{ }'.length)); if (idx !== -1) cursor = idx+1; render(); return; }
    if (btn.id === 'logKey'){ insertAtCursor('\\log('); render(); return; }
    if (btn.id === 'lnKey'){ insertAtCursor('\\ln('); render(); return; }
    if (btn.id === 'expKey'){ insertAtCursor('E'); render(); return; }
    if (btn.id === 'sinKey'){ insertAtCursor('\\sin('); render(); return; }
    if (btn.id === 'cosKey'){ insertAtCursor('\\cos('); render(); return; }
    if (btn.id === 'tanKey'){ insertAtCursor('\\tan('); render(); return; }
    if (btn.id === 'ansKey'){ insertAtCursor(String(lastAnswer)); render(); return; }
    const prim = btn.querySelector('.prim') ? btn.querySelector('.prim').textContent.trim() : btn.textContent.trim().split(' ')[0];
    insertAtCursor(prim);
    render();
  });
});

/* ---------- evaluate (=) ---------- */
document.getElementById('eqKey').addEventListener('click', ()=>{
  const res = safeEvalExpression(expression);
  showConsole(res);
  mathTarget.innerHTML = `\\(${String(res)}\\)`;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([mathTarget]);
  if (!isNaN(Number(res))) lastAnswer = Number(res);
  expression = (res === 'Error' || res === 'Math Error') ? '' : String(res);
  cursor = expression.length;
});

/* ---------- keyboard ---------- */
window.addEventListener('keydown', (ev)=>{
  if (ev.key === 'ArrowLeft'){ ev.preventDefault(); moveCursorLeft(); render(); }
  else if (ev.key === 'ArrowRight'){ ev.preventDefault(); moveCursorRight(); render(); }
  else if (ev.key === 'Backspace'){ ev.preventDefault(); backspace(true); render(); }
  else if (ev.key === 'Enter'){ ev.preventDefault(); document.getElementById('eqKey').click(); }
  else if (/^[0-9()+\-*/.,]$/.test(ev.key)){
    ev.preventDefault();
    let ch = ev.key;
    if (ch === '*') ch = '×';
    if (ch === '/') ch = '÷';
    insertAtCursor(ch); render();
  } else if (/^[a-zA-Z]$/.test(ev.key)){
    ev.preventDefault();
    insertAtCursor(ev.key);
    render();
  }
});

/* click-to-place cursor */
screen.addEventListener('click', (ev)=>{
  const rect = screen.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const { plain, map } = buildPlainRepresentation(expression);
  const ctx = document.createElement('canvas').getContext('2d');
  ctx.font = '16px monospace';
  const fullW = ctx.measureText(plain).width;
  const mRect = mathTarget.getBoundingClientRect();
  const contentLeft = mRect.left + Math.max(0, mRect.width - fullW) - rect.left;
  let relX = x - contentLeft;
  if (relX < 0) relX = 0;
  if (relX > fullW) relX = fullW;
  let acc = 0; let targetPlainIdx = map.length;
  for (let i=0;i<plain.length;i++){
    const w = ctx.measureText(plain[i]).width;
    if (acc + w/2 >= relX){ targetPlainIdx = i; break; }
    acc += w;
  }
  const exprIdx = (targetPlainIdx < map.length) ? map[targetPlainIdx] : expression.length;
  cursor = exprIdx;
  render();
});

/* ---------- Mode system (COMP → STAT → EQN → TABLE → MATRIX → BASE) ---------- */
const MODES = ['COMP','STAT','EQN','TABLE','MATRIX','BASE'];
let modeIndex = 0;
function setMode(idx){
  modeIndex = idx % MODES.length;
  const mode = MODES[modeIndex];
  modeIndicator.textContent = 'MODE: ' + mode;
  renderModePanel(mode);
}
function cycleMode(){ setMode((modeIndex+1) % MODES.length); }
document.getElementById('modeKey').addEventListener('click', cycleMode);

/* ---------- Mode UIs ---------- */
function renderModePanel(mode){
  mode = mode || MODES[modeIndex];
  modePanel.innerHTML = '';
  if (mode === 'COMP'){
    modePanel.innerHTML = `<h3>Calculator (COMP)</h3><div>Standard calculations. Build expression and press =.</div>`;
  } else if (mode === 'STAT'){
    modePanel.innerHTML = `
      <h3>Statistics (STAT)</h3>
      <div class="row"><input id="statVal" placeholder="number" /></div>
      <div class="row"><button class="small" id="statAdd">Add</button><button class="small" id="statClear">Clear</button></div>
      <div style="margin-top:8px"><button class="small" id="statN">N</button><button class="small" id="statSum">Σx</button><button class="small" id="statSumSq">Σx²</button><button class="small" id="statMean">Mean</button><button class="small" id="statStd">StdDev</button></div>
      <div id="statOut" class="result">Count: 0</div>
    `;
    let arr = [];
    document.getElementById('statAdd').addEventListener('click', ()=>{
      const v = Number(document.getElementById('statVal').value);
      if (!isNaN(v)){ arr.push(v); document.getElementById('statOut').textContent = `Count: ${arr.length} — [${arr.join(', ')}]`; }
      else showConsole('Invalid number');
      document.getElementById('statVal').value = '';
    });
    document.getElementById('statClear').addEventListener('click', ()=>{ arr=[]; document.getElementById('statOut').textContent='Count: 0'; });
    document.getElementById('statN').addEventListener('click', ()=> document.getElementById('statOut').textContent = `N: ${arr.length}`);
    document.getElementById('statSum').addEventListener('click', ()=> { const s = arr.reduce((a,b)=>a+b,0); document.getElementById('statOut').textContent = `Σx: ${roundNum(s)}`; });
    document.getElementById('statSumSq').addEventListener('click', ()=> { const s = arr.reduce((a,b)=>a + b*b,0); document.getElementById('statOut').textContent = `Σx²: ${roundNum(s)}`; });
    document.getElementById('statMean').addEventListener('click', ()=> { if (arr.length===0) document.getElementById('statOut').textContent='No data'; else { const s=arr.reduce((a,b)=>a+b,0); document.getElementById('statOut').textContent = `Mean: ${roundNum(s/arr.length)}`; }});
    document.getElementById('statStd').addEventListener('click', ()=> {
      if (arr.length <= 1) { document.getElementById('statOut').textContent = 'Need >=2'; return; }
      const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
      const variance = arr.reduce((a,b)=>(a+(b-mean)**2),0)/(arr.length-1);
      document.getElementById('statOut').textContent = `Std Dev (sample): ${roundNum(Math.sqrt(variance))}`;
    });
  } else if (mode === 'EQN'){
    modePanel.innerHTML = `
      <h3>Equation Solver (EQN)</h3>
      <div class="row"><select id="eqType"><option value="linear">Linear (ax+b=0)</option><option value="quadratic">Quadratic (ax²+bx+c=0)</option></select></div>
      <div id="eqInputs"></div>
      <div class="row"><button class="small" id="eqSolve">Solve</button></div>
      <div id="eqOut" class="result">—</div>
    `;
    const eqInputs = document.getElementById('eqInputs');
    const eqType = document.getElementById('eqType');
    function renderEqFields(){
      const t = eqType.value;
      if (t === 'linear') eqInputs.innerHTML = `<label>a: <input id="linA" value="1"></label> <label>b: <input id="linB" value="0"></label>`;
      else if (t === 'quadratic') eqInputs.innerHTML = `<label>a: <input id="quadA" value="1"></label> <label>b: <input id="quadB" value="0"></label> <label>c: <input id="quadC" value="0"></label>`;
    }
    renderEqFields();
    eqType.addEventListener('change', renderEqFields);
    document.getElementById('eqSolve').addEventListener('click', ()=>{
      const t = eqType.value;
      const out = document.getElementById('eqOut');
      if (t === 'linear'){
        const a = Number(document.getElementById('linA').value) || 0;
        const b = Number(document.getElementById('linB').value) || 0;
        if (a === 0) out.textContent = 'No or infinite solutions';
        else out.textContent = `x = ${roundNum(-b/a)}`;
      } else {
        const a = Number(document.getElementById('quadA').value) || 0;
        const b = Number(document.getElementById('quadB').value) || 0;
        const c = Number(document.getElementById('quadC').value) || 0;
        if (a === 0){ out.textContent = 'a cannot be 0'; return; }
        const D = b*b - 4*a*c;
        if (D < 0){
          const real = -b/(2*a); const imag = Math.sqrt(-D)/(2*a);
          out.textContent = `x = ${roundNum(real)} ± ${roundNum(imag)}i`;
        } else {
          const r1 = (-b + Math.sqrt(D))/(2*a);
          const r2 = (-b - Math.sqrt(D))/(2*a);
          out.textContent = `x₁=${roundNum(r1)}, x₂=${roundNum(r2)}`;
        }
      }
    });
  } else if (mode === 'TABLE'){
    modePanel.innerHTML = `
      <h3>TABLE</h3>
      <div><label>Expression in x: <input id="tblExpr" value="x**2"></label></div>
      <div class="row"><label>Start: <input id="tblStart" type="number" value="0"></label><label>End: <input id="tblEnd" type="number" value="5"></label><label>Step: <input id="tblStep" type="number" value="1"></label></div>
      <div class="row"><button class="small" id="tblGen">Generate</button></div>
      <div id="tblOut" class="result">—</div>
    `;
    document.getElementById('tblGen').addEventListener('click', ()=>{
      const expr = document.getElementById('tblExpr').value;
      const a = Number(document.getElementById('tblStart').value);
      const b = Number(document.getElementById('tblEnd').value);
      const step = Number(document.getElementById('tblStep').value) || 1;
      const rows = [];
      for (let x=a; x<= b + 1e-9; x += step){
        const e = expr.replace(/\bx\b/g, `(${x})`);
        const val = safeEvalExpression(e);
        rows.push({ x: roundNum(x), y: val });
      }
      const html = '<table style="width:100%;color:#000"><tr><th>x</th><th>y</th></tr>' + rows.map(r=>`<tr><td style="padding:4px;border-top:1px solid #ddd">${r.x}</td><td style="padding:4px;border-top:1px solid #ddd">${r.y}</td></tr>`).join('') + '</table>';
      document.getElementById('tblOut').innerHTML = html;
    });
  } else if (mode === 'MATRIX'){
    modePanel.innerHTML = `
      <h3>MATRIX</h3>
      <div class="row"><label>Rows: <input id="matRows" type="number" value="2" min="1" /></label><label>Cols: <input id="matCols" type="number" value="2" min="1" /></label><button class="small" id="matCreate">Create</button></div>
      <div id="matGridOut"></div>
      <div class="row"><button class="small" id="matDet">Determinant</button><button class="small" id="matInverse">Inverse</button><button class="small" id="matTranspose">Transpose</button><button class="small" id="matMult">Multiply (self)</button></div>
      <div id="matOut" class="result">—</div>
    `;
    document.getElementById('matCreate').addEventListener('click', ()=>{
      const r = Number(document.getElementById('matRows').value), c = Number(document.getElementById('matCols').value);
      const container = document.getElementById('matGridOut');
      container.innerHTML = '';
      const grid = document.createElement('div');
      grid.style.display='grid'; grid.style.gridTemplateColumns = `repeat(${c}, 1fr)`; grid.style.gap='6px';
      for (let i=0;i<r*c;i++){ const ip = document.createElement('input'); ip.type='number'; ip.value='0'; ip.style.padding='6px'; ip.style.borderRadius='6px'; ip.style.background='rgba(255,255,255,0.02)'; ip.style.color='#fff'; grid.appendChild(ip); }
      container.appendChild(grid);
      container.dataset.rows = r; container.dataset.cols = c;
    });
    function readMatrix(){
      const container = document.getElementById('matGridOut');
      const r = Number(container.dataset.rows||0), c = Number(container.dataset.cols||0);
      if (!r || !c) return null;
      const inputs = container.querySelectorAll('input');
      const m = [];
      for (let i=0;i<r;i++){ const row = []; for (let j=0;j<c;j++){ row.push(Number(inputs[i*c + j].value) || 0); } m.push(row); }
      return m;
    }
    document.getElementById('matDet').addEventListener('click', ()=>{
      const m = readMatrix(); if (!m) { document.getElementById('matOut').textContent='Create matrix first'; return; }
      if (m.length !== m[0].length){ document.getElementById('matOut').textContent='Determinant only for square matrices'; return; }
      const det = determinant(m);
      document.getElementById('matOut').textContent = 'Determinant: ' + roundNum(det);
    });
    document.getElementById('matInverse').addEventListener('click', ()=>{
      const m = readMatrix(); if (!m) { document.getElementById('matOut').textContent='Create matrix first'; return; }
      if (m.length !== m[0].length){ document.getElementById('matOut').textContent='Inverse only for square matrices'; return; }
      const inv = invertMatrix(m);
      if (!inv) { document.getElementById('matOut').textContent='Matrix singular'; return; }
      document.getElementById('matOut').innerHTML = '<pre style="color:#000">'+JSON.stringify(inv,null,2)+'</pre>';
    });
    document.getElementById('matTranspose').addEventListener('click', ()=>{
      const m = readMatrix(); if (!m) { document.getElementById('matOut').textContent='Create matrix first'; return; }
      const t = transposeMatrix(m);
      document.getElementById('matOut').innerHTML = '<pre style="color:#000">'+JSON.stringify(t,null,2)+'</pre>';
    });
    document.getElementById('matMult').addEventListener('click', ()=>{
      const m = readMatrix(); if (!m) { document.getElementById('matOut').textContent='Create matrix first'; return; }
      const mm = multiplyMatrices(m,m);
      document.getElementById('matOut').innerHTML = '<pre style="color:#000">'+JSON.stringify(mm,null,2)+'</pre>';
    });
  } else if (mode === 'BASE'){
    modePanel.innerHTML = `
      <h3>Base Conversion</h3>
      <div class="row"><label>Input: <input id="baseIn" value="255" /></label><label>From: <select id="fromBase"><option value="10">DEC</option><option value="2">BIN</option><option value="8">OCT</option><option value="16">HEX</option></select></label></div>
      <div class="row"><label>To: <select id="toBase"><option value="2">BIN</option><option value="8">OCT</option><option value="10">DEC</option><option value="16">HEX</option></select></label><button class="small" id="convBtn">Convert</button></div>
      <div id="baseOut" class="result">—</div>
    `;
    document.getElementById('convBtn').addEventListener('click', ()=>{
      const v = document.getElementById('baseIn').value.trim();
      const from = Number(document.getElementById('fromBase').value);
      const to = Number(document.getElementById('toBase').value);
      try { const dec = parseInt(v, from); if (isNaN(dec)){ document.getElementById('baseOut').textContent='Invalid input for base ' + from; return; } const out = dec.toString(to).toUpperCase(); document.getElementById('baseOut').textContent = `${out} (base ${to})`; } catch(e){ document.getElementById('baseOut').textContent = 'Error'; }
  }
  }
}

/* ---------- small matrix utilities ---------- */
function determinant(m){
  const n = m.length;
  if (n === 1) return m[0][0];
  if (n === 2) return m[0][0]*m[1][1] - m[0][1]*m[1][0];
  let det = 0;
  for (let j=0;j<n;j++){
    const sub = [];
    for (let r=1;r<n;r++){ const row=[]; for (let c=0;c<n;c++) if (c!==j) row.push(m[r][c]); sub.push(row); }
    det += ((j%2===0?1:-1) * m[0][j] * determinant(sub));
  }
  return det;
}
function transposeMatrix(m){ const r=m.length, c=m[0].length, out=Array.from({length:c}, ()=>Array.from({length:r}, ()=>0)); for (let i=0;i<r;i++) for (let j=0;j<c;j++) out[j][i]=m[i][j]; return out; }
function multiplyMatrices(a,b){ const ar=a.length, ac=a[0].length, br=b.length, bc=b[0].length; if (ac !== br) return null; const out=Array.from({length:ar}, ()=>Array.from({length:bc}, ()=>0)); for (let i=0;i<ar;i++) for (let j=0;j<bc;j++) for (let k=0;k<ac;k++) out[i][j]+=a[i][k]*b[k][j]; return out; }
function invertMatrix(m){
  const n = m.length;
  const A = m.map(r=>r.slice());
  const I = Array.from({length:n}, (_,i)=>Array.from({length:n}, (_,j)=> i===j?1:0));
  for (let i=0;i<n;i++){
    let piv = i;
    for (let r=i;r<n;r++) if (Math.abs(A[r][i]) > Math.abs(A[piv][i])) piv = r;
    if (Math.abs(A[piv][i]) < 1e-12) return null;
    [A[i], A[piv]] = [A[piv], A[i]]; [I[i], I[piv]] = [I[piv], I[i]];
    const div = A[i][i];
    for (let j=0;j<n;j++){ A[i][j] /= div; I[i][j] /= div; }
    for (let r=0;r<n;r++){ if (r===i) continue; const f = A[r][i]; for (let c=0;c<n;c++){ A[r][c] -= f*A[i][c]; I[r][c] -= f*I[i][c]; } }
  }
  return I;
}

/* ---------- small poly solver (Durand-Kerner) ---------- */
function durandKerner(coeffs){
  const n = coeffs.length - 1;
  const a0 = coeffs[0];
  const c = coeffs.map(x => x / a0);
  let roots = [];
  const radius = 1 + Math.max(...c.slice(1).map(Math.abs));
  for (let k=0;k<n;k++){ const angle = 2*Math.PI*k/n; roots.push(new Complex(radius*Math.cos(angle), radius*Math.sin(angle))); }
  let iterations=0;
  while (iterations < 300){
    let converged = true;
    for (let i=0;i<n;i++){
      let num = evalPolyComplex(c, roots[i]);
      let denom = new Complex(1,0);
      for (let j=0;j<n;j++) if (j!==i) denom = denom.mul(roots[i].sub(roots[j]));
      if (denom.re === 0 && denom.im === 0) denom = new Complex(1e-12,0);
      const delta = num.div(denom);
      roots[i] = roots[i].sub(delta);
      if (Math.hypot(delta.re, delta.im) > 1e-8) converged = false;
    }
    if (converged) break;
    iterations++;
  }
  return roots.map(r => (Math.abs(r.im) < 1e-8) ? roundNum(r.re) : r);
}
function evalPolyComplex(coeffs, z){
  let res = new Complex(0,0);
  for (let i=0;i<coeffs.length;i++){ res = res.mul(z).add(new Complex(coeffs[i],0)); }
  return res;
}

/* ---------- settings & small UI controls ---------- */
document.getElementById('angleUnit').addEventListener('change', (e)=>{ angleUnit = e.target.value; showConsole('Angle: '+angleUnit); });
document.getElementById('decimals').addEventListener('change', (e)=>{ decimalsSetting = e.target.value; showConsole('Decimals: '+decimalsSetting); });
document.getElementById('copyResult').addEventListener('click', ()=>{ navigator.clipboard?.writeText(consoleOutput.textContent).then(()=> showConsole('Copied'), ()=> showConsole('Copy failed')); });
document.getElementById('toggleMath').addEventListener('click', ()=>{ mathTarget.style.display = mathTarget.style.display === 'none' ? 'block' : 'none'; });

/* ---------- initial render ---------- */
setMode(0);
render();
showConsole('Ready — MathJax required for textbook display.');
</script>
</body>
</html>
