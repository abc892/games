<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Arena Tag Showdown</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .game-container {
      position: relative;
    }
    canvas {
      display: block;
      background: linear-gradient(135deg, #ff6ec4, #7873f5);
      border: 4px solid #fff;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      color: #fff;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 20px;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      color: #fff;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 20;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      border: 2px solid gold;
    }
    #setup-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 30;
      color: white;
      width: 400px;
    }
    #time-setup {
      display: none;
    }
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      color: rgba(255, 255, 255, 0.7);
      z-index: 25;
      display: none;
    }
    button {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 10px 5px;
      cursor: pointer;
      border-radius: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    input {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: 1px solid #ccc;
      margin: 10px 0;
      width: 100px;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div id="ui">Time: 0</div>
    <div id="gameOver"></div>
    <div id="countdown"></div>
    <div id="setup-screen">
      <h2>Select Number of Players</h2>
      <button onclick="selectPlayers(2)">2 Players</button>
      <button onclick="selectPlayers(3)">3 Players</button>
      <button onclick="selectPlayers(4)">4 Players</button>
    </div>
    <div id="time-setup">
      <h2>Set Time Limit (Seconds)</h2>
      <input type="number" id="time-input" min="10" max="300" value="30">
      <button onclick="startGame()">Start Game</button>
    </div>
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const gameOverDisplay = document.getElementById('gameOver');
    const setupScreen = document.getElementById('setup-screen');
    const timeSetup = document.getElementById('time-setup');
    const timeInput = document.getElementById('time-input');
    const countdownDisplay = document.getElementById('countdown');

    const keys = {};
    document.addEventListener('keydown', e => keys[e.key] = true);
    document.addEventListener('keyup', e => keys[e.key] = false);

    let players = [];
    let numPlayers = 2;
    let gameStarted = false;

    const gravity = 0.5;
    const platforms = [
      { x: 100, y: 550, w: 80, h: 15 },
      { x: 250, y: 500, w: 70, h: 15 },
      { x: 400, y: 450, w: 80, h: 15 },
      { x: 550, y: 500, w: 70, h: 15 },
      { x: 700, y: 550, w: 80, h: 15 },
      { x: 850, y: 500, w: 70, h: 15 },
      { x: 1000, y: 450, w: 80, h: 15 },
      { x: 200, y: 350, w: 70, h: 15 },
      { x: 400, y: 300, w: 80, h: 15 },
      { x: 600, y: 350, w: 70, h: 15 },
      { x: 800, y: 300, w: 80, h: 15 },
      { x: 1000, y: 350, w: 70, h: 15 },
      { x: 300, y: 200, w: 80, h: 15 },
      { x: 500, y: 150, w: 70, h: 15 },
      { x: 700, y: 200, w: 80, h: 15 },
      { x: 900, y: 150, w: 70, h: 15 },
      // Low platforms near the ground that can be climbed without jump pad
      { x: 200, y: 620, w: 90, h: 15 },
      { x: 900, y: 620, w: 90, h: 15 }
    ];
    
    // Bounce pad placed in the corner and just above the ground
    const bouncePad = { x: 30, y: 650, w: 50, h: 12 };

    let teleporters = [];
    let teleportCooldown = 0;
    let lastTagTime = 0;
    let timer = 0;
    let frameCount = 0;
    let gameOver = false;

    function selectPlayers(number) {
      numPlayers = number;
      setupScreen.style.display = 'none';
      timeSetup.style.display = 'block';
    }

    function startGame() {
      const timeLimit = parseInt(timeInput.value);
      if (isNaN(timeLimit) || timeLimit < 10) {
        alert("Please enter a valid time limit (minimum 10 seconds)");
        return;
      }
      
      timer = timeLimit;
      timeSetup.style.display = 'none';
      
      // Initialize players based on selected number
      players = [];
      const colors = ['red', 'green', 'blue', 'yellow'];
      const startPositions = [
        { x: 100, y: 100 },
        { x: 1000, y: 100 },
        { x: 100, y: 500 },
        { x: 1000, y: 500 }
      ];
      
      const controlSchemes = [
        { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, // Player 1 (red)
        { up: 'w', down: 's', left: 'a', right: 'd' }, // Player 2 (green)
        { up: 't', down: 'g', left: 'f', right: 'h' }, // Player 3 (blue)
        { up: 'i', down: 'k', left: 'j', right: 'l' }  // Player 4 (yellow)
      ];
      
      for (let i = 0; i < numPlayers; i++) {
        players.push({ 
          x: startPositions[i].x, 
          y: startPositions[i].y, 
          vx: 0, 
          vy: 0, 
          w: 30, 
          h: 30, 
          color: colors[i], 
          isIt: false, 
          controls: controlSchemes[i] 
        });
      }
      
      // Randomly assign who is "it"
      const randomPlayerIndex = Math.floor(Math.random() * numPlayers);
      players[randomPlayerIndex].isIt = true;
      
      spawnTeleporters();
      
      // Start countdown
      let countdown = 3;
      countdownDisplay.style.display = 'block';
      countdownDisplay.textContent = countdown;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          countdownDisplay.textContent = countdown;
        } else {
          clearInterval(countdownInterval);
          countdownDisplay.textContent = "GO!";
          setTimeout(() => {
            countdownDisplay.style.display = 'none';
            gameStarted = true;
            gameLoop();
          }, 500);
        }
      }, 1000);
    }

    function spawnTeleporters() {
      // Spawn teleporters in accessible locations near platforms
      const platformEdges = platforms.map(pl => [
        { x: pl.x, y: pl.y - 25 }, // Top of platform
        { x: pl.x + pl.w, y: pl.y - 25 } // Top of platform at right edge
      ]).flat();
      
      // Add some additional accessible positions
      const accessiblePositions = [
        { x: 150, y: 300 },
        { x: 1050, y: 300 },
        { x: 600, y: 200 },
        { x: 600, y: 400 },
        { x: 350, y: 200 },
        { x: 850, y: 200 }
      ];
      
      const allPositions = [...platformEdges, ...accessiblePositions];
      
      // Select two distinct positions
      const index1 = Math.floor(Math.random() * allPositions.length);
      let index2;
      do {
        index2 = Math.floor(Math.random() * allPositions.length);
      } while (index2 === index1);
      
      const pos1 = allPositions[index1];
      const pos2 = allPositions[index2];
      
      teleporters = [
        { x: pos1.x, y: pos1.y, radius: 12, active: true },
        { x: pos2.x, y: pos2.y, radius: 12, active: true }
      ];
    }

    function updatePlayer(p) {
      if (!gameStarted) return;
      
      if (keys[p.controls.left]) p.vx = -4;
      else if (keys[p.controls.right]) p.vx = 4;
      else p.vx = 0;

      if (keys[p.controls.up] && isGrounded(p)) p.vy = -10;

      p.vy += gravity;
      p.x += p.vx;
      p.y += p.vy;

      // Ground collision
      if (p.y + p.h > canvas.height) {
        p.y = canvas.height - p.h;
        p.vy = 0;
      }

      // Platform collision - FIXED
      platforms.forEach(pl => {
        // Check if player is colliding with platform from above (landing on it)
        if (p.vy >= 0 && // Player is moving downward or stationary
            p.x < pl.x + pl.w &&
            p.x + p.w > pl.x &&
            p.y + p.h >= pl.y &&
            p.y + p.h <= pl.y + pl.h + 5) {
          p.y = pl.y - p.h;
          p.vy = 0;
        }
        
        // Check if player is hitting platform from below
        if (p.vy < 0 && // Player is moving upward
            p.x < pl.x + pl.w &&
            p.x + p.w > pl.x &&
            p.y <= pl.y + pl.h &&
            p.y + p.h >= pl.y) {
          p.y = pl.y + pl.h;
          p.vy = 0;
        }
        
        // Check if player is hitting platform from the sides
        if (p.x + p.w > pl.x && p.x < pl.x + pl.w &&
            p.y + p.h > pl.y && p.y < pl.y + pl.h) {
          if (p.vx > 0) { // Moving right
            p.x = pl.x - p.w;
          } else if (p.vx < 0) { // Moving left
            p.x = pl.x + pl.w;
          }
        }
      });

      // Bounce pad
      if (
        p.x < bouncePad.x + bouncePad.w &&
        p.x + p.w > bouncePad.x &&
        p.y + p.h >= bouncePad.y &&
        p.y + p.h <= bouncePad.y + bouncePad.h + 5
      ) {
        p.vy = -20; // Higher jump
      }

      // Teleporters
      if (teleporters[0].active && teleporters[1].active) {
        for (let i = 0; i < teleporters.length; i++) {
          const tp = teleporters[i];
          const dx = (p.x + p.w/2) - tp.x;
          const dy = (p.y + p.h/2) - tp.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < tp.radius + p.w/2) {
            const target = teleporters[1 - i]; // The other teleporter
            p.x = target.x - p.w/2;
            p.y = target.y - p.h/2;
            
            // Add a slight momentum change for visual effect
            p.vx = (Math.random() - 0.5) * 4;
            p.vy = -2;
            
            teleporters[0].active = false;
            teleporters[1].active = false;
            teleportCooldown = frameCount;
            break; // Exit loop after teleporting
          }
        }
      }

      // Keep inside canvas
      p.x = Math.max(0, Math.min(canvas.width - p.w, p.x));
      p.y = Math.min(canvas.height - p.h, p.y);
    }

    function isGrounded(p) {
      return (
        p.y + p.h >= canvas.height ||
        platforms.some(pl =>
          p.x < pl.x + pl.w &&
          p.x + p.w > pl.x &&
          p.y + p.h >= pl.y &&
          p.y + p.h <= pl.y + pl.h + 5
        )
      );
    }

    function detectTag(p1, p2) {
      return (
        p1.x < p2.x + p2.w &&
        p1.x + p1.w > p2.x &&
        p1.y < p2.y + p2.h &&
        p1.y + p1.h > p2.y
      );
    }

    function drawTagIndicator(player) {
      const orbX = player.x + player.w / 2;
      const orbY = player.y - 12;
      ctx.beginPath();
      ctx.arc(orbX, orbY, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'gold';
      ctx.shadowColor = 'gold';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function showGameOver() {
      const itPlayer = players.find(p => p.isIt);
      gameOverDisplay.innerHTML = `Game Over!<br><span style="color:${itPlayer.color}; font-weight:bold">${itPlayer.color.toUpperCase()}</span> player was IT!<br><br>Press F5 to play again`;
      gameOverDisplay.style.display = 'block';
    }

    function drawPlatforms() {
      // Draw platforms
      platforms.forEach(pl => {
        ctx.fillStyle = '#8a5c36';
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(pl.x, pl.y, pl.w, 4);
      });

      // Draw bounce pad
      ctx.fillStyle = '#00c853';
      ctx.fillRect(bouncePad.x, bouncePad.y, bouncePad.w, bouncePad.h);
      for (let i = 0; i < bouncePad.w; i += 8) {
        ctx.fillStyle = '#009624';
        ctx.fillRect(bouncePad.x + i, bouncePad.y, 4, bouncePad.h);
      }
    }

    function drawPlayers() {
      players.forEach(p => {
        // Draw player shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(p.x + 3, p.y + 3, p.w, p.h);
        
        // Draw player
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // Draw player details
        ctx.fillStyle = '#000';
        ctx.fillRect(p.x + 8, p.y + 8, 6, 6);
        ctx.fillRect(p.x + p.w - 14, p.y + 8, 6, 6);
        
        if (p.isIt) drawTagIndicator(p);
      });
    }

    function drawTeleporters() {
      teleporters.forEach(tp => {
        if (tp.active) {
          // Draw glow effect
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius + 3, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 15;
          ctx.fill();
          
          // Draw teleporter
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ffeb3b';
          ctx.fill();
          
          // Draw inner circle
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius / 2, 0, Math.PI * 2);
          ctx.fillStyle = '#ffc107';
          ctx.fill();
          
          ctx.shadowBlur = 0;
        }
      });
    }

    function gameLoop() {
      if (gameOver) {
        showGameOver();
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      frameCount++;

      // Draw background elements
      drawPlatforms();

      // Respawn teleporters
      if (!teleporters[0].active && frameCount - teleportCooldown > 300) {
        spawnTeleporters();
      }

      // Draw teleporters
      drawTeleporters();

      // Update and draw players
      players.forEach(p => {
        updatePlayer(p);
      });
      drawPlayers();

      // Tag logic
      const itPlayer = players.find(p => p.isIt);
      const otherPlayers = players.filter(p => !p.isIt);

      for (const otherPlayer of otherPlayers) {
        if (detectTag(itPlayer, otherPlayer) && Date.now() - lastTagTime > 1000) {
          itPlayer.isIt = false;
          otherPlayer.isIt = true;
          lastTagTime = Date.now();
          break;
        }
      }

      // Timer
      if (frameCount % 60 === 0 && timer > 0) {
        timer--;
        ui.textContent = `Time: ${timer}`;
      }

      if (timer === 0 && !gameOver) {
        gameOver = true;
      }

      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>