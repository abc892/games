<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Arena Tag Showdown</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .game-container {
      position: relative;
    }
    canvas {
      display: block;
      border: 4px solid #fff;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 150px;
      font-size: 18px;
      color: #fff;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 20px;
    }
    #home-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: #0077cc;
      color: white;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 16px;
      transition: 0.3s;
      z-index: 15;
      display: block;
    }
    #home-btn:hover {
      background: #005fa3;
    }
    #pause-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      z-index: 10;
      font-size: 18px;
    }
    #pause-btn:hover {
      background: rgba(0, 0, 0, 0.7);
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      color: #fff;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 20;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      border: 2px solid gold;
    }
    #setup-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 30;
      color: white;
      width: 400px;
    }
    #time-setup {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 30;
      color: white;
      width: 500px;
    }
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      color: rgba(255, 255, 255, 0.7);
      z-index: 25;
      display: none;
    }
    #pause-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 40;
      color: white;
      width: 300px;
      display: none;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      border: 2px solid #4CAF50;
    }
    button {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 10px 5px;
      cursor: pointer;
      border-radius: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    .toggle-btn {
      background: #555;
    }
    .toggle-btn.active {
      background: #4CAF50;
    }
    .back-btn {
      background: #f44336;
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 15px;
      font-size: 14px;
    }
    .back-btn:hover {
      background: #d32f2f;
    }
    input {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: 1px solid #ccc;
      margin: 10px 0;
      width: 100px;
    }
    .mode-container {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #444;
    }
    .background-options {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    .background-option {
      width: 120px;
      height: 80px;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .background-option.selected {
      border-color: #4CAF50;
      box-shadow: 0 0 10px #4CAF50;
    }
    .background-option:hover {
      transform: scale(1.05);
    }
    .bluffs-container {
      margin: 20px 0;
      padding: 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
    }
    .retry-btn {
      background: #FF9800;
      font-size: 18px;
      padding: 12px 25px;
      margin-top: 15px;
    }
    .retry-btn:hover {
      background: #F57C00;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <a href="index.html" id="home-btn">üè† Home</a>
    <div id="ui" style="display: none;">Time: 0</div>
    <button id="pause-btn" style="display: none;">Pause</button>
    <div id="gameOver">
      <h2>Game Over!</h2>
      <div id="winner-text" style="color:gold; font-weight:bold; margin: 20px 0; font-size: 24px;"></div>
      <div style="margin: 20px 0;">
        <p>Press SPACEBAR or click the button to play again</p>
        <button class="retry-btn" onclick="resetToSetup()">üîÑ Play Again</button>
      </div>
    </div>
    <div id="countdown"></div>
    <div id="pause-menu">
      <h2>Game Paused</h2>
      <button onclick="resumeGame()">Resume Game</button>
      <button onclick="leaveGame()">Leave Game</button>
    </div>
    <div id="setup-screen">
      <h2>Select Number of Players</h2>
      <button onclick="selectPlayers(1)">1 Player</button>
      <button onclick="selectPlayers(2)">2 Players</button>
      <button onclick="selectPlayers(3)">3 Players</button>
      <button onclick="selectPlayers(4)">4 Players</button>
      
      <div class="mode-container">
        <h3>Robot Mode</h3>
        <button id="robot-toggle" class="toggle-btn" onclick="toggleRobotMode()">OFF</button>
        <p>Adds a smart circle that seeks or avoids players</p>
      </div>
    </div>
    <div id="time-setup" style="display: none;">
      <button class="back-btn" onclick="goBack()">Back</button>
      <h2>Game Setup</h2>
      
      <div>
        <h3>Time Limit (Seconds)</h3>
        <input type="number" id="time-input" min="10" max="300" value="30">
      </div>
      
      <div>
        <h3>Select Background</h3>
        <div class="background-options">
          <div class="background-option selected" style="background: linear-gradient(135deg, #ff6ec4, #7873f5);" onclick="selectBackground(1)"></div>
          <div class="background-option" style="background: linear-gradient(135deg, #667eea, #764ba2);" onclick="selectBackground(2)"></div>
          <div class="background-option" style="background: linear-gradient(135deg, #f093fb, #f5576c);" onclick="selectBackground(3)"></div>
        </div>
      </div>
      
      <div class="bluffs-container">
        <h3>Power-ups (Bluffs)</h3>
        <button id="bluffs-toggle" class="toggle-btn" onclick="toggleBluffs()">ON</button>
        <p>Enable or disable power-ups during gameplay</p>
      </div>
      
      <button onclick="startGame()">Start Game</button>
    </div>
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const pauseBtn = document.getElementById('pause-btn');
    const gameOverDisplay = document.getElementById('gameOver');
    const winnerText = document.getElementById('winner-text');
    const setupScreen = document.getElementById('setup-screen');
    const timeSetup = document.getElementById('time-setup');
    const timeInput = document.getElementById('time-input');
    const countdownDisplay = document.getElementById('countdown');
    const pauseMenu = document.getElementById('pause-menu');
    const robotToggleBtn = document.getElementById('robot-toggle');
    const bluffsToggleBtn = document.getElementById('bluffs-toggle');

    const keys = {};
    const keyState = {}; // Track key state for double jump
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      // Track key down for double jump
      if (!keyState[e.key]) {
        keyState[e.key] = { pressed: true, justPressed: true };
      } else {
        keyState[e.key].justPressed = true;
      }
      
      // Check for spacebar to reset game when game over
      if (e.key === ' ' && gameOver) {
        resetToSetup();
      }
    });
    document.addEventListener('keyup', e => {
      keys[e.key] = false;
      if (keyState[e.key]) {
        keyState[e.key].justPressed = false;
      }
    });

    let players = [];
    let smartCircle = null;
    let numPlayers = 2;
    let gameStarted = false;
    let robotMode = false;
    let gamePaused = false;
    let selectedBackground = 1;
    let bluffsEnabled = true;
    let currentPlatforms = [];

    const gravity = 0.5;
    // Original platform definitions - these will be used as base for randomization
    const basePlatforms = [
      { x: 100, y: 550, w: 80, h: 15 },
      { x: 250, y: 500, w: 70, h: 15 },
      { x: 400, y: 450, w: 80, h: 15 },
      { x: 550, y: 500, w: 70, h: 15 },
      { x: 700, y: 550, w: 80, h: 15 },
      { x: 850, y: 500, w: 70, h: 15 },
      { x: 1000, y: 450, w: 80, h: 15 },
      { x: 200, y: 350, w: 70, h: 15 },
      { x: 400, y: 300, w: 80, h: 15 },
      { x: 600, y: 350, w: 70, h: 15 },
      { x: 800, y: 300, w: 80, h: 15 },
      { x: 1000, y: 350, w: 70, h: 15 },
      { x: 300, y: 200, w: 80, h: 15 },
      { x: 500, y: 150, w: 70, h: 15 },
      { x: 700, y: 200, w: 80, h: 15 },
      { x: 900, y: 150, w: 70, h: 15 },
      { x: 200, y: 620, w: 90, h: 15 },
      { x: 900, y: 620, w: 90, h: 15 }
    ];
    
    const bouncePad = { x: 30, y: 650, w: 50, h: 12 };

    let teleporters = [];
    let teleportCooldown = 0;
    let lastTagTime = 0;
    let timer = 0;
    let frameCount = 0;
    let gameOver = false;
    let animationId = null;

    // Power-up system
    let powerUps = [];
    let immunitySpawnTimer = 0;
    let timeSlowSpawnTimer = 0;
    let speedBoostSpawnTimer = 0;
    let activeEffects = {
      immunity: [],
      timeSlow: { active: false, endTime: 0, slowedPlayers: [] },
      speedBoost: []
    };

    // Pause functionality
    pauseBtn.addEventListener('click', togglePause);
    
    function togglePause() {
      if (!gameStarted || gameOver) return;
      
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        pauseMenu.style.display = 'block';
        cancelAnimationFrame(animationId);
      } else {
        pauseMenu.style.display = 'none';
        gameLoop();
      }
    }
    
    function resumeGame() {
      gamePaused = false;
      pauseMenu.style.display = 'none';
      gameLoop();
    }
    
    function leaveGame() {
      resetToSetup();
    }
    
    function resetToSetup() {
      gamePaused = false;
      gameStarted = false;
      gameOver = false;
      gameOverDisplay.style.display = 'none';
      pauseMenu.style.display = 'none';
      setupScreen.style.display = 'block';
      pauseBtn.style.display = 'none';
      ui.style.display = 'none';
      
      // Reset robot mode to default state
      robotMode = false;
      robotToggleBtn.classList.remove('active');
      robotToggleBtn.textContent = 'OFF';
      robotToggleBtn.disabled = false;
      robotToggleBtn.style.opacity = '1';
      
      ui.textContent = 'Time: 0';
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    }

    function toggleRobotMode() {
      robotMode = !robotMode;
      robotToggleBtn.classList.toggle('active', robotMode);
      robotToggleBtn.textContent = robotMode ? 'ON' : 'OFF';
    }

    function toggleBluffs() {
      bluffsEnabled = !bluffsEnabled;
      bluffsToggleBtn.classList.toggle('active', bluffsEnabled);
      bluffsToggleBtn.textContent = bluffsEnabled ? 'ON' : 'OFF';
    }

    function selectBackground(bgNum) {
      selectedBackground = bgNum;
      // Update UI to show selected background
      document.querySelectorAll('.background-option').forEach((opt, index) => {
        if (index + 1 === bgNum) {
          opt.classList.add('selected');
        } else {
          opt.classList.remove('selected');
        }
      });
    }

    function goBack() {
      timeSetup.style.display = 'none';
      setupScreen.style.display = 'block';
      
      // Reset robot mode to default state when going back
      robotMode = false;
      robotToggleBtn.classList.remove('active');
      robotToggleBtn.textContent = 'OFF';
      robotToggleBtn.disabled = false;
      robotToggleBtn.style.opacity = '1';
    }

    function selectPlayers(number) {
      numPlayers = number;
      
      // Reset robot mode settings for all player counts
      if (number === 1) {
        // For single player, robot mode is automatically enabled and locked
        robotMode = true;
        robotToggleBtn.classList.add('active');
        robotToggleBtn.textContent = 'ON';
        robotToggleBtn.disabled = true;
        robotToggleBtn.style.opacity = '0.6';
      } else {
        // For multiplayer, allow robot mode toggle
        robotToggleBtn.disabled = false;
        robotToggleBtn.style.opacity = '1';
      }
      
      setupScreen.style.display = 'none';
      timeSetup.style.display = 'block';
    }

    function randomizePlatforms() {
      currentPlatforms = basePlatforms.map(platform => {
        // Random width between current-20 and current+50
        const minWidth = platform.w - 20;
        const maxWidth = platform.w + 50;
        const newWidth = Math.floor(Math.random() * (maxWidth - minWidth + 1)) + minWidth;
        
        // Return new platform with same position and height, but randomized width
        return {
          x: platform.x,
          y: platform.y,
          w: newWidth,
          h: platform.h
        };
      });
    }

    function startGame() {
      const timeLimit = parseInt(timeInput.value);
      if (isNaN(timeLimit) || timeLimit < 10) {
        alert("Please enter a valid time limit (minimum 10 seconds)");
        return;
      }
      
      // Set canvas background based on selection
      switch(selectedBackground) {
        case 1:
          canvas.style.background = 'linear-gradient(135deg, #ff6ec4, #7873f5)';
          break;
        case 2:
          canvas.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
          break;
        case 3:
          canvas.style.background = 'linear-gradient(135deg, #f093fb, #f5576c)';
          break;
      }
      
      // Randomize platforms for this game
      randomizePlatforms();
      
      timer = timeLimit;
      timeSetup.style.display = 'none';
      pauseBtn.style.display = 'block';
      ui.style.display = 'block';
      ui.textContent = `Time: ${timer}`;
      
      // Reset game state
      players = [];
      smartCircle = null;
      gameStarted = false;
      gameOver = false;
      frameCount = 0;
      lastTagTime = 0;
      powerUps = [];
      immunitySpawnTimer = 0;
      timeSlowSpawnTimer = 0;
      speedBoostSpawnTimer = 0;
      activeEffects = {
        immunity: [],
        timeSlow: { active: false, endTime: 0, slowedPlayers: [] },
        speedBoost: []
      };
      
      const colors = ['red', 'green', 'blue', 'yellow'];
      const startPositions = [
        { x: 100, y: 100 },
        { x: 1000, y: 100 },
        { x: 100, y: 500 },
        { x: 1000, y: 500 }
      ];
      
      const controlSchemes = [
        { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' },
        { up: 'w', down: 's', left: 'a', right: 'd' },
        { up: 't', down: 'g', left: 'f', right: 'h' },
        { up: 'i', down: 'k', left: 'j', right: 'l' }
      ];
      
      // Create human players
      for (let i = 0; i < numPlayers; i++) {
        players.push({ 
          x: startPositions[i].x, 
          y: startPositions[i].y, 
          vx: 0, 
          vy: 0, 
          w: 30, 
          h: 30, 
          color: colors[i], 
          isIt: false, 
          controls: controlSchemes[i],
          canDoubleJump: false,
          jumps: 0,
          lastJumpTime: 0
        });
      }
      
      // Add smart circle if robot mode is enabled
      if (robotMode) {
        smartCircle = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: 0,
          vy: 0,
          radius: 12,
          speed: 3.5, // Set to 3.5 for optimal balance
          isIt: false,
          color: 'orange',
          targetCooldown: 0
        };
      }
      
      // Randomly assign who is "it"
      const totalEntities = players.length + (robotMode ? 1 : 0);
      const randomIndex = Math.floor(Math.random() * totalEntities);
      
      if (randomIndex < players.length) {
        players[randomIndex].isIt = true;
      } else if (robotMode && smartCircle) {
        smartCircle.isIt = true;
      }
      
      spawnTeleporters();
      
      // Start countdown
      let countdown = 3;
      countdownDisplay.style.display = 'block';
      countdownDisplay.textContent = countdown;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          countdownDisplay.textContent = countdown;
        } else {
          clearInterval(countdownInterval);
          countdownDisplay.textContent = "GO!";
          setTimeout(() => {
            countdownDisplay.style.display = 'none';
            gameStarted = true;
            gameLoop();
          }, 500);
        }
      }, 1000);
    }

    function spawnTeleporters() {
      const accessiblePositions = [
        { x: 150, y: 300 },
        { x: 1050, y: 300 },
        { x: 600, y: 200 },
        { x: 600, y: 400 },
        { x: 350, y: 200 },
        { x: 850, y: 200 }
      ];
      
      const index1 = Math.floor(Math.random() * accessiblePositions.length);
      let index2;
      do {
        index2 = Math.floor(Math.random() * accessiblePositions.length);
      } while (index2 === index1);
      
      const pos1 = accessiblePositions[index1];
      const pos2 = accessiblePositions[index2];
      
      teleporters = [
        { x: pos1.x, y: pos1.y, radius: 12, active: true },
        { x: pos2.x, y: pos2.y, radius: 12, active: true }
      ];
    }

    // Power-up functions
    function spawnPowerUp(type) {
      // Find a random platform to spawn the power-up on
      const platform = currentPlatforms[Math.floor(Math.random() * currentPlatforms.length)];
      
      // Calculate position on the platform
      const x = platform.x + Math.random() * (platform.w - 20);
      const y = platform.y - 15; // Above the platform
      
      if (type === 'immunity') {
        powerUps.push({
          type: 'immunity',
          x: x,
          y: y,
          width: 20,
          height: 20,
          color: '#3498db', // Blue
          spawnTime: frameCount,
          active: true
        });
      } else if (type === 'timeSlow') {
        powerUps.push({
          type: 'timeSlow',
          x: x,
          y: y,
          radius: 10,
          color: '#9b59b6', // Purple
          spawnTime: frameCount,
          active: true
        });
      } else if (type === 'speedBoost') {
        powerUps.push({
          type: 'speedBoost',
          x: x,
          y: y,
          width: 20,
          height: 20,
          color: '#2ecc71', // Green
          spawnTime: frameCount,
          active: true
        });
      }
    }

    function updatePowerUps() {
      if (!gameStarted || gamePaused || !bluffsEnabled) return;
      
      // Update spawn timers
      immunitySpawnTimer++;
      timeSlowSpawnTimer++;
      speedBoostSpawnTimer++;
      
      // Spawn immunity power-up every 15 seconds (900 frames)
      if (immunitySpawnTimer >= 900) {
        spawnPowerUp('immunity');
        immunitySpawnTimer = 0;
      }
      
      // Spawn time slow power-up every 20 seconds (1200 frames)
      if (timeSlowSpawnTimer >= 1200) {
        spawnPowerUp('timeSlow');
        timeSlowSpawnTimer = 0;
      }
      
      // Spawn speed boost power-up every 18 seconds (1080 frames)
      if (speedBoostSpawnTimer >= 1080) {
        spawnPowerUp('speedBoost');
        speedBoostSpawnTimer = 0;
      }
      
      // Remove power-ups that have been active for more than 5 seconds (300 frames)
      powerUps = powerUps.filter(powerUp => {
        return frameCount - powerUp.spawnTime < 300;
      });
      
      // Check for collisions with players
      for (let i = 0; i < powerUps.length; i++) {
        const powerUp = powerUps[i];
        
        for (const player of players) {
          if (detectPowerUpCollision(player, powerUp)) {
            applyPowerUp(player, powerUp);
            powerUps.splice(i, 1);
            i--;
            break;
          }
        }
        
        // Check for collision with smart circle
        if (smartCircle && detectSmartCirclePowerUpCollision(smartCircle, powerUp)) {
          // Smart circle only collects beneficial power-ups
          if ((powerUp.type === 'speedBoost' || powerUp.type === 'immunity') && 
              !smartCircle.isIt) {
            applyPowerUp(smartCircle, powerUp);
            powerUps.splice(i, 1);
            i--;
          }
        }
      }
      
      // Update active effects
      updateActiveEffects();
    }

    function detectPowerUpCollision(player, powerUp) {
      if (powerUp.type === 'immunity' || powerUp.type === 'speedBoost') {
        // Rectangle collision for immunity (shield) and speed boost
        return (
          player.x < powerUp.x + powerUp.width &&
          player.x + player.w > powerUp.x &&
          player.y < powerUp.y + powerUp.height &&
          player.y + player.h > powerUp.y
        );
      } else if (powerUp.type === 'timeSlow') {
        // Circle collision for time slow (clock)
        const dx = (player.x + player.w/2) - powerUp.x;
        const dy = (player.y + player.h/2) - powerUp.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < powerUp.radius + player.w/2;
      }
      return false;
    }

    function detectSmartCirclePowerUpCollision(smartCircle, powerUp) {
      if (powerUp.type === 'immunity' || powerUp.type === 'speedBoost') {
        // Rectangle-circle collision for immunity and speed boost
        const dx = smartCircle.x - Math.max(powerUp.x, Math.min(smartCircle.x, powerUp.x + powerUp.width));
        const dy = smartCircle.y - Math.max(powerUp.y, Math.min(smartCircle.y, powerUp.y + powerUp.height));
        return (dx * dx + dy * dy) < (smartCircle.radius * smartCircle.radius);
      } else if (powerUp.type === 'timeSlow') {
        // Circle-circle collision for time slow
        const dx = smartCircle.x - powerUp.x;
        const dy = smartCircle.y - powerUp.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < smartCircle.radius + powerUp.radius;
      }
      return false;
    }

    function applyPowerUp(entity, powerUp) {
      if (powerUp.type === 'immunity') {
        // Grant immunity for 5 seconds (300 frames)
        activeEffects.immunity.push({
          entity: entity,
          endTime: frameCount + 300
        });
      } else if (powerUp.type === 'timeSlow') {
        // Slow down all non-"it" players at the moment of collection for 5 seconds
        const slowedPlayers = [];
        for (const player of players) {
          if (!player.isIt) {
            slowedPlayers.push(player);
          }
        }
        if (smartCircle && !smartCircle.isIt) {
          slowedPlayers.push(smartCircle);
        }
        
        activeEffects.timeSlow = {
          active: true,
          endTime: frameCount + 300,
          slowedPlayers: slowedPlayers
        };
      } else if (powerUp.type === 'speedBoost') {
        // Grant speed boost for 5 seconds (300 frames)
        activeEffects.speedBoost.push({
          entity: entity,
          endTime: frameCount + 300
        });
      }
    }

    function updateActiveEffects() {
      // Update immunity effects
      activeEffects.immunity = activeEffects.immunity.filter(effect => {
        return frameCount < effect.endTime;
      });
      
      // Update time slow effect
      if (activeEffects.timeSlow.active && frameCount >= activeEffects.timeSlow.endTime) {
        activeEffects.timeSlow.active = false;
        activeEffects.timeSlow.slowedPlayers = [];
      }
      
      // Update speed boost effects
      activeEffects.speedBoost = activeEffects.speedBoost.filter(effect => {
        return frameCount < effect.endTime;
      });
    }

    function hasImmunity(entity) {
      return activeEffects.immunity.some(effect => effect.entity === entity);
    }

    function isPlayerSlowed(player) {
      if (!activeEffects.timeSlow.active) return false;
      return activeEffects.timeSlow.slowedPlayers.includes(player);
    }

    function isSmartCircleSlowed() {
      if (!activeEffects.timeSlow.active || !smartCircle) return false;
      return activeEffects.timeSlow.slowedPlayers.includes(smartCircle);
    }

    function hasSpeedBoost(entity) {
      return activeEffects.speedBoost.some(effect => effect.entity === entity);
    }

    function drawPowerUps() {
      if (!bluffsEnabled) return;
      
      powerUps.forEach(powerUp => {
        if (powerUp.type === 'immunity') {
          // Draw shield shape (diamond)
          ctx.fillStyle = powerUp.color;
          ctx.beginPath();
          ctx.moveTo(powerUp.x + powerUp.width/2, powerUp.y);
          ctx.lineTo(powerUp.x + powerUp.width, powerUp.y + powerUp.height/2);
          ctx.lineTo(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height);
          ctx.lineTo(powerUp.x, powerUp.y + powerUp.height/2);
          ctx.closePath();
          ctx.fill();
          
          // Add glow effect
          ctx.shadowColor = powerUp.color;
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (powerUp.type === 'timeSlow') {
          // Draw clock shape
          ctx.fillStyle = powerUp.color;
          ctx.beginPath();
          ctx.arc(powerUp.x, powerUp.y, powerUp.radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw clock hands
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(powerUp.x, powerUp.y);
          ctx.lineTo(powerUp.x, powerUp.y - powerUp.radius/2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(powerUp.x, powerUp.y);
          ctx.lineTo(powerUp.x + powerUp.radius/2, powerUp.y);
          ctx.stroke();
          
          // Add glow effect
          ctx.shadowColor = powerUp.color;
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (powerUp.type === 'speedBoost') {
          // Draw lightning bolt shape
          ctx.fillStyle = powerUp.color;
          ctx.beginPath();
          ctx.moveTo(powerUp.x + powerUp.width/2, powerUp.y);
          ctx.lineTo(powerUp.x + powerUp.width/3, powerUp.y + powerUp.height/2);
          ctx.lineTo(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2);
          ctx.lineTo(powerUp.x + powerUp.width/3, powerUp.y + powerUp.height);
          ctx.lineTo(powerUp.x + powerUp.width*2/3, powerUp.y + powerUp.height/2);
          ctx.lineTo(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2);
          ctx.closePath();
          ctx.fill();
          
          // Add glow effect
          ctx.shadowColor = powerUp.color;
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      });
    }

    function updateSmartCircle() {
      if (!smartCircle || !gameStarted || gamePaused) return;
      
      if (smartCircle.targetCooldown > 0) smartCircle.targetCooldown--;
      
      let target = null;
      let minDistance = Infinity;
      
      // Apply speed boost to smart circle if active
      const speedMultiplier = hasSpeedBoost(smartCircle) ? 1.5 : 1;
      const currentSpeed = smartCircle.speed * speedMultiplier;
      
      // Apply time slow effect to smart circle if active
      const timeSlowMultiplier = isSmartCircleSlowed() ? 0.5 : 1;
      const finalSpeed = currentSpeed * timeSlowMultiplier;
      
      // Check for nearby beneficial power-ups if it's safe and not "it"
      if (!smartCircle.isIt && powerUps.length > 0 && bluffsEnabled) {
        const itPlayer = players.find(p => p && p.isIt);
        let safeToCollect = true;
        
        // Check if it's safe to collect power-ups (no "it" player nearby)
        if (itPlayer) {
          const dx = itPlayer.x + itPlayer.w/2 - smartCircle.x;
          const dy = itPlayer.y + itPlayer.h/2 - smartCircle.y;
          const distanceToIt = Math.sqrt(dx * dx + dy * dy);
          
          // If "it" player is too close, don't go for power-ups
          if (distanceToIt < 200) {
            safeToCollect = false;
          }
        }
        
        // If safe, find the closest beneficial power-up (only speed boost and immunity)
        if (safeToCollect) {
          for (const powerUp of powerUps) {
            // Smart circle only collects beneficial power-ups (not time slow)
            if (powerUp.type === 'timeSlow') continue;
            
            const dx = powerUp.x - smartCircle.x;
            const dy = powerUp.y - smartCircle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minDistance) {
              minDistance = distance;
              target = { x: powerUp.x, y: powerUp.y };
            }
          }
        }
      }
      
      // If no power-up target or not safe, use normal behavior
      if (!target) {
        if (smartCircle.isIt) {
          // Smart circle is "it" - chase nearest player
          for (const player of players) {
            if (player && typeof player.x !== 'undefined' && typeof player.y !== 'undefined') {
              const dx = player.x + player.w/2 - smartCircle.x;
              const dy = player.y + player.h/2 - smartCircle.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance < minDistance) {
                minDistance = distance;
                target = { x: player.x + player.w/2, y: player.y + player.h/2 };
              }
            }
          }
        } else {
          // Smart circle is not "it" - avoid the "it" player
          const itPlayer = players.find(p => p && p.isIt);
          if (itPlayer && typeof itPlayer.x !== 'undefined' && typeof itPlayer.y !== 'undefined') {
            const dx = itPlayer.x + itPlayer.w/2 - smartCircle.x;
            const dy = itPlayer.y + itPlayer.h/2 - smartCircle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 200) {
              // Move away from "it" player
              target = { 
                x: smartCircle.x - dx, 
                y: smartCircle.y - dy 
              };
            } else {
              // Move randomly when safe
              if (smartCircle.targetCooldown <= 0) {
                target = {
                  x: Math.random() * canvas.width,
                  y: Math.random() * canvas.height
                };
                smartCircle.targetCooldown = 120; // Change direction every 2 seconds
              }
            }
          }
        }
      }
      
      if (target) {
        const dx = target.x - smartCircle.x;
        const dy = target.y - smartCircle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          smartCircle.vx = (dx / distance) * finalSpeed;
          smartCircle.vy = (dy / distance) * finalSpeed;
        }
      }
      
      smartCircle.x += smartCircle.vx;
      smartCircle.y += smartCircle.vy;
      
      // Keep smart circle within bounds
      smartCircle.x = Math.max(smartCircle.radius, Math.min(canvas.width - smartCircle.radius, smartCircle.x));
      smartCircle.y = Math.max(smartCircle.radius, Math.min(canvas.height - smartCircle.radius, smartCircle.y));
      
      // Handle teleporter collision for smart circle
      if (teleporters && teleporters.length >= 2 && teleporters[0].active && teleporters[1].active) {
        for (let i = 0; i < teleporters.length; i++) {
          const tp = teleporters[i];
          if (tp && typeof tp.x !== 'undefined' && typeof tp.y !== 'undefined') {
            const dx = smartCircle.x - tp.x;
            const dy = smartCircle.y - tp.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < tp.radius + smartCircle.radius) {
              const targetTp = teleporters[1 - i];
              if (targetTp && typeof targetTp.x !== 'undefined' && typeof targetTp.y !== 'undefined') {
                smartCircle.x = targetTp.x;
                smartCircle.y = targetTp.y;
                
                smartCircle.vx = (Math.random() - 0.5) * 4;
                smartCircle.vy = (Math.random() - 0.5) * 4;
                
                teleporters[0].active = false;
                teleporters[1].active = false;
                teleportCooldown = frameCount;
                break;
              }
            }
          }
        }
      }
    }

    function updatePlayer(p) {
      if (!gameStarted || gamePaused) return;
      
      // Apply time slow effect if active
      const timeSlowMultiplier = isPlayerSlowed(p) ? 0.5 : 1;
      
      // Apply speed boost effect if active
      const speedBoostMultiplier = hasSpeedBoost(p) ? 1.5 : 1;
      
      // Combined speed multiplier
      const speedMultiplier = timeSlowMultiplier * speedBoostMultiplier;
      
      // Handle human player movement
      if (keys[p.controls.left]) p.vx = -4 * speedMultiplier;
      else if (keys[p.controls.right]) p.vx = 4 * speedMultiplier;
      else p.vx = 0;

      // Handle jumping and double jumping
      const currentTime = Date.now();
      const jumpKey = p.controls.up;
      
      // Reset jumps when grounded
      if (isGrounded(p)) {
        p.jumps = 0;
        p.canDoubleJump = true;
      }
      
      // Check for jump input
      if (keyState[jumpKey] && keyState[jumpKey].justPressed) {
        // First jump (on ground)
        if (p.jumps === 0 && isGrounded(p)) {
          p.vy = -10;
          p.jumps = 1;
          p.lastJumpTime = currentTime;
          keyState[jumpKey].justPressed = false; // Consume the key press
        }
        // Double jump (in air, within 700ms of first jump)
        else if (p.jumps === 1 && p.canDoubleJump && (currentTime - p.lastJumpTime) <= 700) {
          p.vy = -10;
          p.jumps = 2;
          p.canDoubleJump = false;
          keyState[jumpKey].justPressed = false; // Consume the key press
        }
      }

      p.vy += gravity;
      p.x += p.vx;
      p.y += p.vy;

      // Ground collision
      if (p.y + p.h > canvas.height) {
        p.y = canvas.height - p.h;
        p.vy = 0;
      }

      // Platform collision
      currentPlatforms.forEach(pl => {
        if (p.vy >= 0 && 
            p.x < pl.x + pl.w &&
            p.x + p.w > pl.x &&
            p.y + p.h >= pl.y &&
            p.y + p.h <= pl.y + pl.h + 5) {
          p.y = pl.y - p.h;
          p.vy = 0;
        }
        
        if (p.vy < 0 && 
            p.x < pl.x + pl.w &&
            p.x + p.w > pl.x &&
            p.y <= pl.y + pl.h &&
            p.y + p.h >= pl.y) {
          p.y = pl.y + pl.h;
          p.vy = 0;
        }
        
        if (p.x + p.w > pl.x && p.x < pl.x + pl.w &&
            p.y + p.h > pl.y && p.y < pl.y + pl.h) {
          if (p.vx > 0) {
            p.x = pl.x - p.w;
          } else if (p.vx < 0) {
            p.x = pl.x + pl.w;
          }
        }
      });

      // Bounce pad
      if (p.x < bouncePad.x + bouncePad.w &&
          p.x + p.w > bouncePad.x &&
          p.y + p.h >= bouncePad.y &&
          p.y + p.h <= bouncePad.y + bouncePad.h + 5) {
        p.vy = -20;
      }

      // Teleporters
      if (teleporters[0].active && teleporters[1].active) {
        for (let i = 0; i < teleporters.length; i++) {
          const tp = teleporters[i];
          const dx = (p.x + p.w/2) - tp.x;
          const dy = (p.y + p.h/2) - tp.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < tp.radius + p.w/2) {
            const target = teleporters[1 - i];
            p.x = target.x - p.w/2;
            p.y = target.y - p.h/2;
            
            p.vx = (Math.random() - 0.5) * 4;
            p.vy = -2;
            
            teleporters[0].active = false;
            teleporters[1].active = false;
            teleportCooldown = frameCount;
            break;
          }
        }
      }

      // Keep inside canvas
      p.x = Math.max(0, Math.min(canvas.width - p.w, p.x));
      p.y = Math.min(canvas.height - p.h, p.y);
    }

    function isGrounded(p) {
      return (
        p.y + p.h >= canvas.height ||
        currentPlatforms.some(pl =>
          p.x < pl.x + pl.w &&
          p.x + p.w > pl.x &&
          p.y + p.h >= pl.y &&
          p.y + p.h <= pl.y + pl.h + 5
        )
      );
    }

    function detectPlayerTag(p1, p2) {
      // Only check immunity for the player being tagged (p2), not the one who is "it" (p1)
      if (hasImmunity(p2)) return false;
      
      return (
        p1.x < p2.x + p2.w &&
        p1.x + p1.w > p2.x &&
        p1.y < p2.y + p2.h &&
        p1.y + p1.h > p2.y
      );
    }

    function detectCirclePlayerTag(circle, player) {
      if (!circle || !player || typeof circle.x === 'undefined' || typeof player.x === 'undefined') {
        return false;
      }
      
      // Only check immunity for the player being tagged, not the circle that is "it"
      if (hasImmunity(player)) return false;
      
      const dx = (player.x + player.w/2) - circle.x;
      const dy = (player.y + player.h/2) - circle.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < circle.radius + player.w/2;
    }

    function drawTagIndicator(entity) {
      let orbX, orbY;
      if (entity.radius) { // Smart circle
        orbX = entity.x;
        orbY = entity.y - 20;
      } else { // Player
        orbX = entity.x + entity.w / 2;
        orbY = entity.y - 12;
      }
      
      ctx.beginPath();
      ctx.arc(orbX, orbY, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'gold';
      ctx.shadowColor = 'gold';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function showGameOver() {
      let winner = '';
      const itPlayer = players.find(p => p.isIt);
      
      if (itPlayer) {
        winner = `${itPlayer.color.toUpperCase()} player was IT!`;
      } else if (smartCircle && smartCircle.isIt) {
        winner = 'SMART CIRCLE was IT!';
      }
      
      winnerText.textContent = winner;
      gameOverDisplay.style.display = 'block';
    }

    function drawPlatforms() {
      // Draw platforms
      currentPlatforms.forEach(pl => {
        ctx.fillStyle = '#8a5c36';
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(pl.x, pl.y, pl.w, 4);
      });

      // Draw bounce pad
      ctx.fillStyle = '#00c853';
      ctx.fillRect(bouncePad.x, bouncePad.y, bouncePad.w, bouncePad.h);
      for (let i = 0; i < bouncePad.w; i += 8) {
        ctx.fillStyle = '#009624';
        ctx.fillRect(bouncePad.x + i, bouncePad.y, 4, bouncePad.h);
      }
    }

    function drawPlayers() {
      players.forEach(p => {
        // Draw player shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(p.x + 3, p.y + 3, p.w, p.h);
        
        // Draw immunity effect if active
        if (hasImmunity(p)) {
          ctx.strokeStyle = '#3498db';
          ctx.lineWidth = 3;
          ctx.strokeRect(p.x - 2, p.y - 2, p.w + 4, p.h + 4);
        }
        
        // Draw speed boost effect if active
        if (hasSpeedBoost(p)) {
          ctx.strokeStyle = '#2ecc71';
          ctx.lineWidth = 3;
          ctx.strokeRect(p.x - 2, p.y - 2, p.w + 4, p.h + 4);
        }
        
        // Draw player
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // Draw player details
        ctx.fillStyle = '#000';
        ctx.fillRect(p.x + 8, p.y + 8, 6, 6);
        ctx.fillRect(p.x + p.w - 14, p.y + 8, 6, 6);
        
        if (p.isIt) drawTagIndicator(p);
      });
    }

    function drawSmartCircle() {
      if (!smartCircle) return;
      
      // Draw shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.arc(smartCircle.x + 2, smartCircle.y + 2, smartCircle.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw immunity effect if active
      if (hasImmunity(smartCircle)) {
        ctx.strokeStyle = '#3498db';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(smartCircle.x, smartCircle.y, smartCircle.radius + 2, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Draw speed boost effect if active
      if (hasSpeedBoost(smartCircle)) {
        ctx.strokeStyle = '#2ecc71';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(smartCircle.x, smartCircle.y, smartCircle.radius + 2, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Draw circle
      ctx.fillStyle = smartCircle.color;
      ctx.beginPath();
      ctx.arc(smartCircle.x, smartCircle.y, smartCircle.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw inner details
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(smartCircle.x - 4, smartCircle.y - 4, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(smartCircle.x + 4, smartCircle.y - 4, 2, 0, Math.PI * 2);
      ctx.fill();
      
      if (smartCircle.isIt) drawTagIndicator(smartCircle);
    }

    function drawTeleporters() {
      teleporters.forEach(tp => {
        if (tp.active) {
          // Draw glow effect
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius + 3, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 15;
          ctx.fill();
          
          // Draw teleporter
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ffeb3b';
          ctx.fill();
          
          // Draw inner circle
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius / 2, 0, Math.PI * 2);
          ctx.fillStyle = '#ffc107';
          ctx.fill();
          
          ctx.shadowBlur = 0;
        }
      });
    }

    function gameLoop() {
      if (gameOver) {
        showGameOver();
        return;
      }
      
      if (gamePaused) {
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      frameCount++;

      drawPlatforms();

      // Respawn teleporters
      if (!teleporters[0].active && frameCount - teleportCooldown > 300) {
        spawnTeleporters();
      }

      drawTeleporters();

      // Update and draw power-ups
      updatePowerUps();
      drawPowerUps();

      // Update and draw players
      players.forEach(p => {
        updatePlayer(p);
      });
      drawPlayers();

      // Update smart circle
      updateSmartCircle();
      drawSmartCircle();

      // Tag logic between players
      const itPlayer = players.find(p => p.isIt);
      
      if (itPlayer) {
        const otherPlayers = players.filter(p => !p.isIt);

        for (const otherPlayer of otherPlayers) {
          if (detectPlayerTag(itPlayer, otherPlayer) && Date.now() - lastTagTime > 1000) {
            itPlayer.isIt = false;
            otherPlayer.isIt = true;
            lastTagTime = Date.now();
            break;
          }
        }
      }

      // Tag logic with smart circle
      if (smartCircle) {
        if (smartCircle.isIt) {
          // Smart circle tags players
          for (const player of players) {
            if (player && detectCirclePlayerTag(smartCircle, player) && Date.now() - lastTagTime > 1000) {
              smartCircle.isIt = false;
              player.isIt = true;
              lastTagTime = Date.now();
              break;
            }
          }
        } else {
          // Players tag smart circle
          for (const player of players) {
            if (player && player.isIt && detectCirclePlayerTag(smartCircle, player) && Date.now() - lastTagTime > 1000) {
              player.isIt = false;
              smartCircle.isIt = true;
              lastTagTime = Date.now();
              break;
            }
          }
        }
      }

      // Timer
      if (frameCount % 60 === 0 && timer > 0) {
        timer--;
        ui.textContent = `Time: ${timer}`;
      }

      if (timer === 0 && !gameOver) {
        gameOver = true;
      }

      animationId = requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
