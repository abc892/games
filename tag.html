<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Arena Tag Showdown</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .game-container {
      position: relative;
    }
    canvas {
      display: block;
      border: 4px solid #fff;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 150px;
      font-size: 18px;
      color: #fff;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 20px;
    }
    #home-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: #0077cc;
      color: white;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 16px;
      transition: 0.3s;
      z-index: 15;
      display: block;
      border: none;
      cursor: pointer;
    }
    #home-btn:hover {
      background: #005fa3;
    }
    #pause-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      z-index: 10;
      font-size: 18px;
    }
    #pause-btn:hover {
      background: rgba(0, 0, 0, 0.7);
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      color: #fff;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 20;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      border: 2px solid gold;
    }
    #setup-screen, #time-setup, #mode-select-screen, #name-screen, #lobby-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 30;
      color: white;
      width: 400px;
    }
    #lobby-screen {
      width: 500px;
    }
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      color: rgba(255, 255, 255, 0.7);
      z-index: 25;
      display: none;
    }
    #pause-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 40;
      color: white;
      width: 300px;
      display: none;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      border: 2px solid #4CAF50;
    }
    button {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 10px 5px;
      cursor: pointer;
      border-radius: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .toggle-btn {
      background: #555;
    }
    .toggle-btn.active {
      background: #4CAF50;
    }
    .back-btn {
      background: #f44336;
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 15px;
      font-size: 14px;
    }
    .back-btn:hover {
      background: #d32f2f;
    }
    input {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: 1px solid #ccc;
      margin: 10px 0;
      width: 200px;
    }
    .mode-container {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #444;
    }
    .background-options {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    .background-option {
      width: 120px;
      height: 80px;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .background-option.selected {
      border-color: #4CAF50;
      box-shadow: 0 0 10px #4CAF50;
    }
    .background-option:hover {
      transform: scale(1.05);
    }
    .bluffs-container {
      margin: 20px 0;
      padding: 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
    }
    .retry-btn {
      background: #FF9800;
      font-size: 18px;
      padding: 12px 25px;
      margin-top: 15px;
    }
    .retry-btn:hover {
      background: #F57C00;
    }
    .lobby-code {
      text-align: center;
      font-size: 36px;
      color: #ffd93d;
      background: rgba(255, 217, 61, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      border: 2px solid #ffd93d;
      letter-spacing: 8px;
    }
    .player-list {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 20px;
    }
    .player-entry {
      display: flex;
      justify-content: space-between;
      padding: 18px;
      margin: 8px 0;
      background: rgba(0, 255, 136, 0.1);
      border: 2px solid #00ff88;
      border-radius: 8px;
      color: #00ff88;
      font-size: 16px;
    }
    .player-entry.ready {
      background: rgba(0, 255, 136, 0.3);
      border-color: #00ff88;
    }
    .player-entry.current-user {
      background: rgba(255, 215, 0, 0.15);
      border-color: #ffd700;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <button id="home-btn" style="display: none;">üè† Home</button>
    <div id="ui" style="display: none;">Time: 0</div>
    <button id="pause-btn" style="display: none;">Pause</button>
    
    <div id="gameOver">
      <h2>Game Over!</h2>
      <div id="winner-text" style="color:gold; font-weight:bold; margin: 20px 0; font-size: 24px;"></div>
      <div style="margin: 20px 0;">
        <p>Returning to lobby...</p>
        <button class="retry-btn" id="gameOverBtn">üîô Back to Lobby</button>
      </div>
    </div>
    
    <div id="countdown"></div>
    
    <div id="pause-menu">
      <h2>Game Paused</h2>
      <button id="resumeBtn">Resume Game</button>
      <button id="leaveBtn">Leave Game</button>
    </div>
    
    <!-- Name Entry Screen -->
    <div id="name-screen">
      <h2>Welcome to Arena Tag!</h2>
      <p>Enter your name to continue</p>
      <input type="text" id="nameInput" placeholder="Your Name" maxlength="20">
      <button id="nameSubmitBtn">Continue</button>
    </div>
    
    <!-- Mode Selection Screen -->
    <div id="mode-select-screen" style="display: none;">
      <h2>Select Game Mode</h2>
      <p style="color: #00ff88;">Welcome, <span id="playerNameDisplay"></span>!</p>
      <button id="soloBtn">Solo/Local Multiplayer</button>
      <button id="onlineBtn">Create Online Lobby</button>
      <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #444;">
        <h3>Join Existing Lobby</h3>
        <input type="text" id="joinCodeInputMain" placeholder="Enter 6-digit code" maxlength="6" style="width: 200px;">
        <button id="joinLobbyBtnMain">Join Lobby</button>
      </div>
    </div>
    
    <!-- Setup Screen (Solo/Local) -->
    <div id="setup-screen" style="display: none;">
      <h2>Select Number of Players</h2>
      <button class="player-btn" data-players="1">1 Player</button>
      <button class="player-btn" data-players="2">2 Players</button>
      <button class="player-btn" data-players="3">3 Players</button>
      <button class="player-btn" data-players="4">4 Players</button>
      
      <div class="mode-container">
        <h3>Robot Mode</h3>
        <button id="robot-toggle" class="toggle-btn">OFF</button>
        <p>Adds a smart circle that seeks or avoids players</p>
      </div>
      <button class="back-btn" id="setupBackBtn">Back</button>
    </div>
    
    <!-- Time Setup Screen (Solo/Local) -->
    <div id="time-setup" style="display: none;">
      <button class="back-btn" id="timeBackBtn">Back</button>
      <h2>Game Setup</h2>
      
      <div>
        <h3>Time Limit (Seconds)</h3>
        <input type="number" id="time-input" min="10" max="300" value="30" style="width: 100px;">
      </div>
      
      <div>
        <h3>Select Background</h3>
        <div class="background-options">
          <div class="background-option selected" style="background: linear-gradient(135deg, #ff6ec4, #7873f5);" data-bg="1"></div>
          <div class="background-option" style="background: linear-gradient(135deg, #667eea, #764ba2);" data-bg="2"></div>
          <div class="background-option" style="background: linear-gradient(135deg, #f093fb, #f5576c);" data-bg="3"></div>
        </div>
      </div>
      
      <div class="bluffs-container">
        <h3>Power-ups (Bluffs)</h3>
        <button id="bluffs-toggle" class="toggle-btn active">ON</button>
        <p>Enable or disable power-ups during gameplay</p>
      </div>
      
      <button id="startGameBtn">Start Game</button>
    </div>
    
    <!-- Lobby Screen -->
    <div id="lobby-screen" style="display: none;">
      <h2>Lobby</h2>
      <div class="lobby-code" id="lobbyCode">------</div>
      <div style="margin-bottom: 15px; color: #00d4aa;">Share this code with friends!</div>
      
      <div style="margin: 15px 0;">
        <label style="color: #fff; font-size: 16px;">Game Duration (seconds):</label>
        <input type="number" id="lobby-time-input" min="10" max="300" value="30" style="width: 80px; margin-left: 10px;">
      </div>
      
      <div class="player-list" id="playerList"></div>
      
      <div style="margin-top: 20px;">
        <button id="readyBtn">READY</button>
        <button id="createLobbyBtn" style="display: none;">Create New Lobby</button>
        <button id="joinLobbyBtn" style="display: none;">Join Lobby</button>
        <input type="text" id="joinCodeInput" placeholder="Enter 6-digit code" maxlength="6" style="width: 200px; display: none;">
      </div>
      
      <button class="back-btn" style="position: relative; left: 0; top: 0; margin-top: 10px;" id="leaveLobbyBtn">Leave Lobby</button>
    </div>
    
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  
  <script>
    console.log('üéÆ Arena Tag initializing...');
    
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAwEy-sJx7E61BA6VmBfIFMZsjuAj8RK5g",
      authDomain: "games-c3e27.firebaseapp.com",
      databaseURL: "https://games-c3e27-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "games-c3e27",
      storageBucket: "games-c3e27.firebasestorage.app",
      messagingSenderId: "193027632069",
      appId: "1:193027632069:web:b559c3b10011bc6982b9ac"
    };
    
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    console.log('‚úÖ Firebase initialized');

    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const keys = {};
    const keyState = {};
    
    let playerName = '';
    let userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    let players = [];
    let smartCircle = null;
    let numPlayers = 2;
    let gameStarted = false;
    let robotMode = false;
    let gamePaused = false;
    let selectedBackground = 1;
    let bluffsEnabled = true;
    let currentPlatforms = [];
    let currentLobby = null;
    let lobbyListener = null;
    let timerListener = null;
    let otherPlayers = {};
    let playerRef = null;
    let timer = 0;
    let frameCount = 0;
    let gameOver = false;
    let animationId = null;
    let teleporters = [];
    let teleportCooldown = 0;
    let lastTagTime = 0;
    let tagCooldowns = {}; // Track cooldown between specific player pairs
    let currentlyTouching = {}; // Track which players are currently in contact
    let isHost = false;
    let isTabVisible = true;

    const gravity = 0.5;
    const PLAYER_COLORS = ['red', 'green', 'blue', 'yellow', 'purple', 'orange', 'cyan', 'magenta', 'lime', 'pink'];
    
    const basePlatforms = [
      { x: 100, y: 550, w: 80, h: 15 }, { x: 250, y: 500, w: 70, h: 15 },
      { x: 400, y: 450, w: 80, h: 15 }, { x: 550, y: 500, w: 70, h: 15 },
      { x: 700, y: 550, w: 80, h: 15 }, { x: 850, y: 500, w: 70, h: 15 },
      { x: 1000, y: 450, w: 80, h: 15 }, { x: 200, y: 350, w: 70, h: 15 },
      { x: 400, y: 300, w: 80, h: 15 }, { x: 600, y: 350, w: 70, h: 15 },
      { x: 800, y: 300, w: 80, h: 15 }, { x: 1000, y: 350, w: 70, h: 15 },
      { x: 300, y: 200, w: 80, h: 15 }, { x: 500, y: 150, w: 70, h: 15 },
      { x: 700, y: 200, w: 80, h: 15 }, { x: 900, y: 150, w: 70, h: 15 },
      { x: 200, y: 620, w: 90, h: 15 }, { x: 900, y: 620, w: 90, h: 15 }
    ];
    
    const bouncePad = { x: 30, y: 650, w: 50, h: 12 };

    // Tab visibility detection
    document.addEventListener('visibilitychange', function() {
      isTabVisible = !document.hidden;
      
      if (!isTabVisible && currentLobby) {
        // User switched tab - unready them
        database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).once('value', (snapshot) => {
          if (snapshot.exists() && snapshot.val().ready) {
            database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).update({ ready: false });
            const readyBtn = document.getElementById('readyBtn');
            if (readyBtn) {
              readyBtn.textContent = 'READY';
              readyBtn.disabled = false;
            }
          }
        });
      }
    });

    // Keyboard events
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (!keyState[e.key]) {
        keyState[e.key] = { pressed: true, justPressed: true };
      } else {
        keyState[e.key].justPressed = true;
      }
    });
    
    document.addEventListener('keyup', e => {
      keys[e.key] = false;
      if (keyState[e.key]) {
        keyState[e.key].justPressed = false;
      }
    });

    // Navigation functions
    function hideAllScreens() {
      ['name-screen', 'mode-select-screen', 'setup-screen', 'time-setup', 'lobby-screen'].forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('pause-menu').style.display = 'none';
    }

    function goToModeSelect() {
      hideAllScreens();
      document.getElementById('mode-select-screen').style.display = 'block';
      document.getElementById('playerNameDisplay').textContent = playerName;
      if (animationId) cancelAnimationFrame(animationId);
      gameStarted = false;
      gameOver = false;
    }

    // Name entry
    document.getElementById('nameSubmitBtn').addEventListener('click', () => {
      const name = document.getElementById('nameInput').value.trim();
      if (!name) {
        alert('Please enter your name!');
        return;
      }
      playerName = name;
      console.log('‚úÖ Player name set:', playerName);
      goToModeSelect();
    });

    document.getElementById('nameInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('nameSubmitBtn').click();
      }
    });

    // Mode selection
    document.getElementById('soloBtn').addEventListener('click', () => {
      hideAllScreens();
      document.getElementById('setup-screen').style.display = 'block';
    });

    document.getElementById('onlineBtn').addEventListener('click', () => {
      showLobbyCreation();
    });

    document.getElementById('joinLobbyBtnMain').addEventListener('click', () => {
      const code = document.getElementById('joinCodeInputMain').value.trim();
      if (code.length !== 6) {
        alert('Please enter a 6-digit lobby code!');
        return;
      }
      joinLobby(code);
    });

    document.getElementById('joinCodeInputMain').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('joinLobbyBtnMain').click();
      }
    });

    function joinLobby(code) {
      console.log('Joining lobby:', code);
      
      database.ref(`tagGame/lobbies/${code}`).once('value', (snapshot) => {
        if (!snapshot.exists()) {
          alert('Lobby not found! Please check the code.');
          return;
        }
        
        const lobby = snapshot.val();
        const playerCount = Object.keys(lobby.players || {}).length;
        
        if (playerCount >= 10) {
          alert('Lobby is full! (Maximum 10 players)');
          return;
        }
        
        currentLobby = code;
        isHost = false;
        
        const startPositions = [
          { x: 100, y: 100 }, { x: 1000, y: 100 }, { x: 100, y: 500 }, { x: 1000, y: 500 },
          { x: 550, y: 300 }, { x: 300, y: 200 }, { x: 800, y: 200 }, { x: 550, y: 500 },
          { x: 200, y: 350 }, { x: 900, y: 350 }
        ];
        const pos = startPositions[playerCount % startPositions.length];
        
        database.ref(`tagGame/lobbies/${code}/players/${userId}`).set({
          name: playerName,
          ready: false,
          color: PLAYER_COLORS[playerCount % PLAYER_COLORS.length],
          isIt: false,
          x: pos.x,
          y: pos.y,
          vx: 0,
          vy: 0
        }).then(() => {
          playerRef = database.ref(`tagGame/lobbies/${code}/players/${userId}`);
          playerRef.onDisconnect().remove();
          document.getElementById('joinCodeInputMain').value = '';
          showLobbyScreen(code);
        });
      });
    }

    function showLobbyCreation() {
      const lobbyCode = Math.floor(100000 + Math.random() * 900000).toString();
      currentLobby = lobbyCode;
      isHost = true;
      
      console.log('Creating lobby:', lobbyCode);
      
      database.ref(`tagGame/lobbies/${lobbyCode}`).set({
        code: lobbyCode,
        host: userId,
        createdAt: Date.now(),
        gameStarted: false,
        gameEnded: false,
        gameDuration: 30,
        timer: 30,
        players: {
          [userId]: {
            name: playerName,
            ready: false,
            color: PLAYER_COLORS[0],
            isIt: false,
            x: 100,
            y: 100,
            vx: 0,
            vy: 0
          }
        }
      }).then(() => {
        playerRef = database.ref(`tagGame/lobbies/${lobbyCode}/players/${userId}`);
        playerRef.onDisconnect().remove();
        showLobbyScreen(lobbyCode);
      });
    }

    // Player buttons
    document.querySelectorAll('.player-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        numPlayers = parseInt(btn.dataset.players);
        const robotToggle = document.getElementById('robot-toggle');
        
        if (numPlayers === 1) {
          robotMode = true;
          robotToggle.classList.add('active');
          robotToggle.textContent = 'ON';
          robotToggle.disabled = true;
          robotToggle.style.opacity = '0.6';
        } else {
          robotToggle.disabled = false;
          robotToggle.style.opacity = '1';
        }
        
        hideAllScreens();
        document.getElementById('time-setup').style.display = 'block';
      });
    });

    document.getElementById('setupBackBtn').addEventListener('click', goToModeSelect);
    document.getElementById('timeBackBtn').addEventListener('click', () => {
      hideAllScreens();
      document.getElementById('setup-screen').style.display = 'block';
      robotMode = false;
      const robotToggle = document.getElementById('robot-toggle');
      robotToggle.classList.remove('active');
      robotToggle.textContent = 'OFF';
      robotToggle.disabled = false;
      robotToggle.style.opacity = '1';
    });

    document.getElementById('home-btn').addEventListener('click', () => {
      if (currentLobby) {
        leaveLobby();
      }
      goToModeSelect();
    });

    document.getElementById('robot-toggle').addEventListener('click', function() {
      robotMode = !robotMode;
      this.classList.toggle('active', robotMode);
      this.textContent = robotMode ? 'ON' : 'OFF';
    });

    document.getElementById('bluffs-toggle').addEventListener('click', function() {
      bluffsEnabled = !bluffsEnabled;
      this.classList.toggle('active', bluffsEnabled);
      this.textContent = bluffsEnabled ? 'ON' : 'OFF';
    });

    document.querySelectorAll('.background-option').forEach(opt => {
      opt.addEventListener('click', function() {
        document.querySelectorAll('.background-option').forEach(o => o.classList.remove('selected'));
        this.classList.add('selected');
        selectedBackground = parseInt(this.dataset.bg);
      });
    });

    // Lobby functions
    function showLobbyScreen(code) {
      document.getElementById('lobbyCode').textContent = code;
      document.getElementById('readyBtn').disabled = false;
      document.getElementById('readyBtn').textContent = 'READY';
      
      hideAllScreens();
      document.getElementById('lobby-screen').style.display = 'block';
      
      // Listen for lobby updates
      lobbyListener = database.ref(`tagGame/lobbies/${code}`).on('value', (snapshot) => {
        if (!snapshot.exists()) {
          console.log('Lobby closed');
          alert('Lobby closed!');
          goToModeSelect();
          return;
        }
        
        const lobby = snapshot.val();
        console.log('Lobby update:', {
          gameStarted: lobby.gameStarted,
          gameEnded: lobby.gameEnded,
          timer: lobby.timer,
          currentGameStarted: gameStarted,
          currentGameOver: gameOver
        });
        
        updatePlayerList(lobby.players);
        document.getElementById('lobby-time-input').value = lobby.gameDuration || 30;
        
        // Game started
        if (lobby.gameStarted && !gameStarted && !lobby.gameEnded) {
          console.log('üéÆ Game starting...');
          startMultiplayerGame(lobby);
        }
        
        // Game ended - all players return to lobby
        if (lobby.gameEnded && gameStarted && !gameOver) {
          console.log('üèÅ Game ended signal received');
          endGameForAll();
        }
      });
      
      // Listen for timer updates during game
      timerListener = database.ref(`tagGame/lobbies/${code}/timer`).on('value', (snapshot) => {
        if (snapshot.exists() && gameStarted && !gameOver) {
          timer = snapshot.val();
          document.getElementById('ui').textContent = `Time: ${timer}`;
          
          console.log('Timer update from Firebase:', timer);
          
          // If timer hits 0, stop the game
          if (timer <= 0) {
            console.log('Timer is 0 - stopping game');
            gameOver = true;
            gameStarted = false;
            if (animationId) {
              cancelAnimationFrame(animationId);
              animationId = null;
            }
          }
        }
      });
    }

    function updatePlayerList(players) {
      const list = document.getElementById('playerList');
      list.innerHTML = '';
      
      Object.entries(players).forEach(([id, player]) => {
        const entry = document.createElement('div');
        const isCurrentUser = id === userId;
        entry.className = 'player-entry' + 
                         (player.ready ? ' ready' : '') +
                         (isCurrentUser ? ' current-user' : '');
        entry.innerHTML = `
          <span style="color: ${player.color}; font-weight: 700;">‚¨§ ${player.name}</span>
          <span style="font-weight: 700;">${player.ready ? '‚úì READY' : '‚úó NOT READY'}</span>
        `;
        list.appendChild(entry);
      });
    }

    document.getElementById('readyBtn').addEventListener('click', () => {
      if (!currentLobby) return;
      
      database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).once('value', (snapshot) => {
        if (!snapshot.exists()) return;
        
        const currentReady = snapshot.val().ready;
        database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).update({
          ready: !currentReady
        }).then(() => {
          document.getElementById('readyBtn').textContent = !currentReady ? 'UNREADY' : 'READY';
          checkAllReady();
        });
      });
    });

    document.getElementById('lobby-time-input').addEventListener('change', function() {
      if (!isHost || !currentLobby) return;
      
      database.ref(`tagGame/lobbies/${currentLobby}`).update({
        gameDuration: parseInt(this.value),
        timer: parseInt(this.value)
      });
    });

    function checkAllReady() {
      if (!isHost) return;
      
      database.ref(`tagGame/lobbies/${currentLobby}`).once('value', (snapshot) => {
        const lobby = snapshot.val();
        const players = lobby.players;
        const allReady = Object.values(players).every(p => p.ready);
        const playerCount = Object.keys(players).length;
        
        console.log('Check ready:', { allReady, playerCount });
        
        if (allReady && playerCount >= 2) {
          console.log('Starting game - all players ready!');
          
          const playerIds = Object.keys(players);
          const randomIndex = Math.floor(Math.random() * playerIds.length);
          const itPlayerId = playerIds[randomIndex];
          
          const updates = {};
          updates[`tagGame/lobbies/${currentLobby}/gameStarted`] = true;
          updates[`tagGame/lobbies/${currentLobby}/gameEnded`] = false;
          updates[`tagGame/lobbies/${currentLobby}/gameStartTime`] = Date.now();
          
          playerIds.forEach(id => {
            updates[`tagGame/lobbies/${currentLobby}/players/${id}/isIt`] = (id === itPlayerId);
            updates[`tagGame/lobbies/${currentLobby}/players/${id}/ready`] = false;
          });
          
          randomizePlatforms();
          updates[`tagGame/lobbies/${currentLobby}/platforms`] = currentPlatforms;
          
          database.ref().update(updates);
        }
      });
    }

    document.getElementById('leaveLobbyBtn').addEventListener('click', leaveLobby);

    function leaveLobby() {
      console.log('Leaving lobby...');
      
      if (currentLobby && playerRef) {
        // Remove player
        playerRef.remove().then(() => {
          // Check if lobby is empty
          database.ref(`tagGame/lobbies/${currentLobby}/players`).once('value', (snapshot) => {
            if (!snapshot.exists() || Object.keys(snapshot.val() || {}).length === 0) {
              // Delete empty lobby
              database.ref(`tagGame/lobbies/${currentLobby}`).remove();
              console.log('Deleted empty lobby');
            }
          });
        });
        
        // Remove listeners
        if (lobbyListener) {
          database.ref(`tagGame/lobbies/${currentLobby}`).off('value', lobbyListener);
          lobbyListener = null;
        }
        if (timerListener) {
          database.ref(`tagGame/lobbies/${currentLobby}/timer`).off('value', timerListener);
          timerListener = null;
        }
        
        playerRef = null;
        currentLobby = null;
        isHost = false;
      }
      
      goToModeSelect();
    }

    // Game start
    function startMultiplayerGame(lobby) {
      console.log('Starting multiplayer game...');
      
      if (lobbyListener) {
        database.ref(`tagGame/lobbies/${currentLobby}`).off('value', lobbyListener);
        lobbyListener = null;
      }
      
      timer = lobby.timer || lobby.gameDuration || 30;
      
      if (lobby.platforms) {
        currentPlatforms = lobby.platforms;
      } else {
        randomizePlatforms();
      }
      
      canvas.style.background = 'linear-gradient(135deg, #ff6ec4, #7873f5)';
      
      hideAllScreens();
      document.getElementById('ui').style.display = 'block';
      document.getElementById('home-btn').style.display = 'block';
      document.getElementById('ui').textContent = `Time: ${timer}`;
      
      const localPlayerData = lobby.players[userId];
      players = [{
        x: localPlayerData.x,
        y: localPlayerData.y,
        vx: 0,
        vy: 0,
        w: 30,
        h: 30,
        color: localPlayerData.color,
        isIt: localPlayerData.isIt,
        controls: { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' },
        jumps: 0,
        canDoubleJump: false,
        lastJumpTime: 0,
        isLocal: true
      }];
      
      gameStarted = false;
      gameOver = false;
      frameCount = 0;
      lastTagTime = 0;
      currentlyTouching = {}; // Reset contact tracking
      smartCircle = null;
      
      spawnTeleporters();
      
      // Listen for other players
      database.ref(`tagGame/lobbies/${currentLobby}/players`).on('value', (snapshot) => {
        if (!snapshot.exists()) return;
        
        otherPlayers = {};
        snapshot.forEach((child) => {
          if (child.key !== userId) {
            otherPlayers[child.key] = child.val();
          } else {
            players[0].isIt = child.val().isIt;
          }
        });
      });
      
      // Host manages timer
      if (isHost) {
        startHostTimer();
      }
      
      let countdown = 3;
      const countdownDisplay = document.getElementById('countdown');
      countdownDisplay.style.display = 'block';
      countdownDisplay.textContent = countdown;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          countdownDisplay.textContent = countdown;
        } else {
          clearInterval(countdownInterval);
          countdownDisplay.textContent = "GO!";
          setTimeout(() => {
            countdownDisplay.style.display = 'none';
            gameStarted = true;
            gameLoop();
          }, 500);
        }
      }, 1000);
    }

    let hostTimerInterval = null;

    function startHostTimer() {
      if (hostTimerInterval) clearInterval(hostTimerInterval);
      
      console.log('Host timer started, initial timer:', timer);
      
      hostTimerInterval = setInterval(() => {
        console.log('Host timer tick, current:', timer, 'gameStarted:', gameStarted, 'gameOver:', gameOver);
        
        if (gameStarted && !gameOver) {
          if (timer > 0) {
            timer--;
            console.log('Timer decremented to:', timer);
            database.ref(`tagGame/lobbies/${currentLobby}`).update({ timer });
          }
          
          if (timer <= 0) {
            console.log('Timer reached 0 - calling endGame()');
            clearInterval(hostTimerInterval);
            hostTimerInterval = null;
            endGame();
          }
        }
      }, 1000);
    }

    function endGame() {
      if (!isHost || !currentLobby) {
        console.log('endGame called but not host or no lobby');
        return;
      }
      
      console.log('Host ending game - setting gameEnded flag...');
      
      // Signal all players that game ended
      database.ref(`tagGame/lobbies/${currentLobby}`).update({
        gameStarted: false,
        gameEnded: true,
        timer: 0
      }).then(() => {
        console.log('‚úÖ Game ended signal sent to Firebase successfully');
      }).catch((error) => {
        console.error('‚ùå Error sending game ended signal:', error);
      });
      
      if (hostTimerInterval) {
        clearInterval(hostTimerInterval);
        hostTimerInterval = null;
      }
    }

    function endGameForAll() {
      console.log('Ending game for all players...');
      
      gameStarted = false;
      gameOver = true;
      
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      if (hostTimerInterval) {
        clearInterval(hostTimerInterval);
        hostTimerInterval = null;
      }
      
      // Stop listening to player updates during game over
      if (currentLobby) {
        database.ref(`tagGame/lobbies/${currentLobby}/players`).off('value');
      }
      
      // Find winner
      let winner = '';
      const itPlayer = players.find(p => p.isIt);
      
      if (itPlayer) {
        winner = `${playerName} (You) was IT!`;
      } else {
        Object.entries(otherPlayers).forEach(([id, player]) => {
          if (player.isIt) {
            winner = `${player.name} was IT!`;
          }
        });
      }
      
      document.getElementById('winner-text').textContent = winner;
      document.getElementById('gameOver').style.display = 'block';
      document.getElementById('pause-btn').style.display = 'none';
      document.getElementById('ui').style.display = 'none';
      document.getElementById('home-btn').style.display = 'none';
    }

    document.getElementById('gameOverBtn').addEventListener('click', () => {
      document.getElementById('gameOver').style.display = 'none';
      
      if (currentLobby) {
        // Reset for next game
        database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).update({ ready: false });
        
        if (isHost) {
          database.ref(`tagGame/lobbies/${currentLobby}`).update({
            gameEnded: false,
            timer: document.getElementById('lobby-time-input').value || 30
          });
        }
        
        hideAllScreens();
        document.getElementById('lobby-screen').style.display = 'block';
        document.getElementById('readyBtn').disabled = false;
        document.getElementById('readyBtn').textContent = 'READY';
        
        // Re-enable lobby listener
        showLobbyScreen(currentLobby);
      }
    });

    // Solo game start
    document.getElementById('startGameBtn').addEventListener('click', startSoloGame);

    function startSoloGame() {
      const timeLimit = parseInt(document.getElementById('time-input').value);
      if (isNaN(timeLimit) || timeLimit < 10) {
        alert("Please enter a valid time limit (minimum 10 seconds)");
        return;
      }
      
      switch(selectedBackground) {
        case 1: canvas.style.background = 'linear-gradient(135deg, #ff6ec4, #7873f5)'; break;
        case 2: canvas.style.background = 'linear-gradient(135deg, #667eea, #764ba2)'; break;
        case 3: canvas.style.background = 'linear-gradient(135deg, #f093fb, #f5576c)'; break;
      }
      
      randomizePlatforms();
      timer = timeLimit;
      hideAllScreens();
      document.getElementById('pause-btn').style.display = 'block';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('home-btn').style.display = 'block';
      document.getElementById('ui').textContent = `Time: ${timer}`;
      
      players = [];
      smartCircle = null;
      gameStarted = false;
      gameOver = false;
      frameCount = 0;
      lastTagTime = 0;
      currentlyTouching = {}; // Reset contact tracking
      
      const colors = ['red', 'green', 'blue', 'yellow'];
      const startPositions = [
        { x: 100, y: 100 }, { x: 1000, y: 100 }, { x: 100, y: 500 }, { x: 1000, y: 500 }
      ];
      
      const controlSchemes = [
        { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' },
        { up: 'w', down: 's', left: 'a', right: 'd' },
        { up: 't', down: 'g', left: 'f', right: 'h' },
        { up: 'i', down: 'k', left: 'j', right: 'l' }
      ];
      
      for (let i = 0; i < numPlayers; i++) {
        players.push({ 
          x: startPositions[i].x, y: startPositions[i].y, vx: 0, vy: 0, w: 30, h: 30, 
          color: colors[i], isIt: false, controls: controlSchemes[i],
          canDoubleJump: false, jumps: 0, lastJumpTime: 0
        });
      }
      
      if (robotMode) {
        smartCircle = {
          x: canvas.width / 2, y: canvas.height / 2, vx: 0, vy: 0,
          radius: 12, speed: 3.5, isIt: false, color: 'orange', targetCooldown: 0
        };
      }
      
      const totalEntities = players.length + (robotMode ? 1 : 0);
      const randomIndex = Math.floor(Math.random() * totalEntities);
      
      if (randomIndex < players.length) {
        players[randomIndex].isIt = true;
      } else if (robotMode && smartCircle) {
        smartCircle.isIt = true;
      }
      
      spawnTeleporters();
      
      let countdown = 3;
      const countdownDisplay = document.getElementById('countdown');
      countdownDisplay.style.display = 'block';
      countdownDisplay.textContent = countdown;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          countdownDisplay.textContent = countdown;
        } else {
          clearInterval(countdownInterval);
          countdownDisplay.textContent = "GO!";
          setTimeout(() => {
            countdownDisplay.style.display = 'none';
            gameStarted = true;
            gameLoop();
          }, 500);
        }
      }, 1000);
    }

    function randomizePlatforms() {
      currentPlatforms = basePlatforms.map(platform => {
        const minWidth = platform.w - 20;
        const maxWidth = platform.w + 50;
        const newWidth = Math.floor(Math.random() * (maxWidth - minWidth + 1)) + minWidth;
        return { x: platform.x, y: platform.y, w: newWidth, h: platform.h };
      });
    }

    function spawnTeleporters() {
      const accessiblePositions = [
        { x: 150, y: 300 }, { x: 1050, y: 300 }, { x: 600, y: 200 },
        { x: 600, y: 400 }, { x: 350, y: 200 }, { x: 850, y: 200 }
      ];
      
      const index1 = Math.floor(Math.random() * accessiblePositions.length);
      let index2;
      do {
        index2 = Math.floor(Math.random() * accessiblePositions.length);
      } while (index2 === index1);
      
      teleporters = [
        { x: accessiblePositions[index1].x, y: accessiblePositions[index1].y, radius: 12, active: true },
        { x: accessiblePositions[index2].x, y: accessiblePositions[index2].y, radius: 12, active: true }
      ];
    }

    // Smart circle update
    function updateSmartCircle() {
      if (!smartCircle || !gameStarted || gamePaused) return;
      
      if (smartCircle.targetCooldown > 0) smartCircle.targetCooldown--;
      
      let target = null;
      let minDistance = Infinity;
      
      if (smartCircle.isIt) {
        for (const player of players) {
          if (player && typeof player.x !== 'undefined') {
            const dx = player.x + player.w/2 - smartCircle.x;
            const dy = player.y + player.h/2 - smartCircle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minDistance) {
              minDistance = distance;
              target = { x: player.x + player.w/2, y: player.y + player.h/2 };
            }
          }
        }
      } else {
        const itPlayer = players.find(p => p && p.isIt);
        if (itPlayer) {
          const dx = itPlayer.x + itPlayer.w/2 - smartCircle.x;
          const dy = itPlayer.y + itPlayer.h/2 - smartCircle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 200) {
            target = { x: smartCircle.x - dx, y: smartCircle.y - dy };
          } else {
            if (smartCircle.targetCooldown <= 0) {
              target = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
              smartCircle.targetCooldown = 120;
            }
          }
        }
      }
      
      if (target) {
        const dx = target.x - smartCircle.x;
        const dy = target.y - smartCircle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          smartCircle.vx = (dx / distance) * smartCircle.speed;
          smartCircle.vy = (dy / distance) * smartCircle.speed;
        }
      }
      
      smartCircle.x += smartCircle.vx;
      smartCircle.y += smartCircle.vy;
      
      smartCircle.x = Math.max(smartCircle.radius, Math.min(canvas.width - smartCircle.radius, smartCircle.x));
      smartCircle.y = Math.max(smartCircle.radius, Math.min(canvas.height - smartCircle.radius, smartCircle.y));
    }

    // Player update
    function updatePlayer(p) {
      if (!gameStarted || gamePaused) return;
      
      if (keys[p.controls.left]) p.vx = -4;
      else if (keys[p.controls.right]) p.vx = 4;
      else p.vx = 0;

      const currentTime = Date.now();
      const jumpKey = p.controls.up;
      
      if (isGrounded(p)) {
        p.jumps = 0;
        p.canDoubleJump = true;
      }
      
      if (keyState[jumpKey] && keyState[jumpKey].justPressed) {
        if (p.jumps === 0 && isGrounded(p)) {
          p.vy = -10;
          p.jumps = 1;
          p.lastJumpTime = currentTime;
          keyState[jumpKey].justPressed = false;
        } else if (p.jumps === 1 && p.canDoubleJump && (currentTime - p.lastJumpTime) <= 700) {
          p.vy = -10;
          p.jumps = 2;
          p.canDoubleJump = false;
          keyState[jumpKey].justPressed = false;
        }
      }

      p.vy += gravity;
      p.x += p.vx;
      p.y += p.vy;

      if (p.y + p.h > canvas.height) {
        p.y = canvas.height - p.h;
        p.vy = 0;
      }

      // Platform collision - FIXED to prevent going through from below
      currentPlatforms.forEach(pl => {
        // Landing on top
        if (p.vy >= 0 && 
            p.x < pl.x + pl.w &&
            p.x + p.w > pl.x &&
            p.y + p.h >= pl.y &&
            p.y + p.h <= pl.y + pl.h + 10) {
          p.y = pl.y - p.h;
          p.vy = 0;
        }
        
        // Hitting from below - CRITICAL FIX
        if (p.vy < 0 && 
            p.x < pl.x + pl.w &&
            p.x + p.w > pl.x &&
            p.y <= pl.y + pl.h &&
            p.y + p.h >= pl.y) {
          p.y = pl.y + pl.h;
          p.vy = 0;
        }
        
        // Side collision
        if (p.x + p.w > pl.x && p.x < pl.x + pl.w &&
            p.y + p.h > pl.y && p.y < pl.y + pl.h) {
          if (p.vx > 0) {
            p.x = pl.x - p.w;
          } else if (p.vx < 0) {
            p.x = pl.x + pl.w;
          }
        }
      });

      // Bounce pad
      if (p.x < bouncePad.x + bouncePad.w &&
          p.x + p.w > bouncePad.x &&
          p.y + p.h >= bouncePad.y &&
          p.y + p.h <= bouncePad.y + bouncePad.h + 5) {
        p.vy = -20;
      }

      // Teleporters
      if (teleporters[0] && teleporters[0].active && teleporters[1] && teleporters[1].active) {
        for (let i = 0; i < teleporters.length; i++) {
          const tp = teleporters[i];
          const dx = (p.x + p.w/2) - tp.x;
          const dy = (p.y + p.h/2) - tp.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < tp.radius + p.w/2) {
            const target = teleporters[1 - i];
            p.x = target.x - p.w/2;
            p.y = target.y - p.h/2;
            p.vx = (Math.random() - 0.5) * 4;
            p.vy = -2;
            teleporters[0].active = false;
            teleporters[1].active = false;
            teleportCooldown = frameCount;
            break;
          }
        }
      }

      p.x = Math.max(0, Math.min(canvas.width - p.w, p.x));
      p.y = Math.min(canvas.height - p.h, p.y);
      
      // Sync position in multiplayer
      if (currentLobby && p.isLocal && frameCount % 3 === 0) {
        database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).update({
          x: Math.round(p.x),
          y: Math.round(p.y),
          vx: Math.round(p.vx),
          vy: Math.round(p.vy)
        });
      }
    }

    function isGrounded(p) {
      return (
        p.y + p.h >= canvas.height ||
        currentPlatforms.some(pl =>
          p.x < pl.x + pl.w &&
          p.x + p.w > pl.x &&
          p.y + p.h >= pl.y &&
          p.y + p.h <= pl.y + pl.h + 5
        )
      );
    }

    function detectPlayerTag(p1, p2) {
      return (
        p1.x < p2.x + p2.w &&
        p1.x + p1.w > p2.x &&
        p1.y < p2.y + p2.h &&
        p1.y + p1.h > p2.y
      );
    }

    function detectCirclePlayerTag(circle, player) {
      if (!circle || !player) return false;
      
      const dx = (player.x + player.w/2) - circle.x;
      const dy = (player.y + player.h/2) - circle.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < circle.radius + player.w/2;
    }

    // Drawing functions
    function drawTagIndicator(entity) {
      let orbX, orbY;
      if (entity.radius) {
        orbX = entity.x;
        orbY = entity.y - 20;
      } else {
        orbX = entity.x + entity.w / 2;
        orbY = entity.y - 12;
      }
      
      ctx.beginPath();
      ctx.arc(orbX, orbY, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'gold';
      ctx.shadowColor = 'gold';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawPlatforms() {
      currentPlatforms.forEach(pl => {
        ctx.fillStyle = '#8a5c36';
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(pl.x, pl.y, pl.w, 4);
      });

      ctx.fillStyle = '#00c853';
      ctx.fillRect(bouncePad.x, bouncePad.y, bouncePad.w, bouncePad.h);
      for (let i = 0; i < bouncePad.w; i += 8) {
        ctx.fillStyle = '#009624';
        ctx.fillRect(bouncePad.x + i, bouncePad.y, 4, bouncePad.h);
      }
    }

    function drawPlayers() {
      players.forEach(p => {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(p.x + 3, p.y + 3, p.w, p.h);
        
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(p.x + 8, p.y + 8, 6, 6);
        ctx.fillRect(p.x + p.w - 14, p.y + 8, 6, 6);
        
        if (p.isIt) drawTagIndicator(p);
      });
      
      if (currentLobby) {
        Object.entries(otherPlayers).forEach(([id, player]) => {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(player.x + 3, player.y + 3, 30, 30);
          
          ctx.fillStyle = player.color;
          ctx.fillRect(player.x, player.y, 30, 30);
          
          ctx.fillStyle = '#000';
          ctx.fillRect(player.x + 8, player.y + 8, 6, 6);
          ctx.fillRect(player.x + 30 - 14, player.y + 8, 6, 6);
          
          if (player.isIt) {
            drawTagIndicator({ x: player.x, y: player.y, w: 30, h: 30 });
          }
        });
      }
    }

    function drawSmartCircle() {
      if (!smartCircle) return;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.arc(smartCircle.x + 2, smartCircle.y + 2, smartCircle.radius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = smartCircle.color;
      ctx.beginPath();
      ctx.arc(smartCircle.x, smartCircle.y, smartCircle.radius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(smartCircle.x - 4, smartCircle.y - 4, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(smartCircle.x + 4, smartCircle.y - 4, 2, 0, Math.PI * 2);
      ctx.fill();
      
      if (smartCircle.isIt) drawTagIndicator(smartCircle);
    }

    function drawTeleporters() {
      teleporters.forEach(tp => {
        if (tp && tp.active) {
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius + 3, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 15;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ffeb3b';
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, tp.radius / 2, 0, Math.PI * 2);
          ctx.fillStyle = '#ffc107';
          ctx.fill();
          
          ctx.shadowBlur = 0;
        }
      });
    }

    // Game loop
    function gameLoop() {
      if (gameOver || !gameStarted) return;
      
      if (gamePaused) return;

      // Check if game has ended (for multiplayer)
      if (currentLobby && timer <= 0) {
        gameOver = true;
        gameStarted = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        // Don't call endGameForAll here - let Firebase signal handle it
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      frameCount++;

      drawPlatforms();

      if (teleporters[0] && !teleporters[0].active && frameCount - teleportCooldown > 300) {
        spawnTeleporters();
      }

      drawTeleporters();

      players.forEach(p => updatePlayer(p));
      drawPlayers();

      updateSmartCircle();
      drawSmartCircle();

      // Tag detection for solo
      if (!currentLobby) {
        const itPlayer = players.find(p => p.isIt);
        
        if (itPlayer) {
          const otherLocalPlayers = players.filter(p => !p.isIt);
          for (const otherPlayer of otherLocalPlayers) {
            const tagKey = `${players.indexOf(itPlayer)}-${players.indexOf(otherPlayer)}`;
            const collision = detectPlayerTag(itPlayer, otherPlayer);
            
            if (collision) {
              // They are touching
              if (!currentlyTouching[tagKey]) {
                // First contact - transfer tag
                currentlyTouching[tagKey] = true;
                itPlayer.isIt = false;
                otherPlayer.isIt = true;
                console.log('Tag!', itPlayer.color, '‚Üí', otherPlayer.color);
                break;
              }
              // else: Already touching, don't retag
            } else {
              // Not touching - clear the contact flag
              if (currentlyTouching[tagKey]) {
                currentlyTouching[tagKey] = false;
              }
            }
          }
        }

        if (smartCircle) {
          if (smartCircle.isIt) {
            for (let i = 0; i < players.length; i++) {
              const player = players[i];
              const tagKey = `circle-${i}`;
              const collision = player && detectCirclePlayerTag(smartCircle, player);
              
              if (collision) {
                if (!currentlyTouching[tagKey]) {
                  currentlyTouching[tagKey] = true;
                  smartCircle.isIt = false;
                  player.isIt = true;
                  console.log('Circle tagged player', i);
                  break;
                }
              } else {
                if (currentlyTouching[tagKey]) {
                  currentlyTouching[tagKey] = false;
                }
              }
            }
          } else {
            for (let i = 0; i < players.length; i++) {
              const player = players[i];
              const tagKey = `${i}-circle`;
              const collision = player && player.isIt && detectCirclePlayerTag(smartCircle, player);
              
              if (collision) {
                if (!currentlyTouching[tagKey]) {
                  currentlyTouching[tagKey] = true;
                  player.isIt = false;
                  smartCircle.isIt = true;
                  console.log('Player', i, 'tagged circle');
                  break;
                }
              } else {
                if (currentlyTouching[tagKey]) {
                  currentlyTouching[tagKey] = false;
                }
              }
            }
          }
        }
        
        // Solo timer
        if (frameCount % 60 === 0 && timer > 0) {
          timer--;
          document.getElementById('ui').textContent = `Time: ${timer}`;
        }

        if (timer === 0 && !gameOver) {
          gameOver = true;
          gameStarted = false;
          
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          
          let winner = '';
          const itPlayer = players.find(p => p.isIt);
          if (itPlayer) {
            winner = `${itPlayer.color.toUpperCase()} player was IT!`;
          } else if (smartCircle && smartCircle.isIt) {
            winner = 'SMART CIRCLE was IT!';
          }
          
          document.getElementById('winner-text').textContent = winner;
          document.getElementById('gameOver').style.display = 'block';
          document.getElementById('gameOverBtn').textContent = 'üè† Home';
          document.getElementById('gameOverBtn').onclick = goToModeSelect;
        }
      } else {
        // Multiplayer tag detection with contact tracking
        const itPlayer = players[0];
        
        if (itPlayer && itPlayer.isIt) {
          Object.entries(otherPlayers).forEach(([id, otherPlayer]) => {
            const tagKey = `${userId}-${id}`;
            const collision = (
              itPlayer.x < otherPlayer.x + 30 &&
              itPlayer.x + itPlayer.w > otherPlayer.x &&
              itPlayer.y < otherPlayer.y + 30 &&
              itPlayer.y + itPlayer.h > otherPlayer.y
            );
            
            if (collision) {
              // Players are touching
              if (!currentlyTouching[tagKey]) {
                // First contact - transfer tag
                console.log('Tagged:', id);
                currentlyTouching[tagKey] = true;
                itPlayer.isIt = false;
                database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).update({ isIt: false });
                database.ref(`tagGame/lobbies/${currentLobby}/players/${id}`).update({ isIt: true });
              }
              // else: Still touching, don't retag
            } else {
              // Not touching - clear contact flag
              if (currentlyTouching[tagKey]) {
                currentlyTouching[tagKey] = false;
              }
            }
          });
        }
        
        // Check if other players tag us
        Object.entries(otherPlayers).forEach(([id, otherPlayer]) => {
          const tagKey = `${id}-${userId}`;
          
          if (otherPlayer.isIt && players[0]) {
            const collision = (
              players[0].x < otherPlayer.x + 30 &&
              players[0].x + players[0].w > otherPlayer.x &&
              players[0].y < otherPlayer.y + 30 &&
              players[0].y + players[0].h > otherPlayer.y
            );
            
            if (collision) {
              // Players are touching
              if (!currentlyTouching[tagKey]) {
                // First contact - transfer tag
                console.log('Got tagged by:', id);
                currentlyTouching[tagKey] = true;
                players[0].isIt = true;
                database.ref(`tagGame/lobbies/${currentLobby}/players/${userId}`).update({ isIt: true });
                database.ref(`tagGame/lobbies/${currentLobby}/players/${id}`).update({ isIt: false });
              }
              // else: Still touching, don't retag
            } else {
              // Not touching - clear contact flag
              if (currentlyTouching[tagKey]) {
                currentlyTouching[tagKey] = false;
              }
            }
          }
        });
      }

      animationId = requestAnimationFrame(gameLoop);
    }

    console.log('‚úÖ Game initialized - Enter your name to start!');
  </script>
</body>
</html>
